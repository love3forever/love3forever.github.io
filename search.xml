<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ubuntu18.04开机卡logo界面问题的解决办法</title>
      <link href="/2018/11/21/ubuntu18.04%20%E5%BC%80%E6%9C%BA%E5%8D%A1logo%E7%95%8C%E9%9D%A2/"/>
      <url>/2018/11/21/ubuntu18.04%20%E5%BC%80%E6%9C%BA%E5%8D%A1logo%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>最近在台式机上装双系统，打算长期用ubuntu作为开发环境，一顿折腾把自己常用到的软件装的差不多了，重启机器的时候发现卡在了ubuntu的logo界面(就是登录页面之前的那个)，系统死活进不去了。</p><p>猜测可能的原因是：安装了teamviewer，设置了开机启动。<br><a id="more"></a><br>一番谷歌之后，发现通过ssh登录到机器上之后，使用命令<code>dpkg-reconfigure gdm3</code>之后，系统就能进到登录页面，之后的操作都是正常的。</p><p>你以为问题就这样解决了？<br>当然没有！</p><p>重启机器之后，发现又是一样卡在logo页面，难道每次启动都得ssh之通过命令重启gmd3吗？难受啊！<br>又一番谷歌之后，发现有说是显卡驱动的问题，有说是xorg的问题，按照他们的说法一顿操作猛如虎，重启之后依然进不去系统。想哭。</p><p>最后灵机一动，嘿嘿，gmd3总是进不去，那我不要你了行吗？<br><code>sudo apt install lightdm</code> =&gt; <code>sudo dpkg-reconfigure lightdm</code>，走你！<br>重启系统之后，登录页面顺利进入，一切照旧，舒服了。</p>]]></content>
      
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ubuntu18.04/win10双系统安装问题记录</title>
      <link href="/2018/11/12/ubuntu18.04%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/11/12/ubuntu18.04%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>恰好赶上双十一，打算凑凑热闹，买了块500G的固态硬盘打算升级一下台式机。<br>用了两年的机器，现在性能还是很够用的，但是考虑到台式机一直是作为游戏机的存在，应该拿来干点正事才对。索性，把新买的500G固态装windows,之前120G的固态用来装ubuntu开发机。<br>这里记录一下双系统安装过程中遇到的一些问题。<br><a id="more"></a></p><h2 id="使用三星自带工具迁移系统"><a href="#使用三星自带工具迁移系统" class="headerlink" title="使用三星自带工具迁移系统"></a>使用三星自带工具迁移系统</h2><p>下载并在windows中安装<a href="https://www.samsung.com/semiconductor/minisite/ssd/download/tools/" target="_blank" rel="noopener">Samsung Data Migration</a>，把新的固态硬盘插上，软件很简单易用，弄好之后重启系统即可使用新的固态盘作为系统盘。<br>另外，之前的系统盘可以格式化并且在windows中释放出来了。</p><h2 id="ubuntu-U盘安装"><a href="#ubuntu-U盘安装" class="headerlink" title="ubuntu U盘安装"></a>ubuntu U盘安装</h2><p>在ubuntu官网下载18.04系统iso文件,使用<a href="https://rufus.ie/en_IE.html" target="_blank" rel="noopener">Rufus</a>制作启动盘，搞完之后重启电脑从U盘启动即可进入ubuntu安装的步骤。</p><h2 id="ubuntu系统安装"><a href="#ubuntu系统安装" class="headerlink" title="ubuntu系统安装"></a>ubuntu系统安装</h2><p>系统安装的过程比较简单，但是在给系统分区的时候需要注意，我是这样分的:</p><table><thead><tr><th>mounted</th><th>size</th><th>filesystem</th><th>type</th></tr></thead><tbody><tr><td>/</td><td>25G</td><td>ext4</td><td>primary</td></tr><tr><td>/swap</td><td>8G</td><td>swap</td><td>logical</td></tr><tr><td>_</td><td>200MB</td><td>efi</td><td>_</td></tr><tr><td>/home</td><td>剩下的空间</td><td>ext4</td><td>logical</td></tr></tbody></table><p>其中efi的200MB很关键，要注意保留，然后就是不需要自己去分<code>/boot</code>。<br>其他的基本上都时一路next就行，完成安装之后，重启系统。</p><h2 id="修复启动引导"><a href="#修复启动引导" class="headerlink" title="修复启动引导"></a>修复启动引导</h2><p>按照上边操作，我遇到两种情况：</p><ol><li>进入<code>grub rescue</code></li><li>直接进入系统<br>上边两种情况都和理想中的不一样：默认进入ubuntu，系统启动项中有win10选项(通过ubuntu引导windows)。</li></ol><p>解决方案如下：</p><ol><li>还是从u盘启动，选择<code>try ubuntu without install</code>，进入之后使用以下命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">add-apt-repository ppa:yannubuntu/boot-repair</span><br><span class="line">apt update</span><br><span class="line">apt install boot-repair</span><br><span class="line">boot-repair</span><br></pre></td></tr></table></figure></li></ol><p>按照提示操作，一般就没问题了，提示成功之后，重启系统。</p><ol start="2"><li>这个时候，系统应该能够直接进入ubuntu，但是win10启动项没了，在命令行中运行：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-grub</span><br></pre></td></tr></table></figure></li></ol><p>即可修复启动项，重启之后可以看到效果。</p><p>双系统安装完成，可以愉快的玩耍了。</p>]]></content>
      
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>开发常用各种源设置</title>
      <link href="/2018/03/01/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%90%84%E7%A7%8D%E6%BA%90%E8%AE%BE%E7%BD%AE/"/>
      <url>/2018/03/01/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%90%84%E7%A7%8D%E6%BA%90%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在日常开发过程中，经常会受到国内网络环境限制导致类似：apt install大半天、brew install卡条、npm install一直转圈等诸多蛋疼的事情。<br>恰好我最近重装了笔记本操作系统，也记录一下我在开发过程中需要设置国内源改善开发环境的过程。<br><a id="more"></a></p><h1 id="ubuntu-apt-源"><a href="#ubuntu-apt-源" class="headerlink" title="ubuntu apt 源"></a>ubuntu apt 源</h1><p>使用台式机做开发的时候，通常会在ubuntu上进行。所以修改ubuntu的源是必不可少的：<br>Ubuntu 的软件源配置文件是 <code>/etc/apt/sources.list</code>，只需要根据自己的ubuntu版本修改这个文件内容即可：<br>比如我的版本是16.04 LTS:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure></p><p>更多的信息可以参考这里：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a></p><h1 id="homebrew-源"><a href="#homebrew-源" class="headerlink" title="homebrew 源"></a>homebrew 源</h1><p>在mac上经常会使用homebrew安装软件，使用国内的源可以有效提高软件安装效率：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span><br><span class="line"></span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line">brew update</span><br></pre></td></tr></table></figure></p><p>更多关于homebrew源设置可以参考：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/</a>以及<a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew-bottles/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/homebrew-bottles/</a></p><h1 id="pip-源"><a href="#pip-源" class="headerlink" title="pip 源"></a>pip 源</h1><p>修改<code>~/.pip/pip.conf</code>，如果没有此文件创建即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></p><p>更多关于pip的修改，可参考：<a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</a></p><h1 id="npm或yarn源"><a href="#npm或yarn源" class="headerlink" title="npm或yarn源"></a>npm或yarn源</h1><p>对于npm:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure></p><p>或者可以使用cnpm：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p><p>对于yarn：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn config set registry https://registry.npm.taobao.org --global</span><br><span class="line">yarn config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure></p><p>对于常用python+js开发的我来说，设置完上边这些基本上就不会为安装依赖或者更新软件而头疼啦。🍻🍻🍻</p>]]></content>
      
      
      
        <tags>
            
            <tag> pip </tag>
            
            <tag> ubuntu </tag>
            
            <tag> apt </tag>
            
            <tag> npm </tag>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react+cesium开发小结</title>
      <link href="/2018/02/23/react+cesium%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/02/23/react+cesium%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>从一月份开始，主要在做cesium的开发，和之前不同的是这次是在react框架的基础上进行开发的😄<br><a id="more"></a><br>先上一张现在开发内容的截图：<img src="https://eclipsesv.com/pics/cesium_preview.png" style="margin:auto;width: 700px;display: block"><br>外网可访问地址：<a href="https://service.eclipsesv.com/cesium/" target="_blank" rel="noopener">https://service.eclipsesv.com/cesium/</a>，限于服务器带宽和cesium打包之后的体积，访问速度确实很慢。<br>下边记录一下开发过程中一些不错的经验和思路：</p><h1 id="使用webpack打包cesium"><a href="#使用webpack打包cesium" class="headerlink" title="使用webpack打包cesium"></a>使用webpack打包cesium</h1><p>以往的开发过程中，cesium一般直接是用<code>&lt;srcipt&gt;</code>标签引入并使用的。但是如果想在react框架下很方便的开发，用webpack打包我们用到的第三方库会更可取。<br>cesium官网给出的连接也很明确的告诉用户如何使用webpack打包cesium：<a href="https://cesiumjs.org/tutorials/cesium-and-webpack/" target="_blank" rel="noopener">链接地址</a>。<br>我们只需要在新建的react项目的<code>webpack.config.js</code>中按照上边链接中的方法做即可。现在我们就可以通过<code>npm install cesium</code>或者<code>yarn add cesium</code>就可以把cesium引入项目开始使用啦。🍺🍺🍺</p><h1 id="在项目中引用cesium"><a href="#在项目中引用cesium" class="headerlink" title="在项目中引用cesium"></a>在项目中引用cesium</h1><p>目前主要有两种方法引入cesium中的对象：</p><ol><li><code>import Cesium from &#39;cesium/Cesium&#39;</code>，这种方法引入的<code>Cesium</code>能够涵盖大部分cesium内置的对象</li><li><code>import CesiumMath from &#39;cesium/Core/Math&#39;</code>，这种方法引入部分无法直接通过<code>Cesium</code>就能获取的内容<br>原理其实很简单：这两种不同的引入方式利用上边<code>webpack.config.js</code>中的配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const cesiumSource = &apos;node_modules/cesium/Source&apos;</span><br><span class="line">resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            // Cesium module name</span><br><span class="line">            cesium: path.resolve(__dirname, cesiumSource)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>我们在代码中<code>import</code>的时候，<strong>cesium</strong>其实代表的是<code>node_modules/cesium/Source</code>，这样的话，上边两种引入方式其实还是通过相对文件路径引入想要的内容。<br>如何区分该在什么时候用哪种引入方式？我现在的做法是通过查看<a href="https://cesiumjs.org/refdoc/" target="_blank" rel="noopener">cesium官方文档</a>来区分：<br>以最常用的<code>Viewer</code>在文档中是这样的<code>new Cesium.Viewer(container, options)</code>，这样看来只需要通过上边的第一种引入方法引入<code>Cesium</code>即可;<br>涉及数学运算的<code>CesiumMath    源码存在于：Core/Math.js 18</code>在文档中直接是这样的<code>CesiumMath()</code>，所以通过第二种方法引入<code>cesium/Core/Math</code>。</p><h1 id="cesium在react框架中的状态管理和控制"><a href="#cesium在react框架中的状态管理和控制" class="headerlink" title="cesium在react框架中的状态管理和控制"></a>cesium在react框架中的状态管理和控制</h1><p>cesium相关的开发主要集中在cesium图层控制管理和相关鼠标事件而核心的对象则是<code>Cesium.Viewer</code>。在react框架下，如果在某个react组件中实例化<code>Cesium.Viewer</code>对象之后，大部分操作都要围绕这个<code>Viewer</code>对象开展。<br>现在开发过程中，主要通过两种方式在组件间传递<code>Viewer</code>相关的内容：</p><ol><li>加入redux进行全局状态管理，主要针对cesium的各类图层状态</li><li>组件之间通过<code>props</code>传递鼠标事件或cesium状态</li></ol><h2 id="cesium影像图层的添加或移除"><a href="#cesium影像图层的添加或移除" class="headerlink" title="cesium影像图层的添加或移除"></a>cesium影像图层的添加或移除</h2><p>以影像图层控制为例，图层增删控制主要通过下边这个流程：<img src="https://eclipsesv.com/pics/redux_export.png" style="margin:auto;width: 700px;display: block"><br>我在viewerContainer.js中完成了<code>Cesium.Viewer</code>的实例化，在<code>componentDidMount()</code>中完成了一系列的初始化，并从配置文件中获取到所有可用的图层列表，将它们的信息存储在<code>imageryProviders</code>数组中。<code>imageryProviders</code>中的每个元素分别描述一个可用以加载的影像图层，包括图层编号、图层名称、图层对应的缩略图、用以解析此项配置的驱动等相关内容。<br>经过解析，在页面上用以展示图层信息通常只需要图层编号(id)，图层名称(name)，图层缩略图(thumbnail)，如图所示：<img src="https://eclipsesv.com/pics/data_list.png" style="margin:auto;width: 500;display: block"><br>所以将<code>imageryProviders</code>转变为<code>imageProviderProfile</code>，然后把<code>imageProviderProfile</code>以<strong>props</strong>的形式传递给用以展示数据列表的控件即可。<br>现在虽然能够完成数据列表的展示，可是如何才能控制<code>Viewer</code>上图层的变化呢？我在这里创建了一个<code>selectedImageryProviders</code>数组并使用redux在全局store中维护，这个数组用以保存当前三维球上到底是哪些图层在显示，数组中存储图层的编号(id)即可。<br>按照上边的思路，我在imageLayerManger.js中，通过<code>connect()</code>监听并控制<code>store.selectedImageryProviders</code>：通过界面按钮选择添加或移除图层的时候通过<code>selectProviderById()</code>触发reducer从而修改<code>selectedImageryProviders</code>。这样同样监听<code>store.selectedImageryProviders</code>的<code>viewerContainer.js</code>可以在生命周期函数<code>componentWillReceiveProps</code>中获取<code>selectedImageryProviders</code>的改变从而影响<code>Viewer</code>上图层的添加或者移除。<br>上边啰嗦这么多，也只是提供一个思路，按照这样的方法不仅能够完成影像图层的添加和移除，对于其他类型的数据：地形、矢量或者模型数据都可以按照这样的套路。</p><h1 id="遇到的问题和困难"><a href="#遇到的问题和困难" class="headerlink" title="遇到的问题和困难"></a>遇到的问题和困难</h1><p>在开发过程中遇到的问题和困难中要有以下几点:</p><ol><li>不熟悉webpack配置，开发前期遇到很多缺少webpack plugin的问题</li><li>不能准确拆分组件，组件之间的关系不清晰</li><li>在加入redux之后，全局store设计不够完善</li><li>用以页面展示的组件和处理逻辑的组件拆分不够</li><li>异步reducer使用不够熟练</li><li>webpack打包生产环境文件过大导致外网访问速度很慢</li></ol><p>通过这次项目的开发，react相关的内容也确实得到了锻炼，里边的很多思路和理念理解也都有进步，可以继续这个开发🍻🍻🍻</p>]]></content>
      
      
      
        <tags>
            
            <tag> cesium </tag>
            
            <tag> react </tag>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017小结</title>
      <link href="/2018/01/09/2017%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF%E5%B0%8F%E7%BB%93/"/>
      <url>/2018/01/09/2017%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>今天写完年度工作总结之后，才想起快有两个多月没有更新博客了，主要是因为从十月末开始，我的生活和工作环境都有比较大的变动，索性来一篇所谓的年度小结来概括一下2017这一整年值得纪念的点点滴滴。<br><a id="more"></a></p><h1 id="python相关"><a href="#python相关" class="headerlink" title="python相关"></a>python相关</h1><p>其实说来也巧，在学校的时候，从来没想过以后会用python来作为主要的开发语言，但是在接触python之后，就逐渐明白了<code>人生苦短，我用python</code>这句话的含义。在我看来，python之所以优秀，很大程度上还是整个python社区环境相对来说比较优秀。从科学计算、网络爬虫、web开发、界面开发再到2017年炒的火热的机器学习，哪里都有python身影的出现。而在这些背后，那些默默为整个社区无私奉献的开发者们的功劳不可磨灭。<br>2017年，python相关的内容，我又有哪些成长呢？</p><h2 id="夯实python-web技术栈"><a href="#夯实python-web技术栈" class="headerlink" title="夯实python web技术栈"></a>夯实python web技术栈</h2><p>在实际工作中，我主要的开发任务是做web开发。而python的web框架，我比较擅长的是flask。常用的技术如下图所示：</p><p><img src="https://eclipsesv.com/pics/bf.png" style="margin:auto;width: 450px;display: block"></p><ol><li>我会选择使用mongodb作为数据存储，因为通常情况下使用mongodb就可以满足我的需求，并且在开发过程中会有比较流畅的感觉。</li><li>redis可以作为数据缓存，而我更多的是使用它作为消息队列的一环，利用它的pub/sub来广播和接收消息，结合celery可以完成很多<a href="https://eclipsesv.com/2017/09/26/%E4%B8%80%E6%AC%A1%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/">需要异步执行的任务</a>。</li><li>在流行前端后端分离的今天，直接通过flask写jinja模版渲染已经是越来越少。更多的情况是后端提供数据接口，前后端直接通过ajax进行数据交互。所以，<a href="https://github.com/flask-restful/flask-restful" target="_blank" rel="noopener">flask-restful</a>就可以用来完成基于flask的rest api编写。</li><li>在前端需要后端主动推送消息的时候，基于http协议<code>请求/响应</code>模式无法满足需求，所以引入<a href="https://flask-socketio.readthedocs.io/en/latest/" target="_blank" rel="noopener">flask-socketio</a>就是为了完成类似这样的任务。</li><li>前后端分离，数据接口访问权限问题如何解决？我常用的方法是使用<a href="https://jwt.io/" target="_blank" rel="noopener">JWT</a>来进行用户身份识别。</li></ol><h2 id="Django尝鲜"><a href="#Django尝鲜" class="headerlink" title="Django尝鲜"></a>Django尝鲜</h2><p>在<a href="https://www.djangoproject.com/weblog/2017/dec/02/django-20-released/" target="_blank" rel="noopener">django2.0</a>发布之后，我还是尝试了一番。<br>尝试Django的主要原因有几个：</p><ol><li><p>深受正则表达式毒害的我很开心看到django路由语法简化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url(r&apos;^articles/(?P&lt;year&gt;[0-9]&#123;4&#125;)/$&apos;, views.year_archive)</span><br><span class="line">转变为：</span><br><span class="line">path(&apos;articles/&lt;int:year&gt;/&apos;, views.year_archive)</span><br></pre></td></tr></table></figure></li><li><p>以往通过flask进行web开发，底层数据库多是使用非关系行数据库（有一次需要使用oracle就体验了一把<a href="https://www.sqlalchemy.org/" target="_blank" rel="noopener">sqlalchemy</a>，感觉还行），如果是关系型数据库如mysql或者postgresql可能直接拿django会更方便一些。</p></li><li><code>django-admin</code>还是很不错的，能省下不少力。</li><li>django自身的开发文档很不错（当然flask的也不错）。</li></ol><h2 id="flask-vs-django"><a href="#flask-vs-django" class="headerlink" title="flask vs django"></a>flask vs django</h2><p>结合<a href="https://www.v2ex.com/t/273819" target="_blank" rel="noopener">这篇文章</a>，感觉flask和django在实际应用中适用的场景是有所不同的：</p><ol><li>数据库方面：如果系统采用的都是关系型数据库，直接使用django可能开发效率会高一点，因为自带的orm比较好用；如果使用nosql，那么就没有必要使用django，flask+nosql扩展会更加灵活好用，同样，如果项目结构不是很大，完全可以通过flask+SQLAlchemy进行数据库操作；</li><li>业务需求：如果业务需求仅仅是restful api，那么使用flask可能会是个更好的选择，如果项目需要一个比较完善的后台管理模块，django自带的admin模块应该能够满足需求。</li></ol><h2 id="python爬虫"><a href="#python爬虫" class="headerlink" title="python爬虫"></a>python爬虫</h2><p>和很多人一样，最开始接触python是从爬虫开始，由于我都是比较小型的爬取数据，所以<code>requests+bs4+mongodb</code>就可以满足需求：<br><img src="https://eclipsesv.com/pics/cf.png" style="margin:auto;width: 450px;display: block"></p><p>目前爬取的时候可能会遇到两种情况：</p><ol><li>网站后端渲染好html：这种情况可以使用requests爬取网页，交由bs4提取目标内容；</li><li>前后端分离：这种情况需要仔细分析该网站的ajax请求，找出并分析其中规则，通过requests模拟ajax请求，获取目标数据。</li></ol><p>反防爬措施：</p><ol><li>伪造请求头</li><li>使用ip proxy</li><li>使用像<a href="http://www.seleniumhq.org/" target="_blank" rel="noopener">Selenium</a>这样的浏览器工具模拟人为操作。</li></ol><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>其实很早之前就有这方面的兴趣，无奈数学基础不好，一只没付诸行动。在年底，我们这样的一个公司居然都准备采用机器学习进行视频检测，我觉得是时候补一补数据基础，把这个技能点上了。<br>初步打算：</p><ol><li>复习<a href="https://book.douban.com/subject/2197140/" target="_blank" rel="noopener">《线性代数》</a>和<a href="https://book.douban.com/subject/10590856/" target="_blank" rel="noopener">《统计学习方法》</a></li><li>机器学习相关python基础库<a href="http://www.numpy.org/" target="_blank" rel="noopener">numpy</a>、<a href="https://matplotlib.org/" target="_blank" rel="noopener">matplotlib</a></li><li>学习tensorflow相关demo</li></ol><h1 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h1><p>还是那句话，前后端分离的开发方式，让以往只会用bootstrap、jQuery的我都不好意思说我是做python web的。</p><h2 id="初识vue"><a href="#初识vue" class="headerlink" title="初识vue"></a>初识vue</h2><p>上半年接触了目前比较火的前端框架vue。一开始我是拒绝的，因为用惯了jQuery，在开发思路上一时半会儿转变不过来。在初步理解了它的<code>数据驱动页面</code>的思想之后，发现原来前端开发也可以这么爽。<br>使用vue，不可避免的会接触es6：箭头函数、迭代器、生成器、模块、promise，我只能说“学习使我快乐”。另外，webpack、npm、yarn这些工具加速了前端工程化的进程。其实差不多可以完全改变了我之前对于前端开发的认识。</p><h2 id="浅尝react"><a href="#浅尝react" class="headerlink" title="浅尝react"></a>浅尝react</h2><p>年末，女朋友也来武汉工作，公司前端主要使用react，她也一直怂恿我一起来学react（其实vue学了半吊子的我一开始也是拒绝的）。相比来说，react上手要比vue慢很多，我也是断断续续用了两周时间看react相关的文档。在真正用来做点东西的时候，才发现仅仅会用react是根本不够的：你会遇到管理前端路由的react-router，管理组件状态的redux。在初步理解了redux的store、action和reducer之后，你又会发现<code>redux-thunk</code>、<code>redux-orm</code>等等相关的一系列轮子都可能会用到，<strong>这真的是在做前端开发吗？</strong></p><p>2017年，也可以说是恰好赶上了前端迅速发展的一年，加入前端开发，才会真正发现前端开发很可能已经不是你印象中的样子。2018年，我猜我会投入更多的时间在前端。</p><h1 id="其他技术栈展望"><a href="#其他技术栈展望" class="headerlink" title="其他技术栈展望"></a>其他技术栈展望</h1><h2 id="语言方面"><a href="#语言方面" class="headerlink" title="语言方面"></a>语言方面</h2><ol><li>go语言，想要在2018用go做一个web应用</li><li>java，之前用springboot做过开发，比较有好感，可以尝试在一些快速开发的项目中使用</li><li>node，尝试使用koa做一些事情</li></ol><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li>postgresql，使用postgresql作为数据存储开发项目，结合postgregis完成一些gis应用</li><li>mysql，毕竟目前使用很广泛，学习一下也是很不错的</li><li>neo4j，之前只是尝试，希望可以和机器学习相结合，做一些有趣的事情</li></ol><p><i>总之，作为技术人，我希望在2018年投入更多的时间来夯实现有技术栈，多读书、读好书，拓阔视野，多与人交流分享想法。</i></p><p>相对于技术方面的成长，2017年我在其他方面的成长可能更大。</p><h1 id="西安之旅"><a href="#西安之旅" class="headerlink" title="西安之旅"></a>西安之旅</h1><p>2017年是在西安开始的。我和三哥相约来西安开始了吃吃吃之旅。看看我们都去过哪就知道啦：<br><img src="https://eclipsesv.com/pics/c.png" style="margin:auto;width: 450px;display: block"><br>那几天可以说是非常开心啦。一起去去大雁塔，上明城墙骑行，看钟楼夜景。假期很短，相见有点难。</p><h1 id="南下求职"><a href="#南下求职" class="headerlink" title="南下求职"></a>南下求职</h1><p>在完成出差任务后，一天从承德来到武汉找工作：<br><img src="https://eclipsesv.com/pics/nx.PNG" style="margin:auto;width: 450px;display: block"><br>面试过程比较顺利，顺便和之前的同学、师弟师妹聚餐，感叹时光匆匆。</p><h1 id="好友结婚"><a href="#好友结婚" class="headerlink" title="好友结婚"></a>好友结婚</h1><p>从之前的单位辞职之后，回家参加从小到大的好朋友婚礼。<br><img src="https://eclipsesv.com/pics/jh.png" style="margin:auto;width: 450px;display: block"><br>第一次当伴郎，衷心祝愿他们能够幸福。</p><h1 id="领养二狗"><a href="#领养二狗" class="headerlink" title="领养二狗"></a>领养二狗</h1><p>在微博上领养的二狗：<br><img src="https://eclipsesv.com/pics/gzi.png" style="margin:auto;width: 450px;display: block"><br>这个名字没白起，二狗真的是像狗一样的猫。</p><h1 id="见家长"><a href="#见家长" class="headerlink" title="见家长"></a>见家长</h1><p>幸亏可爱的女朋友的渗透工作，这次见家长可以用“大吉大利，今晚吃鸡”来总结啦：</p><p><img src="https://eclipsesv.com/pics/djdl.JPG" style="margin:0 auto;width: 450px;display: block"></p><h1 id="来我家"><a href="#来我家" class="headerlink" title="来我家"></a>来我家</h1><p>哈哈哈<br>用一句话总结“王叁很优秀，我们很满意“<br>由于恰好是十一假期，还跑洛阳玩了一趟。</p><h1 id="王炸"><a href="#王炸" class="headerlink" title="王炸"></a>王炸</h1><p>盼星星盼月亮，三哥也来武汉工作了，一起度过了艰难的找工作阶段、辛苦的学习阶段，现在算是相对稳定了，我们还一起布置了我们所谓的”工作间“(游戏厅？)：<br><img src="https://eclipsesv.com/pics/yxt.JPG" style="margin:auto;width: 450px;display: block"><br>希望可以在里面读更多的书，学更多的知识，看更多的好片儿还有玩更多的游戏。</p><p><strong><br>    最后，希望在2018年自己的工作能够更加满意，生活可以往自己理想的方向更近一步，希望家人健康平安。<br></strong></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>前端项目的自动化测试和部署初试</title>
      <link href="/2017/11/17/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%92%8C%E9%83%A8%E7%BD%B2/"/>
      <url>/2017/11/17/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%92%8C%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>项目的正常运行离不开完备的测试和正确的部署。通常在项目开发的过程中，我们会写出不同类型的测试从而最大程度的减少bug查找修复时间、降低项目重构成本、增加项目迭代过程中对代码质量的信心，保证项目正常上线。为了能够给用户呈现最新的项目开发成果，一次次手动拷贝代码、登陆远程主机、配置代码运行环境显然比较低效。所以，自动化测试和部署能够有效提升项目开发效率。<br>这篇博客也是总结一下我最近在开发的一个前端项目中使用<strong>jenkins+gitlab</strong>进行自动化测试和部署的过程。<br><a id="more"></a></p><h1 id="jenkins的安装和配置"><a href="#jenkins的安装和配置" class="headerlink" title="jenkins的安装和配置"></a>jenkins的安装和配置</h1><p>我是在阿里云主机上搭建的jenkins服务器，云主机配置：</p><ul><li>操作系统: Ubuntu 16.04.2</li><li>内存: 2GB</li><li>CPU: 1核</li><li>硬盘：40GB</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>需要一个拥有sudo权限的非root用户</li><li>登陆主机，将jenkins的apt key加入系统： <code>wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add -</code></li><li>将jenkins的包地址加入系统的<code>source.list</code>: <code>echo deb https://pkg.jenkins.io/debian-stable binary/ | sudo tee /etc/apt/sources.list.d/jenkins.list</code></li><li>执行安装: <code>sudo apt-get update &amp;&amp; sudo apt-get install jenkins</code></li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>按照上述步骤，即可完成安装，现在启动jenkins，使用命令<code>sudo systemctl start jenkins</code>。一般来说这样直接访问8080端口就可以用了，但是不知道什么原因，虽然日志里边启动成功，但无法访问8080端口。一番查询发现通过这个命令：<code>java -jar /usr/share/jenkins/jenkins.war</code>可以正常启动jenkins。或者将jenkins启动写成一个脚本:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/daemon --name=jenkins --inherit --env=JENKINS_HOME=/var/lib/jenkins \</span><br><span class="line">--output=/var/log/jenkins/jenkins.log --pidfile=/var/run/jenkins/jenkins.pid \</span><br><span class="line">-- /usr/bin/java -Djava.awt.headless=true -jar /usr/share/jenkins/jenkins.war\</span><br><span class="line">--webroot=/var/cache/jenkins/war --httpPort=8080</span><br></pre></td></tr></table></figure></li><li><p>接下来访问8080端口进行登录，初次登陆会让你设置一个root用户：<img src="https://eclipsesv.com/pics/first_login.png" style="margin:auto;width: 700px;display: block">，按照图片中的指引，拷贝密码<code>sudo cat /var/lib/jenkins/secrets/initialAdminPassword</code>，进入下一步。</p></li><li>安装推荐的插件：<img src="https://eclipsesv.com/pics/suggested_plugin.png" style="margin:auto;width: 700px;display: block"><br> 并且将gitlab相关的插件也一并下载。</li><li>创建管理员用户：<img src="https://eclipsesv.com/pics/create_admin.png" style="margin:auto;width: 700px;display: block"></li><li>创建gitlab api token：<br> 打开gitlab api token页面：访问地址<a href="https://gitlab.com/profile/personal_access_tokens" target="_blank" rel="noopener">https://gitlab.com/profile/personal_access_tokens</a><img src="https://eclipsesv.com/pics/jenkins_apitoken.png" style="margin:auto;width: 700px;display: block"><br> 创建token，并保存token值；<br> 打开jenkins设置gitlab api token：访问地址<a href="https://host:port/credentials/store/system/domain/_/newCredentials" target="_blank" rel="noopener">https://host:port/credentials/store/system/domain/_/newCredentials</a><img src="https://eclipsesv.com/pics/jenkins_apiset.png" style="margin:auto;width: 700px;display: block"><br> 将刚才保存的api token填写一下保存即可。</li><li>创建gitlab连接，为下一步做准备：<img src="https://eclipsesv.com/pics/gitlab_connect.png" style="margin:auto;width: 700px;display: block"><br> 需要填写<code>Connection name:gitlab</code>、<code>Gitlab host URL:https://gitlab.com</code>、<code>Credentials:gitlab api token</code>。<br> 这里需要注意两点：<code>Enable authentication for &#39;/project&#39; end-point</code>需要勾掉，不然会影响gitlab githook的设置；<code>Credentials</code>的设置选择刚才创建的<code>gitlab api token</code>即可。</li><li>新建jenkins pipeline任务：<img src="https://eclipsesv.com/pics/pipeline_demo.png" style="margin:auto;width: 700px;display: block"></li></ol><p>通过上述几步，可以完成jenkins的初步配置，完成登陆。接下来可以配置gitlab相关内容，为自动化测试和部署做准备。</p><h1 id="gitlab-githook"><a href="#gitlab-githook" class="headerlink" title="gitlab githook"></a>gitlab githook</h1><p>接下来，设置gitlab的githook：在你的gitlab项目页面中找到<a href="https://gitlab.com/[username]/[projectname]/settings/integrations" target="_blank" rel="noopener">https://gitlab.com/username/projectname/settings/integrations</a>，需要设置的就是<code>URL</code>，此处的url就是上边新建的jenkins任务对应的地址，比如我的:<code>https://service.eclipsesv.com/project/rc-pipeline</code><br>如下图：<img src="https://eclipsesv.com/pics/githook.png" style="margin:auto;width: 700px;display: block"><br>完成设置之后保存即可。</p><h1 id="jenkins-pipeline"><a href="#jenkins-pipeline" class="headerlink" title="jenkins pipeline"></a>jenkins pipeline</h1><p>关于这个任务的配置只需要按照下边的图即可：<img src="https://eclipsesv.com/pics/pipeline_config.png" style="margin:auto;width: 700px;display: block"><br>需要注意的是：<code>gitlab connection</code> 设置为上边设置好的gitlab连接，<code>GitLab Repository Name</code>设置为你要测试部署项目的名称。<br>最后也是最关键的，设置这个jenkins任务的pipeline script：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">   echo &apos;Hello World&apos;</span><br><span class="line">   # 检出代码</span><br><span class="line">   stage(&apos;Checkout code&apos;)&#123;</span><br><span class="line">       checkout([$class: &apos;GitSCM&apos;, branches: [[name: &apos;*/master&apos;]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: &apos;c*****************&apos;, url: &apos;git@gitlab.com:wangmengcn/react-cesium.git&apos;]]])</span><br><span class="line">   &#125;</span><br><span class="line">   # 安装依赖包</span><br><span class="line">   stage(&apos;Init env&apos;)&#123;</span><br><span class="line">       sh &apos;yarn install&apos;</span><br><span class="line">   &#125;</span><br><span class="line">   # 运行测试</span><br><span class="line">   stage(&apos;Run test&apos;)&#123;</span><br><span class="line">       sh &apos;yarn ctest&apos;</span><br><span class="line">   &#125;</span><br><span class="line">   # 代码构建</span><br><span class="line">   stage(&apos;Run build&apos;)&#123;</span><br><span class="line">       sh &apos;yarn cbuild&apos;</span><br><span class="line">   &#125;</span><br><span class="line">   # 发布生成结果</span><br><span class="line">   stage(&apos;Deploy code&apos;)&#123;</span><br><span class="line">       sh &apos;cd dist&apos;</span><br><span class="line">       sh &apos;ls&apos;</span><br><span class="line">       sh &apos;rm -rf /var/lib/jenkins/cesium/*&apos;</span><br><span class="line">       sh &apos;cp -r dist/* /var/lib/jenkins/cesium&apos;</span><br><span class="line">   &#125;</span><br><span class="line">   # 清理项目目录</span><br><span class="line">   stage(&apos;Clean workspace&apos;)&#123;</span><br><span class="line">       deleteDir()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设置完成之后，每次push到master的代码都会触发新的build和deploy：<img src="https://eclipsesv.com/pics/jenkins_run.png" style="margin:auto;width: 700px;display: block"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇博客主要是介绍了jenkins+gitlab进行自动化测试和部署前端项目的一个流程，当然可以通过jenkins强大的插件系统完成除了上边这些功能以外的复杂工作，在以后的工作学习过程中养成良好习惯，让测试和部署尽量能够自动化完成。🍻🍻🍻</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化 </tag>
            
            <tag> react </tag>
            
            <tag> jenkins </tag>
            
            <tag> gitlab </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用docker安装jenkins</title>
      <link href="/2017/11/09/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85jenkins/"/>
      <url>/2017/11/09/%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85jenkins/</url>
      
        <content type="html"><![CDATA[<p>最近在学习jenkins相关的东西，想在自己电脑上安装一套jenkins环境，发现可以通过docker来完成这个任务，下面主要记录一下安装过程。<br><a id="more"></a></p><h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><ol><li>到docker官网上找到适配自己操作系统的安装包：<a href="https://store.docker.com/search?offering=community&amp;type=edition" target="_blank" rel="noopener">网站地址</a>，我用的是mac，可以直接下载dmg文件然后安装。</li><li>到<a href="https://cloud.docker.com/" target="_blank" rel="noopener">docker官网</a>完成用户注册并进行登录：<img src="https://eclipsesv.com/pics/docker_login.png" style="margin:auto;width: 500px;display: block"></li></ol><h1 id="jenkins镜像下载安装"><a href="#jenkins镜像下载安装" class="headerlink" title="jenkins镜像下载安装"></a>jenkins镜像下载安装</h1><ol><li><p>在命令行中登录docker:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker login</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. </span><br><span class="line">If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">Username: ******</span><br><span class="line">Password:</span><br></pre></td></tr></table></figure></li><li><p>拉取jenkins的docker镜像:<br> 这里需要注意，如果需要拉取像jenkins这样的公共镜像的时候，默认的docker镜像源国内访问速度是很慢的，只需要简单配置一下即可，可以<a href="https://www.docker-cn.com/registry-mirror" target="_blank" rel="noopener">参考这里</a>，我是直接在docker客户端中设置：<img src="https://eclipsesv.com/pics/docker_source.png" style="margin:auto;width: 500px;display: block"><br> 然后执行下边这条命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --rm \</span><br><span class="line">  -u root \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  -v jenkins-data:/var/jenkins_home \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  -v &quot;$HOME&quot;:/home \</span><br><span class="line">  jenkinsci/blueocean</span><br></pre></td></tr></table></figure><p> 等待即可：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Unable to find image &apos;jenkinsci/blueocean:latest&apos; locally</span><br><span class="line">latest: Pulling from jenkinsci/blueocean</span><br><span class="line">ff3a5c916c92: Pull complete</span><br><span class="line">5de5f69f42d7: Pull complete</span><br><span class="line">fd869c8b9b59: Downloading  4.865MB/70.23MB</span><br><span class="line">97056f636d5a: Downloading  6.481MB</span><br><span class="line">b8735f69f698: Download complete</span><br><span class="line">fd869c8b9b59: Downloading  5.947MB/70.23MB</span><br><span class="line">569dbe3bfcf5: Download complete</span><br><span class="line">28a1b4b2f3f2: Downloading  3.784MB/74.1MB</span><br><span class="line">bc956c71de07: Waiting</span><br><span class="line">bbf22d011438: Waiting</span><br><span class="line">f3870509cbc0: Waiting</span><br><span class="line">60946888fa2b: Waiting</span><br><span class="line">1fa1da5a0b03: Waiting</span><br><span class="line">bd3e69432b5e: Waiting</span><br><span class="line">b65024d480a6: Waiting</span><br></pre></td></tr></table></figure><p> 完成镜像拉取之后，jenkins就直接在docker中运行了。</p></li><li><p>完成登陆设置：之前做了端口映射，直接打开本地浏览器访问：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>之后进行配置即可。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> jenkins </tag>
            
            <tag> docker </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>离线环境python项目的部署</title>
      <link href="/2017/10/24/%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83python%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
      <url>/2017/10/24/%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83python%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>最近自己参与的一个项目接近尾声，需要把代码部署到甲方提供的服务器。本来想着没有什么困难，谁知道甲方提供的服务器需要连接到vpn堡垒机之后才能连接，并且服务器是不能与外网直接连接的。知道真相的我眼泪掉下来。<br><a id="more"></a><br>平常的开发中，用惯了<code>pip install xxxx</code>或者是<code>pip install -r requirements.txt</code>，没怎么考虑过如何在与外网隔离并且是一个裸机的服务器上部署python项目(当然，如果项目依赖比较少，可以直接下载源码安装，如果依赖比较多就会比较麻烦)。<br>经过一番搜索发现了一款神器：<a href="https://github.com/wolever/pip2pi" target="_blank" rel="noopener">pip2pi</a>，它能够把当前项目的依赖项放置在一个目录中，然后把这些依赖放到服务器上再使用<code>pip</code>安装。</p><h1 id="具体用法"><a href="#具体用法" class="headerlink" title="具体用法"></a>具体用法</h1><p>在使用<code>pip2pi</code>打包项目依赖之前，需要找一个和服务器环境相同的虚拟机：比如说服务器操作系统是centos6.5、python版本是2.7，那就需要自己弄个虚拟机把环境搞一致再下载依赖项。<br>详细步骤如下：</p><ol><li>为了避免多余依赖的引入，最好是用<code>virtualenv</code>创建一个隔离环境：<code>virtualenv packages</code></li><li><p>获取当前项目的所有依赖，进入隔离环境，将项目的依赖项完整下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd /path/to/project</span><br><span class="line">pip freeze &gt; requirements.txt</span><br><span class="line">cp requirements.txt /path/to/packages/</span><br><span class="line"></span><br><span class="line">cd /path/to/packages</span><br><span class="line">source bin/active</span><br><span class="line">pip install pip2pi</span><br><span class="line">mkdir dependences</span><br><span class="line">pip2pi /path/to/packages/dependences --no-use-wheel -r requirements.txt</span><br></pre></td></tr></table></figure></li><li><p>将下载好的依赖项放在服务器，执行命令安装依赖，第一遍安装可能跳过某些依赖项，可以多次执行这个命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --no-index --find-links=file:///path_to/packages/dependences -r requirements.txt</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 离线环境 </tag>
            
            <tag> pip2pi </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在vultr上搭建shadowsocks</title>
      <link href="/2017/10/13/%E5%9C%A8vultr%E4%B8%8A%E6%90%AD%E5%BB%BAshadowsock/"/>
      <url>/2017/10/13/%E5%9C%A8vultr%E4%B8%8A%E6%90%AD%E5%BB%BAshadowsock/</url>
      
        <content type="html"><![CDATA[<p>为啥突然想要自己搭一个shadowsocks呢，事情的起因是这样的：<a href="https://github.com/getlantern/forum" target="_blank" rel="noopener">蓝灯</a>这个项目在<a href="https://github.com/trending" target="_blank" rel="noopener">git trending</a>上连续上榜多日，看了评论发现原来这个东西是个vpn，很多人用来当梯子。因为最近种种原因这个梯子现在用不成了，所以很多用户跑来吐槽。我一直比较懒，都是直接买的现成的vpn，现在一直在用这个官网经常上不去的<a href="https://netfits.net.cn/" target="_blank" rel="noopener">netfits</a>，总体感觉还行，就是价格有点贵，所以趁着这个十一长假之后的第一个周五下午来搞点事情，搭一个自己的ss服务器。<br><img src="https://eclipsesv.com/pics/lantern.png" alt="lantern.png"><br><a id="more"></a><br>经过一番对比，我最终选择使用<a href="https://www.vultr.com/" target="_blank" rel="noopener">vultr</a>的主机(主要是因为价格不贵还可以用支付宝支付😂)，本来想用日本的节点，搭完之后发现ping不到主机，最终选择了新加坡的节点，搭配1000GB/5$/月的套餐(一个月30多块，netfits怕是只有10GB吧)。<br><img src="https://eclipsesv.com/pics/conf.png" alt="conf.png"></p><h1 id="shadowsocks服务安装"><a href="#shadowsocks服务安装" class="headerlink" title="shadowsocks服务安装"></a>shadowsocks服务安装</h1><p>安装过程十分简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line">&gt; chmod +x shadowsocks.sh</span><br><span class="line">&gt; ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure></p><p>三条命令，外加配置密码、开放端口、加密方式这些就行。<br>如果后期需要修改配置，去修改<code>/etc/shadowsocks.json</code>这个文件即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_port&quot;:33333,</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;abc@123&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;fast_open&quot;:true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="shadowsocks客户端配置"><a href="#shadowsocks客户端配置" class="headerlink" title="shadowsocks客户端配置"></a>shadowsocks客户端配置</h1><p>服务配好之后，下载自己需要的客户端就行：<a href="https://github.com/shadowsocks/shadowsocks-windows" target="_blank" rel="noopener">windows版本</a>、<a href="https://github.com/shadowsocks/ShadowsocksX-NG" target="_blank" rel="noopener">mac版本</a>。<br>手机的话，我在app store里边找了个一个18块钱的shadoWingy应用，也是需要简单的配置一下就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 瞎搞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vultr </tag>
            
            <tag> shadowsock </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一次异步任务的执行过程</title>
      <link href="/2017/09/26/%E4%B8%80%E6%AC%A1%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
      <url>/2017/09/26/%E4%B8%80%E6%AC%A1%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个小型的mongodb运维工具，在开发的过程中想要实现mongodb数据库备份的功能：前端页面提供一个按钮，用户点击之后向后端post想要备份哪个数据库，后端接到请求之后将这个任务发给异步任务队列，在数据库完成备份之后，后端推送一个包含此次备份详情的消息给前端页面，并且提供一个能够下载此备份文件的链接。<br>我的实现方法可以用下边这个图来表达：<br><img src="https://eclipsesv.com/pics/task-flow.png" alt="task-flow.png"><br><a id="more"></a></p><h1 id="实现过程和遇到的问题"><a href="#实现过程和遇到的问题" class="headerlink" title="实现过程和遇到的问题"></a>实现过程和遇到的问题</h1><p>首先，介绍一下我在这里用到的一些技术组成：前端直接使用vue，后端使用flask提供restful服务，使用flask-jwt来扩展用户认证的功能、使用flask-socketio扩展给前后端之间增加websocket的通讯方式。Celery当作异步任务队列，执行长耗时的任务。使用Fabric来执行一些流程化的任务(比如在服务器本地执行数据库备份)。Redis在这里充当消息队列，负责flask和celery之间的消息通信(多亏了flask-socketio这个库)。</p><h2 id="jwt权限认证"><a href="#jwt权限认证" class="headerlink" title="jwt权限认证"></a>jwt权限认证</h2><p>现在的web开发，都逐渐偏向前后端分离的模式，前后端之间的通讯大都是通过数据接口的形式来进行。那么前端发来一个数据请求，后端该如何知道是谁在请求数据、数据请求者有没有权限访问这些数据资源呢？我这次尝试使用JWT(JSON Web Tokens)来进行用户认证。<br>由于后端使用的是flask+flask-restful来提供rest数据服务，所以我直接找到一个flask的jwt扩展:<a href="https://pythonhosted.org/Flask-JWT/" target="_blank" rel="noopener">Flask-JWT</a>。在使用的过程中也十分方便，你需要做的有以下几点：</p><ol><li>创建User：<br>创建User的目的是在之后的认证过程中，通过User的username和passowrd来生成token。这里的User必须的三个属性：username、password、id。</li><li><p>完成jwt的基础配置：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># jwt相关</span><br><span class="line">jwt_config = &#123;</span><br><span class="line">    &apos;JWT_SECRET_KEY&apos;: &apos;jwt_secret&apos;,</span><br><span class="line">    &apos;JWT_AUTH_URL_RULE&apos;: &apos;/api/v1/auth&apos;,</span><br><span class="line">    &apos;JWT_EXPIRATION_DELTA&apos;: timedelta(days=1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里需要注意的是：如果flask自身的配置没有<code>SECRET_KEY</code>这一项，jwt必须自己配置<code>JWT_SECRET_KEY</code>，否则flask-jwt会在使用的过程中报错：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Expecting a string- or bytes-formatted key.</span><br></pre></td></tr></table></figure><p> 另外一些其他的相关配置，都可以在flask-jwt的文档中找到。</p></li><li><p>实现jwt认证过程方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def authenticate(username, password):</span><br><span class="line">    # 用户身份认证</span><br><span class="line">    user = User(username, password)</span><br><span class="line">    flag, _ = user.check_password()</span><br><span class="line">    if flag:</span><br><span class="line">        return user</span><br><span class="line">    else:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">def identity(payload):</span><br><span class="line">    print(payload)</span><br><span class="line">    if payload:</span><br><span class="line">        user_id = payload[&apos;identity&apos;]</span><br><span class="line">        # 返回值为之后的current_identity</span><br><span class="line">        return User.gen_user_by_id(user_id)</span><br><span class="line">    else:</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure></li><li><p>完成jwt配置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.update(jwt_config)</span><br><span class="line">jwt = JWT(app, authenticate, identity)</span><br></pre></td></tr></table></figure><p> 通过上述的几个步骤，就可以简单的构建一个由jwt来守护的数据服务了，在初次认证获取token的时候，可以通过向<code>JWT_AUTH_URL_RULE</code>所指向的url post自己的用户名和密码即可。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">→ http POST http://localhost:11111/api/v1/auth username=aaa password=bbb</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 226</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Wed, 27 Sep 2017 05:12:54 GMT</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;access_token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZGVudGl0eSI6IjU5YjVlZDM3NzY0NTBiZjBhYjc1ODE3OCIsImlhdCI6MTUwNjQ4OTE3NCwibmJmIjoxNTA2NDg5MTc0LCJleHAiOjE1MDY1NzU1NzR9.1mZhsu7JU_mAV88TtPmG70iV9Z78QBf0bKKiAGqP6ZE&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@jwt_required和current_identity<br>加入jwt是想让它来保护我的数据服务，这个实现过程十分简单，只需要在需要保护的地方添加<code>@jwt_required</code>这个装饰器即可，而从flask_jwt中引入的<code>current_identity</code>更是能够获得当前请求数据的用户是谁，就像之前通过flask_login中通过<code>current_user</code>获取当前用户一样。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from flask_jwt import jwt_required, current_app, current_identity</span><br><span class="line"></span><br><span class="line">@api_mongo.resource(&apos;/&lt;string:db&gt;/status&apos;)</span><br><span class="line">class DatabaseStatus(Resource):</span><br><span class="line">    &quot;&quot;&quot;docstring for DatabaseStatus&quot;&quot;&quot;</span><br><span class="line">    @jwt_required()</span><br><span class="line">    def get(self, db):</span><br><span class="line">        try:</span><br><span class="line">            db = mongo.get_database(db)</span><br><span class="line">            data = db.command(&quot;dbstats&quot;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(str(e))</span><br><span class="line">            abort(404)</span><br><span class="line">        else:</span><br><span class="line">            return make_response(jsonify(data))</span><br></pre></td></tr></table></figure></li></ol><h2 id="vue-resource获取后端数据"><a href="#vue-resource获取后端数据" class="headerlink" title="vue-resource获取后端数据"></a>vue-resource获取后端数据</h2><p>在首次进行用户认证的时候，将从后端获取的token放在localStorage中，然后在每次访问受保护的资源的时候，在请求的的header里边增加<code>Authorization</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 用户初次认证</span><br><span class="line">this.$http.post(&apos;/api/v1/auth&apos;, JSON.stringify(&#123;username: this.username,password:this.password&#125;)).then(response=&gt;&#123;</span><br><span class="line">  console.log(response) </span><br><span class="line">  localStorage.setItem(&apos;jwt_token&apos;,response.data[&apos;access_token&apos;])</span><br><span class="line">  this.$message(&apos;登陆成功&apos;)</span><br><span class="line">  this.$router.push(&apos;/&apos;)</span><br><span class="line">&#125;, response=&gt;&#123;</span><br><span class="line">  this.$message(&apos;用户名或密码错误&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 访问受保护资源</span><br><span class="line">this.$http.get(&apos;/api/v1/mongo/&apos;+db+&apos;/colstatus&apos;,&#123;&apos;headers&apos;:&#123;&apos;Authorization&apos;:&apos;JWT &apos;+localStorage.getItem(&apos;jwt_token&apos;)&#125;&#125;).then(response=&gt;&#123;</span><br><span class="line">  console.log(response)</span><br><span class="line">  this.colData = response.body</span><br><span class="line">&#125;, response=&gt;&#123;</span><br><span class="line">  this.$message(&apos;获取数据库详情失败&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="异步执行任务"><a href="#异步执行任务" class="headerlink" title="异步执行任务"></a>异步执行任务</h2><p>这次要实现的任务是完成mongodb指定库的备份，由于<code>pymongo</code>中并没有类似mongodb自带工具<code>mongodump</code>那样的方法，所以想了个办法让异步任务通过<code>fabric</code>执行命令完成数据库备份：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from time import time</span><br><span class="line">from datetime import datetime</span><br><span class="line">from flask_socketio import SocketIO</span><br><span class="line">from pymongo import MongoClient</span><br><span class="line">from gridfs import GridFSBucket</span><br><span class="line">from functionModules.taskQueue.celery_app import app</span><br><span class="line">from fabric.api import local</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def mongodump(cmd_str, dump_path, dump_root, dump_name, username, db_name, db_col):</span><br><span class="line">    dump_start = time()</span><br><span class="line">    gfs, col = init_mongo()</span><br><span class="line">    tar_path = &apos;./dump_tars/&#123;&#125;.tar.gz&apos;.format(dump_name)</span><br><span class="line">    tar_filename = &apos;&#123;&#125;.tar.gz&apos;.format(dump_name)</span><br><span class="line">    local(cmd_str)</span><br><span class="line">    local(&apos;cd &#123;&#125;&apos;.format(dump_path))</span><br><span class="line">    local(&apos;pwd&apos;)</span><br><span class="line">    local(&apos;tar zcvf &#123;&#125; -C &#123;&#125; .&apos;.format(tar_path, dump_path))</span><br><span class="line">    print(&apos;备份文件压缩完毕&apos;)</span><br><span class="line">    with open(tar_path, &apos;rb&apos;) as df:</span><br><span class="line">        g_upload = gfs.open_upload_stream(</span><br><span class="line">            tar_filename, metadata=&#123;&apos;contentType&apos;: &apos;application/x-compressed&apos;&#125;)</span><br><span class="line">        g_upload.write(df.read())</span><br><span class="line">        g_upload.close()</span><br><span class="line">        print(&quot;文件上传完毕&quot;)</span><br><span class="line">        dump_over = time()</span><br><span class="line">        dump_cost = round(dump_over - dump_start, 2)</span><br><span class="line">        dump_result = &#123;</span><br><span class="line">            &apos;dump_name&apos;: tar_filename,</span><br><span class="line">            &apos;operator&apos;: username,</span><br><span class="line">            &apos;complete_time&apos;: datetime.now().strftime(&apos;%Y-%m-%d %H-%M&apos;),</span><br><span class="line"></span><br><span class="line">            &apos;file_size&apos;: get_FileSize(tar_path),</span><br><span class="line">            &apos;time_cost&apos;: dump_cost,</span><br><span class="line">            &apos;db_name&apos;: db_name,</span><br><span class="line">            &apos;col_name&apos;: db_col</span><br><span class="line">        &#125;</span><br><span class="line">        col.insert_one(dump_result)</span><br><span class="line">        print(&apos;备份流程完成&apos;)</span><br><span class="line">    try:</span><br><span class="line">        from eventlet import monkey_patch</span><br><span class="line">        monkey_patch()</span><br><span class="line">        socketio = SocketIO(message_queue=&apos;redis://localhost:6379/10&apos;)</span><br><span class="line">        socketio.emit(&apos;mongo dump&apos;, &apos;mongodump complete&apos;)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(str(e))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_FileSize(filePath):</span><br><span class="line">    filePath = unicode(filePath, &apos;utf8&apos;)</span><br><span class="line">    fsize = os.path.getsize(filePath)</span><br><span class="line">    fsize = fsize / float(1024 * 1024)</span><br><span class="line">    return round(fsize, 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def init_mongo():</span><br><span class="line">    mongo = MongoClient()</span><br><span class="line">    db = mongo[&apos;mongodump&apos;]</span><br><span class="line">    gfs = GridFSBucket(db)</span><br><span class="line">    col = db[&apos;dump_info&apos;]</span><br><span class="line">    return gfs, col</span><br></pre></td></tr></table></figure></p><p>整个任务主要是想要实现：</p><ol><li>指定mongodb库的备份</li><li>将mongodb备份文件夹压缩</li><li>将压缩文件上传到mongodb的gridfs中持久存储</li><li>将此次备份详情存入数据库中</li><li>任务完成之后通过websocket通知主程序任务完成</li></ol><p>在这个过程，主要碰到了这样几个问题：</p><ol><li>使用<code>tar zcvf</code>压缩文件的时候，发现压缩包在解压的时候，解压出来的文件包含了被压缩文件的绝对路径，解决办法就是：<code>tar zcvf xx.tar.gz -C /path/to/floder .</code>,一定不能忘记最后的那个<code>.</code></li><li><p>不得不说，<code>flask-socketio</code>这个库真的是很棒，通过</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">socketio = SocketIO(message_queue=&apos;redis://localhost:6379/10&apos;)</span><br><span class="line">socketio.emit(&apos;mongo dump&apos;, &apos;mongodump complete&apos;)</span><br></pre></td></tr></table></figure><p> 这样的方式就可以在Celery的进程中触发主进程(flask)websocket事件，这个主要归功于redis的pub/sub(这个等下再说)</p></li></ol><h2 id="和redis结合的flask-socketio"><a href="#和redis结合的flask-socketio" class="headerlink" title="和redis结合的flask-socketio"></a>和redis结合的flask-socketio</h2><p>之前一直苦恼的是，在主进程(flask)调用celery的task之后，我该如何才知道任务的执行情况。当然，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">celery_task_result = celery_tasks.mongodump.apply_async(</span><br><span class="line">    (dump_cmd_str, &apos;&#123;&#125;&#123;&#125;&apos;.format(dump_root, dump_dir), dump_root, dump_dir, username, dump_db, dump_col))</span><br><span class="line">while not celery_task_result.ready():</span><br><span class="line">    time.sleep(1)</span><br></pre></td></tr></table></figure></p><p>的确可以获得异步执行任务的状态，但是这样会使主进程阻塞，不是一个可取的方法。直到在我重新看了好几遍<code>flask-socketio</code>文档之后才发现这些内容，网页链接在此：<a href="https://flask-socketio.readthedocs.io/en/latest/" target="_blank" rel="noopener">flask-socketio文档</a>：<br><img src="https://eclipsesv.com/pics/flask-socketio.png" alt="flask-socketio.png"><br>如果真如文档内容所说，我用redis做为flask-socketio的消息队列，celery在执行过程中也可以随时把它自己执行的任务状态通过这个消息队列触发对应的文件。于是，我赶紧修改代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># socketio相关</span><br><span class="line">socketio = SocketIO(app, message_queue=&apos;redis://localhost:6379/10&apos;,</span><br><span class="line">                    async_mode=&apos;eventlet&apos;)</span><br></pre></td></tr></table></figure></p><p>一边改代码一遍yy，这下nb了，谁知道重新执行程序发现这样的报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError:Redis requires a monkey patched socket library to work with evnetlet</span><br></pre></td></tr></table></figure></p><p>查看了源码并且又google之后，在初始化socketio的时候简单的使用eventlet的monkey patch即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from eventlet import monkey_patch</span><br><span class="line"></span><br><span class="line">monkey_patch()</span><br></pre></td></tr></table></figure></p><p>经过这一番操作，现在socketio的消息都是通过redis来传递，我们甚至可以直观的在<code>redis-cli</code>中看到:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">→ redis-cli       </span><br><span class="line">127.0.0.1:6379&gt; select 10</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[10]&gt; SUBSCRIBE flask-socketio  # 使用redis做消息队列，默认channel是flask-socketio</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;flask-socketio&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;flask-socketio&quot;</span><br><span class="line">3) &quot;(dp0\nS&apos;skip_sid&apos;\np1\nNsS&apos;room&apos;\np2\nNsS&apos;namespace&apos;\np3\nS&apos;/&apos;\np4\nsS&apos;event&apos;\np5\nS&apos;mongo dump&apos;\np6\nsS&apos;callback&apos;\np7\nNsS&apos;data&apos;\np8\nS&apos;mongodump complete&apos;\np9\nsS&apos;method&apos;\np10\nS&apos;emit&apos;\np11\ns.&quot;</span><br></pre></td></tr></table></figure></p><p><strong>这样，只需要在后端写好对应的事件，celery在执行完成后触发事件，前端订阅了该事件的地方作出对应的响应即可。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">this.socket = io(&apos;http://localhost:11111&apos;)</span><br><span class="line">this.socket.on(&apos;mongo dump&apos;,(dumpmsg)=&gt;&#123;</span><br><span class="line">  console.log(`mongo dump: $&#123;dumpmsg&#125;`)</span><br><span class="line">  this.$notify(&#123;</span><br><span class="line">    title: &apos;成功&apos;,</span><br><span class="line">    message: dumpmsg,</span><br><span class="line">    type: &apos;success&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://eclipsesv.com/pics/socket-message.png" alt="socket-message.png"></p><h2 id="flask文件下载"><a href="#flask文件下载" class="headerlink" title="flask文件下载"></a>flask文件下载</h2><p>其实上边讲了一大堆，基本上已经走完了整个异步任务的整个过程。但是文件完成备份，最终还是要提供一个下载链接，主要是为了让实施人员拿着这套备份去给用户还原数据用。<br>在flask里边，获取mongodb gridfs中文件并提供下载通过这样的方式即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pymongo import MongoClient</span><br><span class="line">from gridfs import GridFSBucket</span><br><span class="line">mongo = MongoClient()</span><br><span class="line">dump_db = mongo[&apos;mongodump&apos;]</span><br><span class="line">dump_info_col = dump_db[&apos;dump_info&apos;]</span><br><span class="line">gfs = GridFSBucket(dump_db)</span><br><span class="line"></span><br><span class="line">@bp_mongo_file.route(&apos;/dumpdownload/&lt;string:filename&gt;&apos;)</span><br><span class="line">def mongofile_download(filename):</span><br><span class="line">    if filename:</span><br><span class="line">        try:</span><br><span class="line">            grid_out = gfs.open_download_stream_by_name(filename)</span><br><span class="line">        except Exception:</span><br><span class="line">            abort(404)</span><br><span class="line">        else:</span><br><span class="line">            contents = grid_out.read()</span><br><span class="line">            if contents:</span><br><span class="line">                response = make_response(contents)</span><br><span class="line">                response.headers[&apos;Content-Type&apos;] = &apos;application/x-compressed&apos;</span><br><span class="line">                response.headers[&quot;Content-Disposition&quot;] = \</span><br><span class="line">                    &quot;attachment; filename=&#123;&#125;&quot;.format(filename)</span><br><span class="line">                return response</span><br></pre></td></tr></table></figure></p><p>而在vue前端，只需要在对应的位置添加下载链接即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;a :href=&quot;getDownloadLink(scope.row.dump_name)&quot;&gt;点击下载&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">getDownloadLink:function(filename)&#123;</span><br><span class="line">  return &apos;http://localhost:11111/mongofile/dumpdownload/&apos;+filename</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这个功能的开发只是个开始，不过在这个过程中我有几点感受：</p><ol><li>必须要重视官方文档的力量</li><li>在遇到问题的时候，除了google，深入下去研究源代码是一个非常不错的方法</li><li>东西要活学活用，现在看来flask-socketio使用redis做为消息队列的方式，其实我在读研的时候用node实现过类似的东西。库可以用现成的，但是思维不能僵化。</li><li>做东西之前要有清晰的逻辑，最好能够画成图</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> celery </tag>
            
            <tag> fabric </tag>
            
            <tag> mongodb </tag>
            
            <tag> websocket </tag>
            
            <tag> redis </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mongodb使用总结</title>
      <link href="/2017/09/18/mongodb%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2017/09/18/mongodb%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本想上周末写好这篇总结的，无奈一起开黑的时间总是过得很快，就偷了个懒，并且还学了个新菜：西红柿牛腩.jpg。所以就把总结的事情放到今天来了。<br>初次接触mongodb还是在研一刚入学的时候，那时候接触的东西少，很多概念都不清楚，到现在差不多已经有三年了，所以总结一下我用mongodb做了哪些事情还是比较有意义的。<br><a id="more"></a></p><h2 id="我的使用场景"><a href="#我的使用场景" class="headerlink" title="我的使用场景"></a>我的使用场景</h2><p>关于mongodb的介绍，我在这里就不赘述了。mongodb在我这里主要的用途有以下几点：</p><pre><code>1. 海量瓦片数据存储管理2. 矢量数据存储管理3. 一般性json数据存储管理</code></pre><p>下面会分别根据使用场景总结在使用过程中使用到的mongodb特性。</p><h2 id="海量瓦片数据存储管理"><a href="#海量瓦片数据存储管理" class="headerlink" title="海量瓦片数据存储管理"></a>海量瓦片数据存储管理</h2><p>这里说的海量瓦片数据，可以把它当作是大量小文件。具体的应用可以看<a href="https://eclipsesv.com/2015/07/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%93%E5%AD%98%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">服务器端缓存环境配置</a>和<a href="https://eclipsesv.com/2015/08/17/Mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E5%9C%A8nginx-gridfs%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">Mongodb副本集在nginx-gridfs中的使用</a>相关的几篇博客。通过<a href="http://nginx.org/" target="_blank" rel="noopener">nginx</a>+<a href="https://github.com/mdirolf/nginx-gridfs" target="_blank" rel="noopener">nginx-gridfs</a>的简单配置和非常简单的lua逻辑控制脚本，就可以直接根据请求url来获取mongodb gridfs中对应的文件。<br>由于那时候才刚接触这些东西，有很多现在看来比较简单的问题，都绕了不少弯子，比如说：不知道mongodb如何备份数据(所以更别提还原备份了)，每次迁移数据库都是直接拷贝db文件夹(不同数据库版本和不同的操作系统经常会导致失败)；不知道数据库索引是什么用，在数据量较大的时候经常查询超时；不懂操作系统，在服务器上必须有图形界面才可以操作…<br>在用惯了这套组合之后，后边还在nginx和mongodb中间加了redis作为缓存，以提升数据索引效率、在一个全景地图项目中，使用gridfs来管理大量的全景图片、现在工作的项目中，也尝试使用mongodb来管理瓦片数据。</p><h2 id="矢量数据存储和管理"><a href="#矢量数据存储和管理" class="headerlink" title="矢量数据存储和管理"></a>矢量数据存储和管理</h2><p>这里说的矢量数据指的是ESRI公司开发的shapefile。在之前的使用过程中，使用mongodb管理矢量数据，主要是想要管理矢量数据中包含的空间和属性信息，所以将shapefile转为geojson之后再由mongodb管理是一个不错的选择。通常可以使用gdal来完成shapefile–&gt;geojson这一步的转换工作。完成数据转换之后，mongodb可以很方便的存储和组织geojson数据。在进行空间数据的索引的时候，mongodb的2d和2dsphere索引提供的一系列操作能够完成很多任务：<br><strong>2dsphere</strong>索引仅支持球面查询，<strong>2d</strong>索引支持平面查询和部分球面查询。这两个索引支持的操作主要有以下这些：</p><ol><li><p>$near<br> 定义：在一次空间查询中，指定一个点，按照离指定点距离由近到远的顺序返回查询结果。这个指定点可以是一个geopoint或者是一个传统的坐标点。<br> 在使用$near进行查询的时候，根据指定点类型的不同需要不同的空间索引，如果指定点是一个geopoint则需要查询的字段建立2dsphere索引，如果是一个传统的坐标点，则需要建立2d索引。<br> 进行$near查询的时候，使用语法如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &lt;location field&gt;: &#123;</span><br><span class="line">     $near: &#123;</span><br><span class="line">       $geometry: &#123;</span><br><span class="line">          type: &quot;Point&quot; ,</span><br><span class="line">          coordinates: [ &lt;longitude&gt; , &lt;latitude&gt; ]</span><br><span class="line">       &#125;,</span><br><span class="line">       $maxDistance: &lt;distance in meters&gt;,</span><br><span class="line">       $minDistance: &lt;distance in meters&gt;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ⚠️<br> 这里需要注意的是，如果指定点是geopoint，可以在查询的时候指定minDistance；如果指定点是传统坐标点的时候，minDistance不可用，并且maxDistance以弧度为单位。<br> 在分了片的数据库中，$near是不可用的，可以使用geoNear命令或者$geoNear进行聚合操作。</p></li><li>$nearSphere<br> 此方法和$near功能一致。</li><li><p>$geoWithin<br> 定义：将处于指定区域内的所有元素返回。指定区域可以是geojson格式的<code>Polygon</code>或者<code>MultiPolygon</code>或者是传统坐标对序列。<br> 使用语法:</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &lt;location field&gt;: &#123;</span><br><span class="line">      $geoWithin: &#123;</span><br><span class="line">         $geometry: &#123;</span><br><span class="line">            type: &lt;&quot;Polygon&quot; or &quot;MultiPolygon&quot;&gt; ,</span><br><span class="line">            coordinates: [ &lt;coordinates&gt; ]</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;或者是</span><br><span class="line">&#123;</span><br><span class="line">   &lt;location field&gt;: &#123;</span><br><span class="line">      $geoWithin: &#123; &lt;shape operator&gt;: &lt;coordinates&gt; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 根据指定区域构造的方式不同，使用不同的方法，如果指定区域是geojson格式的就用<code>$geometry</code>操作符，如果指定区域是传统坐标对，可用的操作符就有：<code>$box</code>、<code>$polygon</code>、<code>$center</code>和<code>$centerSphere</code>。<br> ⚠️<br> $geoWithin不需要专门创建空间所以，但是有空间索引可以提高检索效率，并且<code>2dsphere</code>和<code>2d</code>索引均支持<code>$geoWithin</code>。<br> $geoWithin返回的结果是无序的，所以它的查询通常要比<code>$near</code>或者是<code>$geoNear</code>快。<br> 如果指定区域过大(超过半球面)的时候，需要指定mongodb的空间参考：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">db.places.find(</span><br><span class="line">   &#123;</span><br><span class="line">     loc: &#123;</span><br><span class="line">       $geoWithin: &#123;</span><br><span class="line">          $geometry: &#123;</span><br><span class="line">             type : &quot;Polygon&quot; ,</span><br><span class="line">             coordinates: [</span><br><span class="line">               [</span><br><span class="line">                 [ -100, 60 ], [ -100, 0 ], [ -100, -60 ], [ 100, -60 ], [ 100, 60 ], [ -100, 60 ]</span><br><span class="line">               ]</span><br><span class="line">             ],</span><br><span class="line">             crs: &#123;</span><br><span class="line">                type: &quot;name&quot;,</span><br><span class="line">                properties: &#123; name: &quot;urn:x-mongodb:crs:strictwinding:EPSG:4326&quot; &#125;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> 在使用<code>$box</code>操作符的时候：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &lt;location field&gt;: &#123;</span><br><span class="line">     $geoWithin: &#123;</span><br><span class="line">        $box: [</span><br><span class="line">          [ &lt;bottom left coordinates&gt; ],</span><br><span class="line">          [ &lt;upper right coordinates&gt; ]</span><br><span class="line">        ]</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在使用<code>$polygon</code>操作符的时候：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &lt;location field&gt;: &#123;</span><br><span class="line">      $geoWithin: &#123;</span><br><span class="line">         $polygon: [ [ &lt;x1&gt; , &lt;y1&gt; ], [ &lt;x2&gt; , &lt;y2&gt; ], [ &lt;x3&gt; , &lt;y3&gt; ], ... ]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在使用<code>$center</code>的时候：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &lt;location field&gt;: &#123;</span><br><span class="line">      $geoWithin: &#123; $center: [ [ &lt;x&gt;, &lt;y&gt; ] , &lt;radius&gt; ] &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在使用<code>$centerSphere</code>的时候：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &lt;location field&gt;: &#123;</span><br><span class="line">      $geoWithin: &#123; $centerSphere: [ [ &lt;x&gt;, &lt;y&gt; ], &lt;radius&gt; ] &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>$geoIntersects<br> 定义：返回和指定区域相交的元素，指定区域通常是一个geojson格式的<code>Polygon</code>。<br> 使用语法：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &lt;location field&gt;: &#123;</span><br><span class="line">     $geoIntersects: &#123;</span><br><span class="line">        $geometry: &#123;</span><br><span class="line">           type: &quot;&lt;GeoJSON object type&gt;&quot; ,</span><br><span class="line">           coordinates: [ &lt;coordinates&gt; ]</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ⚠️<br> 和<code>$geoWithin</code>一样，<code>$geoIntersects</code>不需要专门创建空间索引，但是空间索引能够提升检索效率，但是它仅支持<code>2dsphere</code>索引。<br> 在进行超过半球面的检索时，同样需要指定空间参考：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">db.places.find(</span><br><span class="line">   &#123;</span><br><span class="line">     loc: &#123;</span><br><span class="line">       $geoIntersects: &#123;</span><br><span class="line">          $geometry: &#123;</span><br><span class="line">             type : &quot;Polygon&quot;,</span><br><span class="line">             coordinates: [</span><br><span class="line">               [</span><br><span class="line">                 [ -100, 60 ], [ -100, 0 ], [ -100, -60 ], [ 100, -60 ], [ 100, 60 ], [ -100, 60 ]</span><br><span class="line">               ]</span><br><span class="line">             ],</span><br><span class="line">             crs: &#123;</span><br><span class="line">                type: &quot;name&quot;,</span><br><span class="line">                properties: &#123; name: &quot;urn:x-mongodb:crs:strictwinding:EPSG:4326&quot; &#125;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><p>通过上述的几个方法，能过满足空间数据的常规索引需求。<br>上述两种场景主要是为了应对和空间信息相关的数据，在实际的使用中，更多的是普通的json格式数据。</p><h2 id="一般性json格式数据存储管理"><a href="#一般性json格式数据存储管理" class="headerlink" title="一般性json格式数据存储管理"></a>一般性json格式数据存储管理</h2><p>在更多的时候，使用mongodb主要是用来给web服务提供数据。现在前后端分离的开发方式，前后端之间的交互转变为数据的交互，我的套路就是vue+flask-restful+mongodb。<br>由于mongodb对json格式的数据存储有先天的优势，所以在写代码的时候会剩很多事，合理的使用mongodb的一些特性会有更大的便利。</p><h3 id="aggregation"><a href="#aggregation" class="headerlink" title="aggregation"></a>aggregation</h3><p>之前记录过mongodb的aggreagtion相关的内容:<a href="https://eclipsesv.com/2016/11/23/mongodb_Aggregation/">Mongodb Aggregation Pipleline</a>和<a href="https://eclipsesv.com/2017/07/25/mongodb%E6%9C%80%E8%BF%91%E9%A2%91%E7%B9%81%E9%9C%80%E8%A6%81%E7%9C%8B%E7%9A%84%E6%96%87%E6%A1%A3/">mongodb最近频繁看的文档</a>。<br>由于mongodb对跨表查询支持的不是很好，所以在数据存储的时候经常会尽可能的将所需要的数据都放在同一个document里边。但是在实际进行数据请求的时候，可能需要对获取到的数据进行对应的处理，这个时候mongodb的aggregation就能起到作用。直接利用数据库的能力完成数据处理，通常会比拿到数据之后再通过自己的代码完成数据处理要好得多。</p><h3 id="ttl索引和explain"><a href="#ttl索引和explain" class="headerlink" title="ttl索引和explain()"></a>ttl索引和explain()</h3><p>这两个点在之前的一个博客里边提到过：<a href="https://eclipsesv.com/2016/11/25/%E8%AF%BBMongodb%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/">读Mongodb权威指南有感</a>。<br>ttl索引可用的面还是挺广的，用以记录缓存过期、验证码或者各类时效性的数据。<br>explain()方法在进行数据库性能调优的过程中也会有很好的效果。</p><h3 id="数据备份和还原"><a href="#数据备份和还原" class="headerlink" title="数据备份和还原"></a>数据备份和还原</h3><p>整库的还原和备份，可以直接通过mongodb自带的工具<code>mongodump</code>和<code>mongorestore</code>来完成：<br>通过<code>mongodump -d database_name -o /path/to/dump_dir --gzip</code>来完成备份，<code>mongorestore -d database_name --dir /path/to/dump_dir --gzip</code>来完成还原。<br>当然，如果两个数据库实例在同一个局域网内，也可以直接在mongo中执行命令来完成database或者是collection的迁移：<br>使用cloneCollection命令或者db.cloneCollection()来完成collection的数据迁移：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand( &#123; cloneCollection: &quot;users.profiles&quot;,</span><br><span class="line">                 from: &quot;mongodb.example.net:27017&quot;,</span><br><span class="line">                 query: &#123; &apos;active&apos; : true &#125;</span><br><span class="line">               &#125; )</span><br><span class="line"></span><br><span class="line">db.cloneCollection(&apos;mongodb.example.net:27017&apos;, &apos;users.profile&apos;,</span><br><span class="line">                    &#123; &apos;active&apos; : true &#125; )</span><br></pre></td></tr></table></figure></p><p>⚠️<br>mongos不支持上述两种方法，并且如果目标服务器的mongodb实例开启<code>authorization</code>这两个方法也是不可以用的。<br>类似的，使用下边两个方法来完成整个库的拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use importdb</span><br><span class="line">db.cloneDatabase(&quot;hostname&quot;)</span><br><span class="line"></span><br><span class="line">&#123; clone: &quot;db1.example.net:27017&quot; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="pymongo的使用"><a href="#pymongo的使用" class="headerlink" title="pymongo的使用"></a>pymongo的使用</h3><p>使用flask-restful提供数据服务，用到mongodb的地方我都是直接使用pymongo来操作数据库。在使用的过程中有几点，可以记下：</p><ol><li>在使用flask的jsonify的时候，不能直接把mongodb返回的一整条数据jsonify，这是因为ObjectId不能直接转为json，通常我在查询数据的时候不返回ObjectId</li><li>在进行排序或者建立索引的时候，会用到<code>ASCENDING</code>和<code>DESCENDING</code>，升序和降序。需要<code>from pymongo import DESCENDING, ASCENDING</code>，当然还有其他一些索引类型，也都需要从pymongo中直接import</li><li><p>在数据量很大的时候，将整个数据集返回，然后逐条操作。整个过程可能会耗费较长的时间，这个时候需要设置<code>no_cursor_timeout</code>，就像这样：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def gen_playlists():</span><br><span class="line">    playlists = col.find(&#123;&#125;, &#123;&apos;_id&apos;: 0&#125;, no_cursor_timeout=True)</span><br><span class="line">    for playlist in playlists:</span><br><span class="line">        yield playlist</span><br><span class="line">    playlists.close()</span><br></pre></td></tr></table></figure><p> <code>no_cursor_timeout</code>默认设置为<code>False</code>，如果<code>find()</code>返回的结果集中的某个<code>cursor</code>在十分钟以内没有被操作，这个查询结果就会被关闭。在将<code>no_cursor_timeout</code>设置为<code>True</code>的时候，需要在数据操作完成之后手动关闭查询结果。</p></li><li>给mongodb设置用户名密码是保证数据安全的一个常用方法，这篇<a href="https://eclipsesv.com/2017/01/17/mongodb%E5%B8%A6%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81%E4%BD%BF%E7%94%A8/">mongodb带密码验证使用</a>博客里边有详细的说明。</li></ol><h2 id="未用到的特性"><a href="#未用到的特性" class="headerlink" title="未用到的特性"></a>未用到的特性</h2><p>虽说是前前后后差不多已经用了三年的mongodb，但总体说来也就达到了会用的程度。mongodb的分片到现在也没有实际的应用经验，很多有用的索引类型也都没用过，并且也没有实实在在优化数据库性能的经验，所以还有很多要学的。大致从一下几点努力：</p><ol><li>仔细阅读官方文档</li><li>在以后的小项目中尽量使用更多的数据库新特性</li><li>除了pymongo以外，其他的driver也接触使用</li><li>尝试学习mongodb内部实现细节，比如geohash算法的实现</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> mongodb </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>proxy在爬虫中的使用姿势</title>
      <link href="/2017/08/28/proxy%E5%9C%A8%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
      <url>/2017/08/28/proxy%E5%9C%A8%E7%88%AC%E8%99%AB%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<p>通过爬虫获取数据会经常被服务器ban掉ip，所以有个有效的proxy pool十分必要。这几天在爬网易云音乐的用户数据，顺便搞了个<a href="https://github.com/love3forever/proxyHunter" target="_blank" rel="noopener">proxyhunter</a>，并且尝试发布成pip包：<a href="https://pypi.python.org/pypi/proxyhunter/0.0.1" target="_blank" rel="noopener">proxyhunter</a>，方便以后的使用。下面主要说下<strong>requests</strong>在进行请求的时候，proxy如何设置，以及我这个proxyhunter如何使用。<br><a id="more"></a><br>这里获取的proxy都是免费的，来自<a href="http://www.kuaidaili.com/" target="_blank" rel="noopener">http://www.kuaidaili.com/</a>。如果对proxy有比较高的要求，可以使用付费版的，我买了一周的开放代理，和免费的比起来，返回的代理列表中可用的比例相对来说还是挺高的。</p><h1 id="request的proxy"><a href="#request的proxy" class="headerlink" title="request的proxy"></a>request的proxy</h1><p>在利用requests进行数据请求的时候，可以通过设置proxy来指定请求的proxy，当然，如果proxy不可用，请求是无法返回所需要的数据的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def test_proxy(current_proxy):</span><br><span class="line">    # param: current_proxy是一个由host和port构成的tuple</span><br><span class="line">    # 将获得的proxy通过&apos;http://ip.cn/&apos;测试，如果可用返回True</span><br><span class="line">    proxies = dict()</span><br><span class="line">    if current_proxy:</span><br><span class="line">        proxies[&apos;http&apos;] = &quot;http://&#123;&#125;:&#123;&#125;&quot;.format(*current_proxy)</span><br><span class="line">        proxies[&apos;https&apos;] = &quot;http://&#123;&#125;:&#123;&#125;&quot;.format(*current_proxy)</span><br><span class="line">        try:</span><br><span class="line">            test_response = requests.get(</span><br><span class="line">                &apos;http://ip.cn/&apos;, timeout=5, proxies=proxies)</span><br><span class="line">        except Exception:</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            if test_response.status_code == 200:</span><br><span class="line">                test_soup = BeautifulSoup(test_response.content, &apos;lxml&apos;)</span><br><span class="line">                ip_info = test_soup.select(&apos;.well&apos;)</span><br><span class="line">                if ip_info:</span><br><span class="line">                    print(ip_info)</span><br><span class="line">                    return True</span><br><span class="line">            else:</span><br><span class="line">                return False</span><br></pre></td></tr></table></figure></p><p>可以看到，在通过request调用get的时候，设置<code>proxies=proxies</code>即可。<br>通过请求<code>http://ip.cn/</code>可以查询到当前的ip和port，前提是当前的proxy可用。</p><h1 id="proxyhunter"><a href="#proxyhunter" class="headerlink" title="proxyhunter"></a>proxyhunter</h1><p>由于是第一次向pypi提交python包，还是有必要记录一下过程：</p><ol><li>第一步当然是<a href="https://pypi.python.org/pypi?%3Aaction=register_form" target="_blank" rel="noopener">注册用户</a></li><li>在完成注册和邮箱验证之后，可以安装一个<a href="https://pypi.python.org/pypi/twine" target="_blank" rel="noopener">twine</a>，稍后上传包会用到这个工具</li><li><p>打包代码：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── proxyhunter</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── huntingOn.py</span><br><span class="line">├── requirements.txt</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure><p> 初始情况下，自己的代码放在proxyhunter目录中，编写打包相关代码，在<code>setup.py</code>中：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from setuptools import setup, find_packages</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">    name=&quot;proxyhunter&quot;,</span><br><span class="line">    version=&quot;0.0.1&quot;,</span><br><span class="line">    keywords=(&quot;pip&quot;, &quot;http&quot;, &quot;http proxy&quot;),</span><br><span class="line">    description=&quot;free available http proxy from web&quot;,</span><br><span class="line">    long_description=&quot;proxy hunter&quot;,</span><br><span class="line">    license=&quot;MIT Licence&quot;,</span><br><span class="line"></span><br><span class="line">    url=&quot;https://eclipsesv.com&quot;,</span><br><span class="line">    author=&quot;wangmengcn&quot;,</span><br><span class="line">    author_email=&quot;eclipse_sv@163.com&quot;,</span><br><span class="line"></span><br><span class="line">    packages=find_packages(),</span><br><span class="line">    include_package_data=True,</span><br><span class="line">    platforms=&quot;any&quot;,</span><br><span class="line">    install_requires=[&quot;requests&quot;, &quot;lxml&quot;, &quot;bs4&quot;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> 这里边的配置根据自己要发布包的具体情况而定。<br> 然后就可以通过</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python setup.py bdist_egg   # easy_install</span><br><span class="line">python setup.py sdist       # pip</span><br></pre></td></tr></table></figure><p> 在dist目录中生成对应文件：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├── proxyhunter-0.0.1-py2.7.egg</span><br><span class="line">└── proxyhunter-0.0.1.tar.gz</span><br></pre></td></tr></table></figure><p> 这样就完成了代码的打包。🍺🍺🍺</p></li><li>发布代码<br>使用刚才安装的工具<strong>twine</strong>:<code>twine upload dist/*</code><br>在命令行中输入对应内容即可。<br>这时候，目录结构应该是这样的:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── build</span><br><span class="line">│   ├── bdist.macosx-10.12-intel</span><br><span class="line">│   └── lib</span><br><span class="line">│       └── proxyhunter</span><br><span class="line">│           ├── __init__.py</span><br><span class="line">│           └── huntingOn.py</span><br><span class="line">├── dist</span><br><span class="line">│   ├── proxyhunter-0.0.1-py2.7.egg</span><br><span class="line">│   └── proxyhunter-0.0.1.tar.gz</span><br><span class="line">├── proxyhunter</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── huntingOn.py</span><br><span class="line">├── proxyhunter.egg-info</span><br><span class="line">│   ├── PKG-INFO</span><br><span class="line">│   ├── SOURCES.txt</span><br><span class="line">│   ├── dependency_links.txt</span><br><span class="line">│   ├── requires.txt</span><br><span class="line">│   └── top_level.txt</span><br><span class="line">├── requirements.txt</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure></li></ol><p>并且，网站上可以看到<a href="https://pypi.python.org/pypi/proxyhunter/0.0.1" target="_blank" rel="noopener">相关的内容</a>。</p><h2 id="proxyhunter用法"><a href="#proxyhunter用法" class="headerlink" title="proxyhunter用法"></a>proxyhunter用法</h2><p>由于现在已经打包了，用的时候也会十分简单：</p><ol><li>安装<br><code>pip install proxyhunter</code></li><li>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [1]: from proxyhunter.huntingOn import Hunter</span><br><span class="line"></span><br><span class="line">In [2]: hunter = Hunter()</span><br><span class="line"></span><br><span class="line">In [3]: for proxy in hunter:</span><br><span class="line">   ...:     print proxy</span><br><span class="line">   ...:</span><br><span class="line">wating for new proxy</span><br><span class="line">wating for new proxy</span><br><span class="line">[&lt;div class=&quot;well&quot;&gt;&lt;p&gt;\u60a8\u73b0\u5728\u7684 IP\uff1a&lt;code&gt;60.174.237.43&lt;/code&gt;&lt;/p&gt;&lt;p&gt;\u6240\u5728\u5730\u7406\u4f4d\u7f6e\uff1a&lt;code&gt;\u5b89\u5fbd\u7701\u5de2\u6e56\u5e02 \u7535\u4fe1&lt;/code&gt;&lt;/p&gt;&lt;p&gt;GeoIP: Hefei, Anhui, China&lt;/p&gt;&lt;/div&gt;]</span><br><span class="line">(u&apos;60.174.237.43&apos;, u&apos;9999&apos;)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> requests </tag>
            
            <tag> http proxy </tag>
            
            <tag> pip </tag>
            
            <tag> proxyhunter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python魔术方法指南[转]</title>
      <link href="/2017/08/22/python%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E6%8C%87%E5%8D%97/"/>
      <url>/2017/08/22/python%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p>转自<a href="http://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/a-guide-to-pythons-magic-methods.html" target="_blank" rel="noopener">Python 魔术方法指南</a><br><a id="more"></a><br>文章主要分为如下几个部分：</p><ul><li>入门</li><li>构造和初始化</li><li>构造定制类<ul><li>用于比较的魔术方法</li><li>用于数值处理的魔术方法</li></ul></li><li>表现你的类</li><li>控制属性访问</li><li>创建定制序列</li><li>反射</li><li>可以调用的对象</li><li>会话管理器</li><li>创建描述器对象</li><li>持久化对象</li><li>总结</li><li>附录</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>此教程为我的数篇文章中的一个重点。主题是魔术方法。<br>什么是魔术方法?他们是面向对象的Python的一切。他们是可以给你的类增加”magic”的特殊方法。他们总是被双下划线所包围(e.g. <code>__init__</code> 或者 <code>__lt__</code>)。然而他们的文档却远没有提供应该有的内容。Python中所有的魔术方法均在Python官方文档中有相应描述，但是对于他们的描述比较混乱而且组织比较松散。很难找到有一个例子(也许他们原本打算的很好，在开始语言参考中有描述很详细，然而随之而来的确是枯燥的语法描述等等)。</p><p>所以，为了修补我认为Python文档应该修补的瑕疵，我决定给Python中的魔术方法提供一些用平淡的语言和实例驱使的文档。我在开始已经写了数篇博文，现在在这篇文章中对他们进行总结。</p><p>我希望你能够喜欢这篇文章。你可以将之当做一个教程，一个补习资料，或者一个参考。本文章的目的仅仅是为Python中的魔术方法提供一个友好的教程。</p><h2 id="构造和初始化"><a href="#构造和初始化" class="headerlink" title="构造和初始化"></a>构造和初始化</h2><p>每个人都知道一个最基本的魔术方法， <code>__init__</code> 。通过此方法我们可以定义一个对象的初始操作。然而，当我调用 <code>x = SomeClass()</code> 的时候， <code>__init__</code> 并不是第一个被调用的方法。实际上，还有一个叫做 <code>__new__</code> 的方法，来构造这个实例。然后给在开始创建时候的初始化函数来传递参数。在对象生命周期的另一端，也有一个 <code>__del__</code> 方法。我们现在来近距离的看一看这三个方法:</p><p><code>__new__(cls, [...)</code><br><code>__new__</code> 是在一个对象实例化的时候所调用的第一个方法。它的第一个参数是这个类，其他的参数是用来直接传递给 <code>__init__</code> 方法。 <code>__new__</code> 方法相当不常用,但是它有自己的特性，特别是当继承一个不可变的类型比如一个tuple或者string。我不希望在 <code>__new__</code> 上有太多细节，因为并不是很有用处，但是在 <code>Python文档 &lt;http://www.python.org/download/releases/2.2/descrintro/#__new__&gt;</code>_ 中有详细的阐述。</p><p><code>__init__(self, […)</code><br>此方法为类的初始化方法。当构造函数被调用的时候的任何参数都将会传给它。(比如如果我们调用 <code>x = SomeClass(10, &#39;foo&#39;)</code>)，那么 <code>__init__</code>  将会得到两个参数10和foo。 <code>__init__</code> 在Python的类定义中被广泛用到。</p><p><code>__del__(self)</code><br>如果 <code>__new__</code> 和 <code>__init__</code> 是对象的构造器的话，那么 <code>__del__</code> 就是析构器。它不实现语句 <code>del x</code> (以上代码将不会翻译为 <code>x.__del__()</code> )。它定义的是当一个对象进行垃圾回收时候的行为。当一个对象在删除的时需要更多的清洁工作的时候此方法会很有用，比如套接字对象或者是文件对象。注意，如果解释器退出的时候对象还存存在，就不能保证 <code>__del__</code> 能够被执行，所以 <code>__del__</code> can’t serve as a replacement for good coding practices ()<del>~</del>~~</p><p>放在一起的话，这里是一个 <code>__init__</code> 和 <code>__del__</code> 实际使用的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from os.path import join</span><br><span class="line"></span><br><span class="line">class FileObject:</span><br><span class="line">    &apos;&apos;&apos;给文件对象进行包装从而确认在删除时文件流关闭&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, filepath=&apos;~&apos;, filename=&apos;sample.txt&apos;):</span><br><span class="line">        #读写模式打开一个文件 </span><br><span class="line">        self.file = open(join(filepath, filename), &apos;r+&apos;)</span><br><span class="line"></span><br><span class="line">    def __del__(self):</span><br><span class="line">        self.file.close()</span><br><span class="line">        del self.file</span><br></pre></td></tr></table></figure></p><h1 id="让定制的类工作起来"><a href="#让定制的类工作起来" class="headerlink" title="让定制的类工作起来"></a>让定制的类工作起来</h1><p>使用Python的魔术方法的最大优势在于他们提供了一种简单的方法来让对象可以表现的像内置类型一样。那意味着你可以避免丑陋的，违反直觉的，不标准的的操作方法。在一些语言中，有一些操作很常用比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if instance.equals(other_instance):</span><br><span class="line">    # do something</span><br></pre></td></tr></table></figure></p><p>在Python中你可以这样。但是这会让人迷惑且产生不必要的冗余。相同的操作因为不同的库会使用不同的名字，这样会产生不必要的工作。然而有了魔术方法的力量，我们可以定义一个方法(本例中为 <code>__eq__</code> )，就说明了我们的意思：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if instance == other_instance:</span><br><span class="line">        #do something</span><br></pre></td></tr></table></figure></p><p>这只是魔术方法的功能的一小部分。它让你可以定义符号的含义所以我们可以在我们的类中使用。就像内置类型一样。</p><h2 id="用于比较的魔术方法"><a href="#用于比较的魔术方法" class="headerlink" title="用于比较的魔术方法"></a>用于比较的魔术方法</h2><p>Python对实现对象的比较，使用魔术方法进行了大的逆转，使他们非常直观而不是笨拙的方法调用。而且还提供了一种方法可以重写Python对对象比较的默认行为(通过引用)。以下是这些方法和他们的作用。</p><p><code>__cmp__(self, other)</code><br><code>__cmp__</code> 是最基本的用于比较的魔术方法。它实际上实现了所有的比较符号(&lt;,==,!=,etc.)，但是它的表现并不会总是如你所愿(比如，当一个实例与另一个实例相等是通过一个规则来判断，而一个实例大于另外一个实例是通过另外一个规则来判断)。如果 <code>self &lt; other</code> 的话 <code>__cmp__</code> 应该返回一个负数，当 <code>self == other</code> 的时候会返回0 ，而当 <code>self &gt; other</code> 的时候会返回正数。通常最好的一种方式是去分别定义每一个比较符号而不是一次性将他们都定义。但是 <code>__cmp__</code> 方法是你想要实现所有的比较符号而一个保持清楚明白的一个好的方法。</p><p><code>__eq__(self, other)</code><br>定义了等号的行为, <code>==</code> 。</p><p><code>__ne__(self, other)</code><br>定义了不等号的行为, <code>!=</code> 。</p><p><code>__lt__(self, other)</code><br>定义了小于号的行为， <code>&lt;</code> 。</p><p><code>__gt__(self, other)</code><br>定义了大于等于号的行为， <code>&gt;=</code> 。</p><p>举一个例子，创建一个类来表现一个词语。我们也许会想要比较单词的字典序(通过字母表)，通过默认的字符串比较的方法就可以实现，但是我们也想要通过一些其他的标准来实现，比如单词长度或者音节数量。在这个例子中，我们来比较长度实现。以下是实现代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Word(str):</span><br><span class="line">&apos;&apos;&apos;存储单词的类，定义比较单词的几种方法&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    def __new__(cls, word):</span><br><span class="line">        # 注意我们必须要用到__new__方法，因为str是不可变类型</span><br><span class="line">        # 所以我们必须在创建的时候将它初始化</span><br><span class="line">        if &apos; &apos; in word:</span><br><span class="line">            print &quot;Value contains spaces. Truncating to first space.&quot;</span><br><span class="line">            word = word[:word.index(&apos; &apos;)] #单词是第一个空格之前的所有字符</span><br><span class="line">        return str.__new__(cls, word)</span><br><span class="line"></span><br><span class="line">    def __gt__(self, other):</span><br><span class="line">        return len(self) &gt; len(other)</span><br><span class="line">    def __lt__(self, other):</span><br><span class="line">        return len(self) &lt; len(other)</span><br><span class="line">    def __ge__(self, other):</span><br><span class="line">        return len(self) &gt;= len(other)</span><br><span class="line">    def __le__(self, other):</span><br><span class="line">        return len(self) &lt;= len(other)</span><br></pre></td></tr></table></figure></p><p>现在，我们创建两个 <code>Words</code> 对象(通过使用 <code>Word(&#39;foo&#39;)</code> 和 <code>Word(&#39;bar&#39;)</code> 然后通过长度来比较它们。注意，我们没有定义 <code>__eq__</code> 和 <code>__ne__</code> 方法。这是因为将会产生一些怪异的结果(比如 <code>Word(&#39;foo&#39;) == Word(&#39;bar&#39;)</code> 将会返回true)。这对于测试基于长度的比较不是很有意义。所以我们退回去，用 <code>str</code> 内置来进行比较。</p><p>现在你知道你不必定义每一个比较的魔术方法从而进行丰富的比较。标准库中很友好的在 <code>functiontols</code> 中提供给我们一个类的装饰器定义了所有的丰富的比较函数。如果你只是定义 <code>__eq__</code> 和另外一个(e.g. <code>__gt__</code>, <code>__lt__</code>,etc.)这个特性仅仅在Python 2.7中存在，但是你如果有机会碰到的话，那么将会节省大量的时间和工作量。你可以通过在你定义的类前放置 <code>@total_ordering</code> 来使用。</p><h2 id="数值处理的魔术方法"><a href="#数值处理的魔术方法" class="headerlink" title="数值处理的魔术方法"></a>数值处理的魔术方法</h2><p>如同你在通过比较符来比较类的实例的时候来创建很多方法，你也可以定义一些数值符号的特性。系紧你的安全带，来吧，这里有很多内容。为了组织方便，我将会把数值处理的方法来分成五类:一元操作符，普通算数操作符，反射算数操作符(之后会详细说明),增量赋值，和类型转换。</p><h2 id="一元操作符和函数"><a href="#一元操作符和函数" class="headerlink" title="一元操作符和函数"></a>一元操作符和函数</h2><p>仅仅有一个操作位的一元操作符和函数。比如绝对值，负等。</p><p><code>__pos__(self)</code><br>实现正号的特性(比如 <code>+some_object</code>)</p><p><code>__neg__(self)</code><br>实现负号的特性(比如 <code>-some_object</code>)</p><p><code>__abs__(self)</code><br>实现内置 <code>abs()</code> 函数的特性。</p><p><code>__invert__(self)</code><br>实现 <code>~</code> 符号的特性。为了说明这个特性。你可以查看 <code>Wikipedia中的这篇文章 &lt;http://en.wikipedia.org/wiki/Bitwise_operation#NOT&gt;</code>_</p><h2 id="普通算数操作符"><a href="#普通算数操作符" class="headerlink" title="普通算数操作符"></a>普通算数操作符</h2><p>现在我们仅仅覆盖了普通的二进制操作符:+,-,*和类似符号。这些符号大部分来说都浅显易懂。</p><p><code>__add__(self, other)</code><br>实现加法。<br><code>__sub__(self, other)</code><br>实现减法。<br><code>__mul__(self, other)</code><br>实现乘法。<br><code>__floordiv__(self, other)</code><br>实现 <code>//</code> 符号实现的整数除法。<br><code>__div__(self, other)</code><br>实现 <code>/</code> 符号实现的除法。<br><code>__truediv__(self, other)</code><br>实现真除法。注意只有只用了 <code>from __future__ import division</code> 的时候才会起作用。<br><code>__mod__(self, other)</code><br>实现取模算法 <code>%</code><br><code>__divmod___(self, other)</code><br>实现内置 <code>divmod()</code> 算法<br><code>__pow__</code><br>实现使用 <code>**</code> 的指数运算<br><code>__lshift__(self, other)</code><br>实现使用 <code>&lt;&lt;</code> 的按位左移动<br><code>__rshift__(self, other)</code><br>实现使用 <code>&gt;&gt;</code> 的按位左移动<br><code>__and__(self, other)</code><br>实现使用 <code>&amp;</code> 的按位与<br><code>__or__(self, other)</code><br>实现使用 <code>|</code> 的按位或<br><code>__xor__(self, other)</code><br>实现使用 <code>^</code> 的按位异或</p><h2 id="反运算"><a href="#反运算" class="headerlink" title="反运算"></a>反运算</h2><p>下面我将会讲解一些反运算的知识。有些概念你可能会认为恐慌或者是陌生。但是实际上非常简单。以下是一个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_object + other</span><br></pre></td></tr></table></figure></p><p>这是一个普通的加法运算，反运算是相同的，只是把操作数调换了位置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">other + some_object</span><br></pre></td></tr></table></figure></p><p>所以，除了当与其他对象操作的时候自己会成为第二个操作数之外，所有的这些魔术方法都与普通的操作是相同的。大多数情况下，反运算的结果是与普通运算相同的。所以你可以你可以将 <code>__radd__</code> 与 <code>__add__</code> 等价。</p><p><code>__radd__(self, other)</code><br>实现反加<br><code>__rsub__(self, other)</code><br>实现反减<br><code>__rmul__(self, other)</code><br>实现反乘<br><code>__rfloordiv__(self, other)</code><br>实现 <code>//</code> 符号的反除<br><code>__rdiv__(self, other)</code><br>实现 <code>/</code> 符号的反除<br><code>__rtruediv__(self, other)</code><br>实现反真除，只有当 <code>from __future__ import division</code> 的时候会起作用<br><code>__rmod__(self, other)</code><br>实现 <code>%</code> 符号的反取模运算<br><code>__rdivmod__(self, other)</code><br>当 <code>divmod(other, self)</code> 被调用时，实现内置 <code>divmod()</code> 的反运算<br><code>__rpow__</code><br>实现 <code>**</code> 符号的反运算<br><code>__rlshift__(self, other)</code><br>实现 <code>&lt;&lt;</code> 符号的反左位移<br><code>__rrshift__(self, other)</code><br>实现 <code>&gt;&gt;</code> 符号的反右位移<br><code>__rand__(self, other)</code><br>实现 <code>&amp;</code> 符号的反与运算<br><code>__ror__(self, other)</code><br>实现 <code>|</code> 符号的反或运算<br><code>__xor__(self, other)</code><br>实现 <code>^</code> 符号的反异或运算</p><h2 id="增量赋值"><a href="#增量赋值" class="headerlink" title="增量赋值"></a>增量赋值</h2><p>Python也有大量的魔术方法可以来定制增量赋值语句。你也许对增量赋值已经很熟悉，它将操作符与赋值来结合起来。如果你仍然不清楚我在说什么的话，这里有一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = 5</span><br><span class="line">x += 1 # in other words x = x + 1</span><br></pre></td></tr></table></figure></p><p><code>__iadd__(self, other)</code><br>实现赋值加法<br><code>__isub__(self, other)</code><br>实现赋值减法<br><code>__imul__(self, other)</code><br>实现赋值乘法<br><code>__ifloordiv__(self, other)</code><br>实现 <code>//=</code> 的赋值地板除<br><code>__idiv__(self, other)</code><br>实现符号 <code>/=</code> 的赋值除<br><code>__itruediv__(self, other)</code><br>实现赋值真除,只有使用 <code>from __future__ import division</code> 的时候才能使用<br><code>__imod_(self, other)</code><br>实现符号 <code>%=</code> 的赋值取模<br><code>__ipow__</code><br>实现符号 <code>**=</code> 的赋值幂运算<br><code>__ilshift__(self, other)</code><br>实现符号 <code>&lt;&lt;=</code> 的赋值位左移<br><code>__irshift__(self, other)</code><br>实现符号 <code>&gt;&gt;=</code> 的赋值位右移<br><code>__iand__(self, other)</code><br>实现符号 <code>&amp;=</code> 的赋值位与<br><code>__ior__(self, other)</code><br>实现符号 <code>|=</code> 的赋值位或<br><code>__ixor__(self, other)</code><br>实现符号 <code>|=</code> 的赋值位异或</p><h2 id="类型转换魔术方法"><a href="#类型转换魔术方法" class="headerlink" title="类型转换魔术方法"></a>类型转换魔术方法</h2><p>Python也有很多的魔术方法来实现类似 <code>float()</code> 的内置类型转换特性。<br><code>__int__(self)</code><br>实现整形的强制转换<br><code>__long__(self)</code><br>实现长整形的强制转换<br><code>__float__(self)</code><br>实现浮点型的强制转换<br><code>__complex__(self)</code><br>实现复数的强制转换<br><code>__oct__(self)</code><br>实现八进制的强制转换<br><code>__hex__(self)</code><br>实现二进制的强制转换<br><code>__index__(self)</code><br>当对象是被应用在切片表达式中时，实现整形强制转换，如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 <code>__index__</code> (详见PEP357)<br><code>__trunc__(self)</code><br>当使用 <code>math.trunc(self)</code> 的时候被调用。 <code>__trunc__</code> 应该返回数值被截取成整形(通常为长整形)的值<br><code>__coerce__(self, other)</code><br>实现混合模式算数。如果类型转换不可能的话，那么 <code>__coerce__</code> 将会返回 <code>None</code> ,否则他将对 <code>self</code> 和 <code>other</code> 返回一个长度为2的tuple，两个为相同的类型。</p><h1 id="表现你的类"><a href="#表现你的类" class="headerlink" title="表现你的类"></a>表现你的类</h1><p>如果有一个字符串来表示一个类将会非常有用。在Python中，有很多方法可以实现类定义内置的一些函数的返回值。<br><code>__str__(self)</code><br>定义当 <code>str()</code> 调用的时候的返回值<br><code>__repr__(self)</code><br>定义 <code>repr()</code> 被调用的时候的返回值。 <code>str()</code> 和 <code>repr()</code> 的主要区别在于 <code>repr()</code> 返回的是机器可读的输出，而 <code>str()</code> 返回的是人类可读的。<br><code>__unicode__(self)</code><br>定义当 <code>unicode()</code> 调用的时候的返回值。 <code>unicode()</code> 和 <code>str()</code> 很相似，但是返回的是unicode字符串。注意，如a果对你的类调用 <code>str()</code>  然而你只定义了 <code>__unicode__()</code> ，那么将不会工作。你应该定义 <code>__str__()</code> 来确保调用时能返回正确的值。</p><p><code>__hash__(self)</code><br>定义当 <code>hash()</code> 调用的时候的返回值，它返回一个整形，用来在字典中进行快速比较<br><code>__nonzero__(self)</code><br>定义当 <code>bool()</code> 调用的时候的返回值。本方法应该返回True或者False，取决于你想让它返回的值。</p><h1 id="控制属性访问"><a href="#控制属性访问" class="headerlink" title="控制属性访问"></a>控制属性访问</h1><p>许多从其他语言转到Python的人会抱怨它缺乏类的真正封装。(没有办法定义私有变量，然后定义公共的getter和setter)。Python其实可以通过魔术方法来完成封装。我们来看一下:</p><p><code>__getattr__(self, name)</code><br>你可以定义当用户试图获取一个不存在的属性时的行为。这适用于对普通拼写错误的获取和重定向，对获取一些不建议的属性时候给出警告(如果你愿意你也可以计算并且给出一个值)或者处理一个 <code>AttributeError</code> 。只有当调用不存在的属性的时候会被返回。然而，这不是一个封装的解决方案。<br><code>__setattr__(self, name, value)</code><br>与 <code>__getattr__</code> 不同， <code>__setattr__</code> 是一个封装的解决方案。无论属性是否存在，它都允许你定义对对属性的赋值行为，以为这你可以对属性的值进行个性定制。但是你必须对使用 <code>__setattr__</code> 特别小心。之后我们会详细阐述。<br><code>__delattr__</code><br>与 <code>__setattr__</code> 相同，但是功能是删除一个属性而不是设置他们。注意与 <code>__setattr__</code> 相同，防止无限递归现象发生。(在实现 <code>__delattr__</code> 的时候调用 <code>del self.name</code> 即会发生)<br><code>__getattribute__(self, name)</code><br><code>__getattribute__</code> 与它的同伴 <code>__setattr__</code> 和 <code>__delattr__</code> 配合非常好。但是我不建议使用它。只有在新类型类定义中才能使用 <code>__getattribute__</code> (在最新版本Python中所有的类都是新类型，在老版本中你可以通过继承 <code>object</code> 来制作一个新类。这样你可以定义一个属性值的访问规则。有时也会产生一些帝归现象。(这时候你可以调用基类的 <code>__getattribute__</code> 方法来防止此现象的发生。)它可以消除对 <code>__getattr__</code> 的使用，如果它被明确调用或者一个 <code>AttributeError</code> 被抛出，那么当实现 <code>__getattribute__</code> 之后才能被调用。此方法是否被使用其实最终取决于你的选择。)我不建议使用它因为它的使用几率较小(我们在取得一个值而不是设置一个值的时候有特殊的行为是非常罕见的。)而且它不能避免会出现bug。</p><p>在进行属性访问控制定义的时候你可能会很容易的引起一个错误。考虑下面的例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def __setattr__(self, name, value):</span><br><span class="line">    self.name = value</span><br><span class="line">    #每当属性被赋值的时候， `__setattr__()` 会被调用，这样就造成了递归调用。</span><br><span class="line">    #这意味这会调用 `self.__setattr__(&apos;name&apos;, value)` ，每次方法会调用自己。这样会造成程序崩溃。</span><br><span class="line"></span><br><span class="line">def __setattr__(self, name, value):</span><br><span class="line">    self.__dict__[name] = value  #给类中的属性名分配值</span><br><span class="line">    #定制特有属性</span><br></pre></td></tr></table></figure><p>Python的魔术方法非常强大，然而随之而来的则是责任。了解正确的方法去使用非常重要。</p><p>所以我们对于定制属性访问权限了解了多少呢。它不应该被轻易的使用。实际上，它非常强大。但是它存在的原因是:Python 不会试图将一些不好的东西变得不可能，而是让它们难以实现。自由是至高无上的，所以你可以做任何你想做的。以下是一个特别的属性控制的例子(我们使用 <code>super</code> 因为不是所有的类都有 <code>__dict__</code> 属性):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class AccessCounter:</span><br><span class="line">    &apos;&apos;&apos;一个包含计数器的控制权限的类每当值被改变时计数器会加一&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        super(AccessCounter, self).__setattr__(&apos;counter&apos;, 0)</span><br><span class="line">        super(AccessCounter, self).__setattr__(&apos;value&apos;, val)</span><br><span class="line"></span><br><span class="line">    def __setattr__(self, name, value):</span><br><span class="line">        if name == &apos;value&apos;:</span><br><span class="line">            super(AccessCounter, self).__setattr__(&apos;counter&apos;, self.counter + 1)</span><br><span class="line">    #如果你不想让其他属性被访问的话，那么可以抛出 AttributeError(name) 异常</span><br><span class="line">        super(AccessCounter, self).__setattr__(name, value)</span><br><span class="line"></span><br><span class="line">    def __delattr__(self, name):</span><br><span class="line">        if name == &apos;value&apos;:</span><br><span class="line">            super(AccessCounter, self).__setattr__(&apos;counter&apos;, self.counter + 1)</span><br><span class="line">        super(AccessCounter, self).__delattr__(name)]</span><br></pre></td></tr></table></figure></p><h1 id="创建定制的序列"><a href="#创建定制的序列" class="headerlink" title="创建定制的序列"></a>创建定制的序列</h1><p>有很多方法让你的Python类行为可以像内置的序列(dict, tuple,list, string等等)。这是目前为止我最喜欢的魔术方法,因为它给你很搞的控制权限而且让很多函数在你的类实例上工作的很出色。但是在开始之前，需要先讲一些必须条件。</p><h2 id="必须条件"><a href="#必须条件" class="headerlink" title="必须条件"></a>必须条件</h2><p>现在我们开始讲如何在Python中创建定制的序列，这个时候该讲一讲协议。协议(Protocols)与其他语言中的接口很相似。它给你很多你必须定义的方法。然而在Python中的协议是很不正式的，不需要明确声明实现。事实上，他们更像一种指南。</p><p>我们为什么现在讨论协议？因为如果要定制容器类型的话需要用到这些协议。首先，实现不变容器的话有一个协议:实现不可变容器，你只能定义 <code>__len__</code> 和 <code>__getitem__</code> (一会会讲更多)。可变容器协议则需要所有不可变容器的所有另外还需要 <code>__setitem__</code> 和 <code>__delitem__</code> 。最终，如果你希望你的对象是可迭代的话，你需要定义 <code>__iter__</code> 会返回一个迭代器。迭代器必须遵循迭代器协议，需要有 <code>__iter__</code> (返回它本身) 和 <code>next</code> 。</p><h2 id="容器的魔法"><a href="#容器的魔法" class="headerlink" title="容器的魔法"></a>容器的魔法</h2><p>这些是容器使用的魔术方法。<br><code>__len__(self)</code><br>然会容器长度。对于可变不可变容器都需要有的协议的一部分。<br><code>__getitem__(self, key)</code><br>定义当一个条目被访问时，使用符号 <code>self[key]</code> 。这也是不可变容器和可变容器都要有的协议的一部分。如果键的类型错误和 <code>KeyError</code> 或者没有合适的值。那么应该抛出适当的 <code>TypeError</code> 异常。<br><code>__setitem__(self, key, value)</code><br>定义当一个条目被赋值时的行为,使用 <code>self[key] = value</code> 。这也是可变容器和不可变容器协议中都要有的一部分。<br><code>__delitem__(self, key)</code><br>定义当一个条目被删除时的行为(比如 <code>del self[key]</code>)。这只是可变容器协议中的一部分。当使用一个无效的键时应该抛出适当的异常。<br><code>__iter__(self)</code><br>返回一个容器的迭代器。很多情况下会返回迭代器，尤其是当内置的 <code>iter()</code> 方法被调用的时候，或者当使用 <code>for x in container</code> 方式循环的时候。迭代器是他们本身的对象，他们必须定义返回 <code>self</code> 的 <code>__iter__</code> 方法。<br><code>__reversed__(self)</code><br>实现当 <code>reversed()</code> 被调用时的行为。应该返回列表的反转版本。<br><code>__contains__(self, item)</code><br>当调用 <code>in</code> 和 <code>not in</code> 来测试成员是否存在时候 <code>__contains__</code> 被定义。你问为什么这个不是序列协议的一部分？那是因为当 <code>__contains__</code> 没有被定义的时候，Python会迭代这个序列并且当找到需要的值时会返回 <code>True</code> 。<br><code>__concat__(self, other)</code><br>最终，你可以通过 <code>__concat__</code> 来定义当用其他的来连接两个序列时候的行为。当 <code>+</code> 操作符被调用时候会返回一个 <code>self</code> 和 <code>other.__concat__</code> 被调用后的结果产生的新序列。</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>在我们的例子中，让我们看一看你可能在其他语言中 用到的函数构造语句的实现(比如 Haskell)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class FunctionalList:</span><br><span class="line">&apos;&apos;&apos;一个封装了一些附加魔术方法比如 head, tail, init, last, drop, 和take的列表类。</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">def __init__(self, values=None):</span><br><span class="line">if values is None:</span><br><span class="line">    self.values = []</span><br><span class="line">else:</span><br><span class="line">    self.values = values</span><br><span class="line"></span><br><span class="line">def __len__(self):</span><br><span class="line">    return len(self.values)</span><br><span class="line"></span><br><span class="line">def __getitem__(self, key):</span><br><span class="line">    #如果键的类型或者值无效，列表值将会抛出错误</span><br><span class="line">    return self.values[key]</span><br><span class="line"></span><br><span class="line">def __setitem__(self, key, value):</span><br><span class="line">    self.values[key] = value</span><br><span class="line"></span><br><span class="line">def __delitem__(self, key):</span><br><span class="line">    del self.values[key]</span><br><span class="line"></span><br><span class="line">def __iter__(self):</span><br><span class="line">    return iter(self.values)</span><br><span class="line"></span><br><span class="line">def __reversed__(self):</span><br><span class="line">    return reversed(self.values)</span><br><span class="line"></span><br><span class="line">def append(self, value):</span><br><span class="line">    self.values.append(value)</span><br><span class="line">def head(self):</span><br><span class="line">    return self.values[0]</span><br><span class="line">def tail(self):</span><br><span class="line">    return self.values[1:]</span><br><span class="line">def init(self):</span><br><span class="line">    #返回一直到末尾的所有元素</span><br><span class="line">    return self.values[:-1]</span><br><span class="line">def last(self):</span><br><span class="line">    #返回末尾元素</span><br><span class="line">    return self.values[-1]</span><br><span class="line">def drop(self, n):</span><br><span class="line">    #返回除前n个外的所有元素</span><br><span class="line">    return self.values[n:]</span><br><span class="line">def take(self, n):</span><br><span class="line">    #返回前n个元素</span><br><span class="line">    return self.values[:n]</span><br></pre></td></tr></table></figure></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>你可以通过魔术方法控制控制使用 <code>isinstance()</code> 和 <code>issubclass()</code> 内置方法的反射行为。这些魔术方法是:</p><p><code>__instancecheck__(self, instance)</code></p><p>检查一个实例是不是你定义的类的实例</p><p><code>__subclasscheck__(self, subclass)</code></p><p>检查一个类是不是你定义的类的子类</p><p>这些方法的用例似乎很少，这也许是真的。我不会花更多的时间在这些魔术方法上因为他们并不是很重要，但是他们的确反应了Python 中的面向对象编程的一些基本特性:非常容易的去做一些事情，即使并不是很必须。这些魔术方法看起来并不是很有用，但是当你需要的时候你会很高兴有这种特性。</p><h1 id="可以调用的对象"><a href="#可以调用的对象" class="headerlink" title="可以调用的对象"></a>可以调用的对象</h1><p>你也许已经知道，在Python中，方法也是一种高等的对象。这意味着他们也可以被传递到方法中就像其他对象一样。这是一个非常惊人的特性。<br>在Python中，一个特殊的魔术方法可以让类的实例的行为表现的像函数一样，你可以调用他们，将一个函数当做一个参数传到另外一个函数中等等。这是一个非常强大的特性让Python编程更加舒适甜美。<br><code>__call__(self, [args...])</code>  </p><p>允许一个类的实例像函数一样被调用。实质上说，这意味着 <code>x()</code> 与 <code>x.__call__()</code> 是相同的。注意 <code>__call__</code> 参数可变。这意味着你可以定义 <code>__call__</code> 为其他你想要的函数，无论有多少个参数。</p><p><code>__call__</code> 在那些类的实例经常改变状态的时候会非常有效。调用这个实例是一种改变这个对象状态的直接和优雅的做法。用一个实例来表达最好不过了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Entity:</span><br><span class="line">&apos;&apos;&apos;调用实体来改变实体的位置。&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">def __init__(self, size, x, y):</span><br><span class="line">    self.x, self.y = x, y</span><br><span class="line">    self.size = size</span><br><span class="line"></span><br><span class="line">def __call__(self, x, y):</span><br><span class="line">    &apos;&apos;&apos;改变实体的位置&apos;&apos;&apos;</span><br><span class="line">    self.x, self.y = x, y</span><br></pre></td></tr></table></figure></p><h1 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h1><p>在Python 2.5中，为了代码利用定义了一个新的关键词 <code>with</code> 语句。会话控制在Python中不罕见(之前是作为库的一部分被实现)，直到 <code>PEP343 &lt;http://www.python.org/dev/peps/pep-0343/&gt;</code>_ 被添加后。它被成为一级语言结构。你也许之前看到这样的语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;foo.txt&apos;) as bar:</span><br><span class="line">    perform some action with bar</span><br></pre></td></tr></table></figure><p>回话控制器通过包装一个 <code>with</code> 语句来设置和清理行为。回话控制器的行为通过两个魔术方法来定义:<br><code>__enter__(self)</code><br>定义当使用 <code>with</code> 语句的时候会话管理器应该初始块被创建的时候的行为。注意 <code>__enter__</code> 的返回值被 <code>with</code> 语句的目标或者 <code>as</code> 后的名字绑定。<br><code>__exit__(self, exception_type, exception_value, traceback)</code><br>定义当一个代码块被执行或者终止后会话管理器应该做什么。它可以被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作。如果代码块执行成功， <code>exception_type</code> , <code>exception_value</code> , 和 <code>traceback</code> 将会是 <code>None</code> 。否则的话你可以选择处理这个异常或者是直接交给用户处理。如果你想处理这个异常的话，确认 <code>__exit__</code> 在所有结束之后会返回 <code>True</code> 。如果你想让异常被会话管理器处理的话，那么就这样处理。</p><p><code>__enter</code> 和 <code>__exit__</code> 对于明确有定义好的和日常行为的设置和清洁工作的类很有帮助。你也可以使用这些方法来创建一般的可以包装其他对象的会话管理器。以下是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Closer:</span><br><span class="line">&apos;&apos;&apos;通过with语句和一个close方法来关闭一个对象的会话管理器&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">def __init__(self, obj):</span><br><span class="line">    self.obj = obj</span><br><span class="line"></span><br><span class="line">def __enter__(self):</span><br><span class="line">    return self.obj # bound to target</span><br><span class="line"></span><br><span class="line">def __exit__(self, exception_type, exception_val, trace):</span><br><span class="line">    try:</span><br><span class="line">        self.obj.close()</span><br><span class="line">    except AttributeError: # obj isn&apos;t closable</span><br><span class="line">        print &apos;Not closable.&apos;</span><br><span class="line">        return True # exception handled successfully</span><br></pre></td></tr></table></figure><p>以下是一个使用 <code>Closer</code> 的例子，使用一个FTP链接来证明(一个可关闭的套接字):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from magicmethods import Closer</span><br><span class="line">&gt;&gt;&gt; from ftplib import FTP</span><br><span class="line">&gt;&gt;&gt; with Closer(FTP(&apos;ftp.somesite.com&apos;)) as conn:</span><br><span class="line">...     conn.dir()</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; conn.dir()</span><br><span class="line">&gt;&gt;&gt; with Closer(int(5)) as i:</span><br><span class="line">...     i += 1</span><br><span class="line">...</span><br><span class="line">Not closable.</span><br><span class="line">&gt;&gt;&gt; i</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><p>你已经看到了我们的包装器如何静默的处理适当和不适当的使用行为。这是会话管理器和魔术方法的强大功能。</p><h1 id="创建对象的描述器"><a href="#创建对象的描述器" class="headerlink" title="创建对象的描述器"></a>创建对象的描述器</h1><p>描述器是通过得到，设置，删除的时候被访问的类。当然也可以修改其他的对象。描述器并不是鼓励的，他们注定被一个所有者类所持有。当创建面向对象的数据库或者类，里面含有相互依赖的属性时，描述器将会非常有用。一种典型的使用方法是用不同的单位表示同一个数值，或者表示某个数据的附加属性(比如坐标系上某个点包含了这个点到远点的距离信息)。</p><p>为了构建一个描述器，一个类必须有至少 <code>__get__</code> 或者 <code>__set__</code> 其中一个，并且 <code>__delete__</code> 被实现。让我们看看这些魔术方法。<br><code>__get__(self, instance, owner)</code><br>定义当描述器的值被取得的时候的行为， <code>instance</code> 是拥有者对象的一个实例。 <code>owner</code> 是拥有者类本身。<br><code>__set__(self, instance, value)</code><br>定义当描述器值被改变时候的行为。 <code>instance</code> 是拥有者类的一个实例 <code>value</code> 是要设置的值。<br><code>__delete__(self, instance)</code><br>定义当描述器的值被删除的行为。<code>instance</code> 是拥有者对象的实例。<br>以下是一个描述器的实例:单位转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Meter(object):</span><br><span class="line">&apos;&apos;&apos;Descriptor for a meter.&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, value=0.0):</span><br><span class="line">    self.value = float(value)</span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">    return self.value</span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">    self.value = float(value)</span><br><span class="line"></span><br><span class="line">class Foot(object):</span><br><span class="line">    &apos;&apos;&apos;Descriptor for a foot.&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    def __get__(self, instance, owner):</span><br><span class="line">    return instance.meter * 3.2808</span><br><span class="line">    def __set__(self, instance, value):</span><br><span class="line">    instance.meter = float(value) / 3.2808</span><br><span class="line"></span><br><span class="line">class Distance(object):</span><br><span class="line">    &apos;&apos;&apos;Class to represent distance holding two descriptors for feet and</span><br><span class="line">    meters.&apos;&apos;&apos;</span><br><span class="line">    meter = Meter()</span><br><span class="line">    foot = Foot()</span><br></pre></td></tr></table></figure><h1 id="储存你的对象"><a href="#储存你的对象" class="headerlink" title="储存你的对象"></a>储存你的对象</h1><p>如果你接触过其他的 Pythoner，你可能已经听说过 Pickle 了， Pickle 是用来序列化 Python 数据结构的模块，在你需要暂时存储一个对象的时候（比如缓存），这个模块非常的有用，不过这同时也是隐患的诞生地。</p><p>序列化数据是一个非常重要的功能，所以他不仅仅拥有相关的模块（ <code>Pickle</code> , <code>cPickle</code> ），还有自己的协议以及魔术方法，不过首先，我们先讨论下关于序列化内建数据结构的方法。</p><h2 id="Pickling-简单例子"><a href="#Pickling-简单例子" class="headerlink" title="Pickling: 简单例子"></a>Pickling: 简单例子</h2><p>让我们深入研究 Pickle，比如说你现在需要临时储存一个字典，你可以把它写入到一个文件里，并且要小心翼翼的确保格式正确，之后再用 exec() 或者处理文件输入来恢复数据，实际上这是很不安全的，如果你使用文本存储了一些重要的数据，任何方式的改变都可能会影响到你的程序，轻则程序崩溃，重则被恶意程序利用，所以，让我们用 Pickle 代替这种方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line"></span><br><span class="line">data = &#123;&apos;foo&apos;: [1, 2, 3],</span><br><span class="line">        &apos;bar&apos;: (&apos;Hello&apos;, &apos;world!&apos;),</span><br><span class="line">        &apos;baz&apos;: True&#125;</span><br><span class="line">jar = open(&apos;data.pkl&apos;, &apos;wb&apos;)</span><br><span class="line">pickle.dump(data, jar) # write the pickled data to the file jar</span><br><span class="line">jar.close()</span><br></pre></td></tr></table></figure><p>嗯，过了几个小时之后，我们需要用到它了，只需把它 unpickle 了就行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line"></span><br><span class="line">pkl_file = open(&apos;data.pkl&apos;, &apos;rb&apos;) # connect to the pickled data</span><br><span class="line">data = pickle.load(pkl_file) # load it into a variable</span><br><span class="line">print data</span><br><span class="line">pkl_file.close()</span><br></pre></td></tr></table></figure></p><p>正如你期望的，数据原封不动的回来了！</p><p>同时要给你一句忠告： pickle 并不是很完美， Pickle 文件很容易被不小心或者故意损坏， Pickle 文件比纯文本文件要稍微安全一点，但是还是可以被利用运行恶意程序。 Pickle 不是跨版本兼容的（译注：最近刚好在 《Python Cookbook》上看到相关讨论，书中描述的 Pickle 是跨版本兼容的，此点待验证），所以尽量不要去分发 Pickle 过的文本，因为别人并不一定能够打开。不过在做缓存或者其他需要序列化数据的时候， Pickle 还是很有用处的。</p><h2 id="序列化你自己的对象"><a href="#序列化你自己的对象" class="headerlink" title="序列化你自己的对象"></a>序列化你自己的对象</h2><p>Pickle 并不是只支持内建数据结果，任何遵循 Pickle 协议的类都可以，Pickle 协议为 Python 对象规定了4个可选方法来自定义 Pickle 行为（对于 C 扩展的 cPickle 模块会有一些不同，但是这并不在我们的讨论范围内）：</p><p><code>__getinitargs__(self)</code></p><p>如果你希望在逆序列化的同时调用 <code>__init__</code> ，你可以定义 <code>__getinitargs__</code> 方法，这个方法应该返回一系列你想被 <code>__init__</code> 调用的参数，注意这个方法只对老样式的类起作用。</p><p><code>__getnewargs__(self)</code></p><p>对于新式的类，你可以定义任何在重建对象时候传递到 <code>__new__</code> 方法中的参数。这个方法也应该返回一系列的被 <code>__new__</code> 调用的参数。</p><p><code>__getstate__(self)</code></p><p>你可以自定义当对象被序列化时返回的状态，而不是使用 <code>__dict</code> 方法，当逆序列化对象的时候，返回的状态将会被 <code>__setstate__</code> 方法调用。</p><p><code>__setstate__(self, state)</code></p><p>在对象逆序列化的时候，如果 <code>__setstate__</code> 定义过的话，对象的状态将被传给它而不是传给 <code>__dict__</code> 。这个方法是和 <code>__getstate__</code> 配对的，当这两个方法都被定义的时候，你就可以完全控制整个序列化与逆序列化的过程了。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我们以 Slate 为例，这是一段记录一个值以及这个值是何时被写入的程序，但是，这个 Slate 有一点特殊的地方，当前值不会被保存。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">class Slate:</span><br><span class="line">    &apos;&apos;&apos;Class to store a string and a changelog, and forget its value when</span><br><span class="line">    pickled.&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, value):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.last_change = time.asctime()</span><br><span class="line">        self.history = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def change(self, new_value):</span><br><span class="line">        # Change the value. Commit last value to history</span><br><span class="line">        self.history[self.last_change] = self.value</span><br><span class="line">        self.value = new_value</span><br><span class="line">        self.last_change = time.asctime()</span><br><span class="line"></span><br><span class="line">    def print_changes(self):</span><br><span class="line">        print &apos;Changelog for Slate object:&apos;</span><br><span class="line">        for k, v in self.history.items():</span><br><span class="line">            print &apos;%s\t %s&apos; % (k, v)</span><br><span class="line"></span><br><span class="line">    def __getstate__(self):</span><br><span class="line">        # Deliberately do not return self.value or self.last_change.</span><br><span class="line">        # We want to have a &quot;blank slate&quot; when we unpickle.</span><br><span class="line">        return self.history</span><br><span class="line"></span><br><span class="line">    def __setstate__(self, state):</span><br><span class="line">        # Make self.history = state and last_change and value undefined</span><br><span class="line">        self.history = state</span><br><span class="line">        self.value, self.last_change = None, None</span><br></pre></td></tr></table></figure></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这份指南的希望为所有人都能带来一些知识，即使你是 Python 大牛或者对于精通于面向对象开发。如果你是一个 Python 初学者，阅读这篇文章之后你已经获得了编写丰富，优雅，灵活的类的知识基础了。如果你是一个有一些经验的 Python 程序员，你可能会发现一些能让你写的代码更简洁的方法。如果你是一个 Python 大牛，可能会帮助你想起来一些你已经遗忘的知识，或者一些你还没听说过的新功能。不管你现在有多少经验，我希望这次对于 Python 特殊方法的旅程能够带给你一些帮助（用双关语真的很不错 XD）（译注: 这里的双关在于标题为 Magic Methods 这里是 神奇的旅程 ，不过由于中英语序的问题，直译略显头重脚轻，所以稍微变化了下意思，丢掉了双关的含义）。</p><h1 id="附录：如何调用魔术方法"><a href="#附录：如何调用魔术方法" class="headerlink" title="附录：如何调用魔术方法"></a>附录：如何调用魔术方法</h1><p>一些魔术方法直接和内建函数相对，在这种情况下，调用他们的方法很简单，但是，如果是另外一种不是特别明显的调用方法，这个附录介绍了很多并不是很明显的魔术方法的调用形式。</p><table><thead><tr><th>魔术方法</th><th>调用方式</th><th>解释</th></tr></thead><tbody><tr><td><strong>new</strong>(cls [,…])</td><td>instance = MyClass(arg1, arg2)</td><td><strong>new</strong> 在创建实例的时候被调用</td></tr><tr><td><strong>init</strong>(self [,…])</td><td>instance = MyClass(arg1, arg2)</td><td><strong>init</strong> 在创建实例的时候被调用</td></tr><tr><td><strong>cmp</strong>(self, other)</td><td>self == other, self &gt; other, 等。</td><td>在比较的时候调用</td></tr><tr><td><strong>pos</strong>(self)</td><td></td><td>self</td><td>一元加运算符</td></tr><tr><td><strong>neg</strong>(self)</td><td>-self</td><td>一元减运算符</td></tr><tr><td><strong>invert</strong>(self)</td><td>~self</td><td>取反运算符</td></tr><tr><td><strong>index</strong>(self)</td><td>x[self]</td><td>对象被作为索引使用的时候</td></tr><tr><td><strong>nonzero</strong>(self)</td><td>bool(self)</td><td>对象的布尔值</td></tr><tr><td><strong>getattr</strong>(self, name)</td><td>self.name # name 不存在</td><td>访问一个不存在的属性时</td></tr><tr><td><strong>setattr</strong>(self, name, val)</td><td>self.name = val</td><td>对一个属性赋值时</td></tr><tr><td><strong>delattr</strong>(self, name)</td><td>del self.name</td><td>删除一个属性时</td></tr><tr><td>__getattribute(self, name)</td><td>self.name</td><td>访问任何属性时</td></tr><tr><td><strong>getitem</strong>(self, key)</td><td>self[key]</td><td>使用索引访问元素时</td></tr><tr><td><strong>setitem</strong>(self, key, val)</td><td>self[key] = val</td><td>对某个索引值赋值时</td></tr><tr><td><strong>delitem</strong>(self, key)</td><td>del self[key]</td><td>删除某个索引值时</td></tr><tr><td><strong>iter</strong>(self)</td><td>for x in self</td><td>迭代时</td></tr><tr><td><strong>contains</strong>(self, value)</td><td>value in self, value not in self</td><td>使用 in 操作测试关系时</td></tr><tr><td><strong>concat</strong>(self, value)</td><td>self</td><td>other</td><td>连接两个对象时</td></tr><tr><td><strong>call</strong>(self [,…])</td><td>self(args)</td><td>“调用”对象时</td></tr><tr><td><strong>enter</strong>(self)</td><td>with self as x:</td><td>with 语句环境管理</td></tr><tr><td><strong>exit</strong>(self, exc, val, trace)</td><td>with self as x:</td><td>with 语句环境管理</td></tr><tr><td><strong>getstate</strong>(self)</td><td>pickle.dump(pkl_file, self)</td><td>序列化</td></tr><tr><td><strong>setstate</strong>(self)</td><td>data = pickle.load(pkl_file)</td><td>序列化</td></tr></tbody></table><p>希望这个表格对你对于什么时候应该使用什么方法这个问题有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 魔术方法 </tag>
            
            <tag> oop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>对象引用、可变性[流畅的Python]</title>
      <link href="/2017/08/20/fluent_python_chapter8/"/>
      <url>/2017/08/20/fluent_python_chapter8/</url>
      
        <content type="html"><![CDATA[<p>记录一下在读《流程的python》时对自己有用的知识点。<br><a id="more"></a></p><h1 id="1-变量不是盒子"><a href="#1-变量不是盒子" class="headerlink" title="1. 变量不是盒子"></a>1. 变量不是盒子</h1><p>进行赋值操作的时候，并不是将一个对象放在变量构成的<code>盒子</code>中。实际上，在进行赋值操作的时候，等号右边的对象是在它被创建之后才把等号左边的变量分配给它，相当于给这个对象贴上了一个标签🏷️。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: class Gizmo:</span><br><span class="line">   ...:     def __init__(self):</span><br><span class="line">   ...:         print(id(self))</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [2]: x = Gizmo()</span><br><span class="line">4418370088</span><br><span class="line"></span><br><span class="line">In [3]: y = Gizmo()[0]</span><br><span class="line">4418271496</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-3-81d29164ac5d&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; 1 y = Gizmo()[0]</span><br><span class="line"></span><br><span class="line">AttributeError: Gizmo instance has no attribute &apos;__getitem__&apos;</span><br></pre></td></tr></table></figure></p><p>可以看到，在将变量x分配给类Gizmo的一个实例之前，Gizmo的实例已经被创建。</p><h1 id="2-标识、相等性和别名"><a href="#2-标识、相等性和别名" class="headerlink" title="2. 标识、相等性和别名"></a>2. 标识、相等性和别名</h1><p>正如上边所说，变量相当于是一个对象的标签，当然，一个对象可以被贴上许多标签，即多个变量绑定同一个对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [4]: list1 = [0,1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">In [5]: list2 = list1</span><br><span class="line"></span><br><span class="line">In [6]: list2</span><br><span class="line">Out[6]: [0, 1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">In [7]: list2.append(6)</span><br><span class="line"></span><br><span class="line">In [8]: list1</span><br><span class="line">Out[8]: [0, 1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure></p><p>可以看到list1和list2是同一个对象的不同标签。<br>但是，如何才能判断两个变量是否绑定的是同一个对象？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [9]: list3 = [0,1,2,3,4,5,6]</span><br><span class="line"></span><br><span class="line">In [10]: list3 == list1 == list2</span><br><span class="line">Out[10]: True</span><br></pre></td></tr></table></figure></p><p>接着上边的例子，我们现在有一个叫做list3的变量，它和list1、list2是相等的，但是它们三个绑定的是同一个对象吗？python官方文档中有这样的描述：</p><blockquote><p>每个变量都有标识、类型和值。对象一旦创建，它的标识绝对不会变化；你可以把标识当作该对象在内存中的地址。is运算符用以比较两个对象的标识，内建函数<code>id()</code>返回对象标识的整数表示。</p></blockquote><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [12]: list1 is list2</span><br><span class="line">Out[12]: True</span><br><span class="line"></span><br><span class="line">In [13]: list3 is list1</span><br><span class="line">Out[13]: False</span><br><span class="line"></span><br><span class="line">In [14]: id(list1)</span><br><span class="line">Out[14]: 4418368144</span><br><span class="line"></span><br><span class="line">In [15]: id(list2)</span><br><span class="line">Out[15]: 4418368144</span><br><span class="line"></span><br><span class="line">In [16]: id(list3)</span><br><span class="line">Out[16]: 4418128064</span><br></pre></td></tr></table></figure>可以看到`list1 is list2`并且`id(list1) == id(list2)`,这说明list1和list2绑定的是同一个对象，list3则和list1或者list2绑定的是不同的对象，即使是`list3 == list1 == list2`</code></pre><h1 id="3-运算符is和"><a href="#3-运算符is和" class="headerlink" title="3. 运算符is和=="></a>3. 运算符<code>is</code>和<code>==</code></h1><p>通过上边的例子，有个直观的印象就是</p><blockquote><p><code>is</code>用于比较对象的标识，<code>==</code>用于比较对象的值</p></blockquote><pre><code>通常情况下，我们会更多的使用`==`进行对象间的值的比较，但是在&lt;strong&gt;变量和单例值之间的比较，更应该使用`is`&lt;/strong&gt;。这是因为: &lt;strong&gt;`is`运算符比`==`更快，因为它不能重载，这样python不用寻找并调用特殊方法，而是直接比较两个整数ID。`a == b`是语法糖，等同于执行`a.__eq__(b)`。继承自object的`__eq__`方法比较的是两个对象的ID，结果和`is`一样，但是多数内置类型都定义了更有意义的方式，覆盖了`__eq__`，这样就可能会给相等性测试带来更多复杂的处理工作。&lt;/strong&gt;</code></pre><h1 id="4-元组的相对不可变性"><a href="#4-元组的相对不可变性" class="headerlink" title="4. 元组的相对不可变性"></a>4. 元组的相对不可变性</h1><p>元组与多数python的集合类型一样（这里的一样指的是：列表、字典、集等而不包括像是str，bytes和array.array这样的单一类型序列，它们保存的不是引用，而是在连续内存中保存的数据本身），保存的是对象的引用。所以，如果引用的元素是可变的，即使元组本身不变，它其中的元素也是可变的。<strong>元组的不可变性，指的是它其中保存的引用不变（数据结构和物理内容），与引用的对象无关</strong></p><h1 id="5-copy和deepcopy"><a href="#5-copy和deepcopy" class="headerlink" title="5. copy和deepcopy"></a>5. copy和deepcopy</h1><p>由上边的例子可以看到，像列表、字典等集合类型，它们内部保存的是对象的引用，所以就会出现这样的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">In [33]: l1 = [3,[4,5,6],(7,8,9)]</span><br><span class="line"></span><br><span class="line">In [34]: l2 = list(l1)</span><br><span class="line"></span><br><span class="line">In [35]: l2</span><br><span class="line">Out[35]: [3, [4, 5, 6], (7, 8, 9)]</span><br><span class="line"></span><br><span class="line">In [36]: l1.append(0)</span><br><span class="line"></span><br><span class="line">In [37]: l1[1].append(&apos;x&apos;)</span><br><span class="line"></span><br><span class="line">In [38]: print(l1)</span><br><span class="line">[3, [4, 5, 6, &apos;x&apos;], (7, 8, 9), 0]</span><br><span class="line"></span><br><span class="line">In [39]: print(l2)</span><br><span class="line">[3, [4, 5, 6, &apos;x&apos;], (7, 8, 9)]</span><br><span class="line"></span><br><span class="line">In [40]: l2[1] += [&apos;y&apos;,&apos;z&apos;]</span><br><span class="line"></span><br><span class="line">In [41]: l2[2] += (&apos;x&apos;,&apos;y&apos;,&apos;z&apos;)</span><br><span class="line"></span><br><span class="line">In [42]: l1</span><br><span class="line">Out[42]: [3, [4, 5, 6, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;], (7, 8, 9), 0]</span><br><span class="line"></span><br><span class="line">In [43]: l2</span><br><span class="line">Out[43]: [3, [4, 5, 6, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;], (7, 8, 9, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;)]</span><br></pre></td></tr></table></figure></p><p>In [33]和In [34]进行了简单的列表复制，通过内置的构造函数来完成赋值。这个时候<code>l1 == l2</code>并且<code>l1 is not l2</code>它们绑定了不同的对象。所以In [36]中l1.append(0)并不会对l2造成影响。<br>但是由于列表内部保存的是对象的引用，所以<code>l1[1] == [4,5,6]</code>，如果对l1[1]进行操作，l2自然会收到影响。<br>In [40]和In [41]分别对l2[1]和l2[2]进行操作，列表在进行<code>+=</code>操作之后，会就地修改列表，但对于元组来说<code>+=</code>操作会创建一个新的元组然后重新绑定给变量<strong>l2[2]</strong>，这样<code>l1[2]</code>和<code>l2[2]</code>就不是同一个对象。（个人觉得，上边的这个过程可以当作一道优秀的面试题目😊）</p><blockquote><p>对<code>+=</code>或者<code>*=</code>所做的增量复制操作来说，如果操作符左侧绑定的是不可变对象，会创建一个新的对象，如果是可变对象，会就地修改</p></blockquote><pre><code>默认情况下，python进行的复制都是浅复制（副本共享内部对象的引用）,通过copy模块提供的deepcopy和copy可以为任何对象做深复制或者浅复制。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">In [55]: class Bus:</span><br><span class="line">    ...:     def __init__(self,passengers=None):</span><br><span class="line">    ...:         if passengers is None:</span><br><span class="line">    ...:             self.passengers = []</span><br><span class="line">    ...:         else:</span><br><span class="line">    ...:             self.passengers = passengers</span><br><span class="line">    ...:     def pick(self,name):</span><br><span class="line">    ...:         self.passengers.append(name)</span><br><span class="line">    ...:     def drop(self,name):</span><br><span class="line">    ...:         self.passengers.remove(name)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [56]: import copy</span><br><span class="line"></span><br><span class="line">In [57]: bus1 = Bus([&apos;wm&apos;,&apos;ws&apos;,&apos;ls&apos;,&apos;gjy&apos;])</span><br><span class="line"></span><br><span class="line">In [58]: bus2 = copy.copy(bus1)</span><br><span class="line"></span><br><span class="line">In [59]: bus3 = copy.deepcopy(bus1)</span><br><span class="line"></span><br><span class="line">In [60]: map(id,[bus1,bus2,bus3])</span><br><span class="line">Out[60]: [4418132448, 4416805992, 4416805920]</span><br><span class="line"></span><br><span class="line">In [61]: bus1.drop(&apos;wm&apos;)</span><br><span class="line"></span><br><span class="line">In [62]: bus2.passengers</span><br><span class="line">Out[62]: [&apos;ws&apos;, &apos;ls&apos;, &apos;gjy&apos;]</span><br><span class="line"></span><br><span class="line">In [63]: bus3.passengers</span><br><span class="line">Out[63]: [&apos;wm&apos;, &apos;ws&apos;, &apos;ls&apos;, &apos;gjy&apos;]</span><br><span class="line"></span><br><span class="line">In [64]: map(id,[bus1.passengers,bus2.passengers,bus3.passengers])</span><br><span class="line">Out[64]: [4419499288, 4419499288, 4418048440]</span><br></pre></td></tr></table></figure>可以看到，通过deepcopy，bus3和bus1之间并没有共享内部对象的引用，而通过copy生成的bus2的`passengers`和bus1是相同的对象。</code></pre><h1 id="6-不要使用可变类型作为参数的默认值"><a href="#6-不要使用可变类型作为参数的默认值" class="headerlink" title="6. 不要使用可变类型作为参数的默认值"></a>6. 不要使用可变类型作为参数的默认值</h1><p>通过下边的例子可以证明上边的这条忠告：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">In [67]: class HauntedBus:</span><br><span class="line">    ...:     def __init__(self,passengers=[]):</span><br><span class="line">    ...:         self.passengers = passengers</span><br><span class="line">    ...:     def pick(self,name):</span><br><span class="line">    ...:         self.passengers.append(name)</span><br><span class="line">    ...:     def drop(self,name):</span><br><span class="line">    ...:         self.passengers.remove(name)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [68]: bus1 = HauntedBus([&apos;wm&apos;,&apos;ws&apos;,&apos;ls&apos;])</span><br><span class="line"></span><br><span class="line">In [69]: bus1.passengers</span><br><span class="line">Out[69]: [&apos;wm&apos;, &apos;ws&apos;, &apos;ls&apos;]</span><br><span class="line"></span><br><span class="line">In [70]: bus1.pick(&apos;gjy&apos;)</span><br><span class="line"></span><br><span class="line">In [71]: bus1.drop(&apos;ws&apos;)</span><br><span class="line"></span><br><span class="line">In [72]: bus1.passengers</span><br><span class="line">Out[72]: [&apos;wm&apos;, &apos;ls&apos;, &apos;gjy&apos;]</span><br><span class="line"></span><br><span class="line">In [73]: bus2 = HauntedBus()</span><br><span class="line"></span><br><span class="line">In [74]: bus2.pick(&apos;wm&apos;)</span><br><span class="line"></span><br><span class="line">In [76]: bus2.passengers</span><br><span class="line">Out[76]: [&apos;wm&apos;]</span><br><span class="line"></span><br><span class="line">In [77]: bus3 = HauntedBus()</span><br><span class="line"></span><br><span class="line">In [78]: bus3.pick(&apos;ws&apos;)</span><br><span class="line"></span><br><span class="line">In [79]: bus3.passengers</span><br><span class="line">Out[79]: [&apos;wm&apos;, &apos;ws&apos;]</span><br></pre></td></tr></table></figure></p><p>可以看到，在没有定义初始乘客的HauntedBus实例会共享同一个乘客列表，这是因为<code>self.passengers</code>变成了<code>passengers</code>参数默认值的别名，默认值在定义函数时计算，因此默认值变成了函数对象的属性，因此，如果默认值是可变对象，并且修改了它的值，那么后续的函数调用都会收到影响。</p><h1 id="7-防御可变参数"><a href="#7-防御可变参数" class="headerlink" title="7. 防御可变参数"></a>7. 防御可变参数</h1><p>如果一个函数接受的是可变参数，那么应该谨慎的考虑是否想要修改传入的参数，是否想要将对这个可变对象的修改作用到函数体之外？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [81]: overwatch_team = [&apos;wm&apos;,&apos;ws&apos;,&apos;ls&apos;,&apos;gjy&apos;,&apos;ll&apos;]</span><br><span class="line"></span><br><span class="line">In [82]: class Twilightbus:</span><br><span class="line">    ...:     def __init__(self,passengers=None):</span><br><span class="line">    ...:         if passengers is None:</span><br><span class="line">    ...:             self.passengers = []</span><br><span class="line">    ...:         else:</span><br><span class="line">    ...:             self.passengers = passengers</span><br><span class="line">    ...:     def pick(self,name):</span><br><span class="line">    ...:         self.passengers.append(name)</span><br><span class="line">    ...:     def drop(self,name):</span><br><span class="line">    ...:         self.passengers.remove(name)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [83]: bus = Twilightbus(overwatch_team)</span><br><span class="line"></span><br><span class="line">In [84]: bus.drop(&apos;wm&apos;)</span><br><span class="line"></span><br><span class="line">In [85]: bus.drop(&apos;ws&apos;)</span><br><span class="line"></span><br><span class="line">In [86]: overwatch_team</span><br><span class="line">Out[86]: [&apos;ls&apos;, &apos;gjy&apos;, &apos;ll&apos;]</span><br></pre></td></tr></table></figure></p><p>可以看到Twilightbus可以让乘客莫名其妙的销声匿迹😨。这是因为，在将参数passenger传给Twilightbus的时候，实际上是将<code>self.passengers</code>变成了passengers的别名，所以每当乘客下车执行<code>drop()</code>的时候，直接将乘客从列表中抹去。<br>如果想要避免这种状况，可以在初始化函数中做一些修改:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self,passengers):</span><br><span class="line">    if passengers is None:</span><br><span class="line">        self.passengers = []</span><br><span class="line">    else:</span><br><span class="line">        self.passengers = list(passengers)</span><br></pre></td></tr></table></figure></p><p>经过上边这样的内部处理，就不会发生上边的幽灵巴士案件。所以，在类中直接把参数复制给实例变量以前一定要考虑清楚。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 读书 </tag>
            
            <tag> 可变类型 </tag>
            
            <tag> 深浅拷贝 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Iterables,Iterators和Generators</title>
      <link href="/2017/08/10/Iterables,Iterators%E5%92%8CGenerators/"/>
      <url>/2017/08/10/Iterables,Iterators%E5%92%8CGenerators/</url>
      
        <content type="html"><![CDATA[<p>最近一段时间都在研究python里边的一些概念:<strong>iterator,iterable和generator</strong>.看到<a href="http://nvie.com/posts/iterators-vs-generators/" target="_blank" rel="noopener">这篇文章</a>写的十分不错,基本上讲清楚了这三个东西都是什么以及他们之间的关系.这当然值得记录一下😊.<br>所谓一图胜千言,这篇文章中的这个关系图让人一目了然.<br><img src="https://eclipsesv.com/pics/relationships.png" alt="relationships.png"><br><a id="more"></a></p><h1 id="纠结所在"><a href="#纠结所在" class="headerlink" title="纠结所在"></a>纠结所在</h1><p>如果对<strong>iterator,iterable和generator</strong>的概念比较纠结,一般主要是没有区分清楚:</p><ul><li>container</li><li>iterable</li><li>iterator</li><li>generator</li><li>generator expression</li><li>[list,set,dict] comprehension</li></ul><p>下面按照原文中讲解的那样,对上边几个概念逐一解释:</p><h1 id="container"><a href="#container" class="headerlink" title="container"></a>container</h1><p>在python中container是一类用于存放各种元素(item)的容器,并且它能够判断一个item是否在container中.<strong>一般来说</strong>它会将它内部的元素都存放在内存中,并且能够逐一返回它内部的每个元素.一些比较典型的类型都是container:</p><ul><li>list,deque…</li><li>set,fronzensets…</li><li>dict,defaultdict,OrderedDict,Counter…</li><li>tuple,namedtuple…</li><li>str</li></ul><p>container相对来说比较容易理解,因为它就像是现实生活中的一些真实容器,用来存放各种东西.并且container可以很容易的判断一个item是否是它的一个元素,几个🌰:</p><ul><li><p>对于list、set、tuple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; assert 1 in [1, 2, 3]      # lists</span><br><span class="line">&gt;&gt;&gt; assert 4 not in [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; assert 1 in &#123;1, 2, 3&#125;      # sets</span><br><span class="line">&gt;&gt;&gt; assert 4 not in &#123;1, 2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; assert 1 in (1, 2, 3)      # tuples</span><br><span class="line">&gt;&gt;&gt; assert 4 not in (1, 2, 3)</span><br></pre></td></tr></table></figure></li><li><p>对于dict,可以直接判断一个元素是否是它的key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;1: &apos;foo&apos;, 2: &apos;bar&apos;, 3: &apos;qux&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; assert 1 in d</span><br><span class="line">&gt;&gt;&gt; assert 4 not in d</span><br><span class="line">&gt;&gt;&gt; assert &apos;foo&apos; not in d  # &apos;foo&apos; is not a _key_ in the dict</span><br><span class="line">&gt;&gt;&gt; assert &apos;foo&apos; in d.values()</span><br></pre></td></tr></table></figure></li><li><p>对于string,可以判断一个字符或者子串是否是这个string的组成部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &apos;foobar&apos;</span><br><span class="line">&gt;&gt;&gt; assert &apos;b&apos; in s</span><br><span class="line">&gt;&gt;&gt; assert &apos;x&apos; not in s</span><br><span class="line">&gt;&gt;&gt; assert &apos;foo&apos; in s  # a string &quot;contains&quot; all its substrings</span><br></pre></td></tr></table></figure></li></ul><p>上边一下例子说明对于container来说,判断一个item是否是它其中的一个元素十分直接、方便.尤其对于string来说,虽然它并没有将它的所有子串都放在内存中,但也是可以通过<code>in</code>来进行子串检测.<br><strong>但是需要注意的是:</strong>上边我们关注的主要是container的<code>成员检测</code>,并且一般来说,container也都可以逐一返回它内部的每个元素,比如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [16]: a = [1,2,3,[4,5]]</span><br><span class="line"></span><br><span class="line">In [17]: for item in a:</span><br><span class="line">    ...:     print item</span><br><span class="line">    ...:</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">[4,5]</span><br></pre></td></tr></table></figure></p><p>但能逐一返回container中每个元素并不是因为它是一个container(有点绕😄),这是因为它是可迭代的(iterable).所有的container都是iterable的.正如上边图中所示的那样<code>a container typically is an iterable</code>.</p><h1 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h1><p>如上所述,所有的container都是iterable的,但是除了各种类型的container以外,像file或者socket这样类型的对象也都是iterable.与container之间不同的是,container大都是包含着有限个元素的,或者说他们有着明确的长度,但是像file或者socket这样的对象他们内部可能会有不那么确定数量的数据.</p><blockquote><p>所以,一个iterable的对象必须是一个能够逐一返回自身包含元素的对象,而这个对象被称为iterator.</p></blockquote><p>iterable和iterator之间的区别可以通过下边的🌰看出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; y = iter(x)</span><br><span class="line">&gt;&gt;&gt; z = iter(x)</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(z)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; type(x)</span><br><span class="line">&lt;class &apos;list&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; type(y)</span><br><span class="line">&lt;class &apos;list_iterator&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>上边的例子中,x是一个iterable(可迭代对象),y和z是两个不同的iterator(迭代器).y和z能够分别逐一返回x中的每个元素,并且这两个iterator之间不会互相影响自己的状态.</p><blockquote><p>通常情况下,一个iterable class会在内部实现<code>__iter__()</code>和<code>__next()__</code>方法,这个过程也可以成为实现了迭代器协议,其中<code>__iter__()</code>方法返回迭代器对象iterator,<code>__next()__</code>实现逐一返回元素的过程.</p></blockquote><p>所以,在使用<code>for item in iterator</code>这样的语句进行遍历的时候,其实执行过程类似于下图:<br><img src="https://eclipsesv.com/pics/iterable-vs-iterator.png" alt="iterable-vs-iterator.png"></p><h1 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h1><p>所以说,到底iterator是个什么东西？🐍</p><blockquote><p>一个iterator对象可以当作是一个工厂,每次使用next()方法,都会产生一个来自iterator内部的值,并且它能够维护于此相关的内部状态.</p></blockquote><p>iterator内部的元素有时候是有限的,但有时候也可能包含无限个数的元素:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from itertools import count</span><br><span class="line">&gt;&gt;&gt; counter = count(start=13)</span><br><span class="line">&gt;&gt;&gt; next(counter)</span><br><span class="line">13</span><br><span class="line">&gt;&gt;&gt; next(counter)</span><br><span class="line">14</span><br></pre></td></tr></table></figure></p><p>利用itertools中的一些方法,可以利用有限元素的iterator变为无限元素的iterator:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from itertools import cycle</span><br><span class="line">&gt;&gt;&gt; colors = cycle([&apos;red&apos;, &apos;white&apos;, &apos;blue&apos;])</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line">&apos;red&apos;</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line">&apos;white&apos;</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line">&apos;blue&apos;</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line">&apos;red&apos;</span><br></pre></td></tr></table></figure></p><p>有的时候,可以在无限元素的iterator中分出一个有限元素的iterator:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from itertools import islice</span><br><span class="line">&gt;&gt;&gt; colors = cycle([&apos;red&apos;, &apos;white&apos;, &apos;blue&apos;])  # infinite</span><br><span class="line">&gt;&gt;&gt; limited = islice(colors, 0, 4)            # finite</span><br><span class="line">&gt;&gt;&gt; for x in limited:                         # so safe to use for-loop on</span><br><span class="line">...     print(x)</span><br><span class="line">red</span><br><span class="line">white</span><br><span class="line">blue</span><br><span class="line">red</span><br></pre></td></tr></table></figure></p><p>通过构造一个斐波那契数列来看iterator对内部状态是如何控制的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class fib:</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         self.prev = 0</span><br><span class="line">...         self.curr = 1</span><br><span class="line">... </span><br><span class="line">...     def __iter__(self):</span><br><span class="line">...         return self</span><br><span class="line">... </span><br><span class="line">...     def __next__(self):</span><br><span class="line">...         value = self.curr</span><br><span class="line">...         self.curr += self.prev</span><br><span class="line">...         self.prev = value</span><br><span class="line">...         return value</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f = fib()</span><br><span class="line">&gt;&gt;&gt; list(islice(f, 0, 10))</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure></p><p>可以看到class fib 实现了迭代器协议,所以f是一个iterator,并且是iterable的.通过两个内部变量<code>prev</code>和<code>curr</code>,fib能够在每次相应<code>next()</code>调用的时候返回对应的值.每次对<code>next()</code>的响应,对于iterator来说主要有两件事情要做:</p><ol><li>为下一次<code>next()</code>调用改变内部状态</li><li>生成当前<code>next()</code>调用要返回的值</li></ol><blockquote><p>由此可以看出,iterator可以当作是一个惰性求值的工厂,每次<code>next()</code>调用会让iterator生成所需要的值,然后在下一次<code>next()</code>调用前都保持空闲状态.🕶️</p></blockquote><h1 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h1><p>generator(生成器),可以当作一种特殊的iterator(更为优雅的一种).<br>它能够用更为简洁的代码来实现上边斐波那契数列,并且避免手动实现<code>__iter()__</code>和<code>__next()__</code>.<br>举个🍐:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fib():</span><br><span class="line">    prev,curr = 0,1</span><br><span class="line">    while True:</span><br><span class="line">        yield curr</span><br><span class="line">        prev,curr = curr,curr+prev</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f = fib()</span><br><span class="line">&gt;&gt;&gt; list(islice(f, 0, 10))</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure></p><p>通过<code>yield</code>来构造的generator,是不是更加优雅.💍<br>通常有两种方法能够构造一个generator:</p><ol><li>generator function</li><li>generator comprehension</li></ol><p><code>generator function</code>很好理解,表面上和普通的函数没什么区别,只是这个函数通过关键字<code>yield</code>来返回值.<br>类似于列表推导式或者set、dict,通过<code>(x for x in rang(10))</code>这样的形式返回的就是一个generator,而通过圆括号<code>()</code>进行的推导式就是<code>generator comprehension</code>.<br>总的来说,generator能够非常有效的组织代码,用更少的变量和流程控制,并且使用generator会更好地减少内存或者cpu的负载.所以像我这样的代码里边遍布了各种for循环:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def something():</span><br><span class="line">    result = []</span><br><span class="line">    for ... in ...:</span><br><span class="line">        result.append(x)</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure></p><p>还是抓紧时间好好改一改吧:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def iter_something():</span><br><span class="line">    for ... in ...:</span><br><span class="line">        yield x</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 生成器 </tag>
            
            <tag> 可迭代对象 </tag>
            
            <tag> iterator </tag>
            
            <tag> generator </tag>
            
            <tag> iterable </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python的itertools[读文档]</title>
      <link href="/2017/08/09/python%E7%9A%84itertools/"/>
      <url>/2017/08/09/python%E7%9A%84itertools/</url>
      
        <content type="html"><![CDATA[<p>python的itertools库受到了来自APL, Haskell和SML的灵感，并且用最适合python语言特性的形式重构。它差不多可以说是定义了一套高效、节省内存的方法使用纯python来构建开发者所需要的各种不同迭代器。<br><a id="more"></a></p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>根据itertools中方法的返回类型不同，可以将这些方法分为三类：<br><strong>无穷迭代∞</strong></p><table><thead><tr><th>迭代器</th><th>参数</th><th>返回值</th><th>示例</th></tr></thead><tbody><tr><td>count()</td><td>start,[step]</td><td>start,start+step,start+2*step,…</td><td>count(10) –&gt; 10,11,12,13,14,…</td></tr><tr><td>cycle()</td><td>p</td><td>p0,p1,p2,…,plast,p0,p1,p2….</td><td>cycle([1,2,3,4]) –&gt; 1,2,3,4,1,2,3,4,…</td></tr><tr><td>repeat()</td><td>p,[n]</td><td>p,p,p,…,p 或者重复n次p</td><td>repeat(10,2) –&gt; 10,10</td></tr></tbody></table><p><strong>处理输入迭代器⌨️</strong></p><table><thead><tr><th>迭代器</th><th>参数</th><th>返回值</th><th>示例</th></tr></thead><tbody><tr><td>chain()</td><td>p,q,..</td><td>p0,p1,..,plast,q0,q1,…,qlast,….</td><td>chain(‘abc’,[1,2,3]) –&gt; a b c 1 2 3</td></tr><tr><td>compress()</td><td>data,selectors</td><td>(d[0] if s[0]),(d[1] if s[1])…</td><td>compress(‘abcd’,[0,1,0,0]) –&gt; b</td></tr><tr><td>dropwhile()</td><td>pred,seq</td><td>seq[n],seq[n+1]… while pred(seq[n-1]) == False</td><td>dropwhile(lambda x:x&lt;3,[1,2,4,0,1]) –&gt; 4,0,1</td></tr><tr><td>groupby()</td><td>iterable,[keyfunc]</td><td>根据keyfunc(iterable item)值返回的迭代器</td><td></td></tr><tr><td>ifilter()</td><td>pred,seq</td><td>返回seq中pred(seq[n])为真值的一部分元素</td><td>ifilter(lambda x:x&gt;3,[1,2,3,4,5,6]) –&gt; 4,5,6</td></tr><tr><td>ifilterfalse()</td><td>pred,seq</td><td>返回seq中pred(seq[n])为假的一部分元素</td><td>ifilterfalse(lambda x:x&gt;3,[1,2,3,4,5,6]) –&gt; 1,2,3</td></tr><tr><td>islice()</td><td>seq, [start,] stop [, step]</td><td>返回seq[start:stop:step]的切片</td><td>islice(count(10),1,3) -&gt; 11,12</td></tr><tr><td>imap()</td><td>func, p, q, …</td><td>func(p0, q0), func(p1, q1), …</td><td>imap(lambda x,y:x+y,count(0),count(10)) –&gt; 10,11,12,…</td></tr><tr><td>starmap()</td><td>func, seq</td><td>func(<em>seq[0]), func(</em>seq[1]), …</td><td>starmap(pow, [(2,5), (3,2), (10,3)]) –&gt; 32 9 1000</td></tr><tr><td>tee()</td><td>it, n</td><td>it1, it2, … itn splits one iterator into n</td><td></td></tr><tr><td>takewhile()</td><td>pred,seq</td><td>seq[0], seq[1], until pred fails</td><td>takewhile(lambda x: x&lt;5, [1,4,6,4,1]) –&gt; 1 4</td></tr><tr><td>izip()</td><td>p, q, …</td><td>(p[0], q[0]), (p[1], q[1]), … 返回迭代器的长度和参数中长度最短迭代器相同</td><td>izip(‘ABCD’, ‘xy’) –&gt; Ax By</td></tr><tr><td>izip_longest()</td><td>p, q, …</td><td>(p[0], q[0]), (p[1], q[1]), …</td><td>izip_longest(‘ABCD’, ‘xy’, fillvalue=’-‘) –&gt; Ax By C- D-</td></tr></tbody></table><p><strong>组合生成器🎈</strong> </p><table><thead><tr><th>迭代器</th><th>参数</th><th>返回值</th><th>示例</th></tr></thead><tbody><tr><td>product()</td><td>p, q, … [repeat=1]</td><td>返回输入参数的笛卡尔积</td></tr><tr><td>permutations()</td><td>p[, r]</td><td>返回由长度为r的p中元素的组合，<br>每个元素不会重复出现</td><td>permutations([1,2],2) –&gt;<br> (1, 2), (2, 1)</td></tr><tr><td>combinations()</td><td>p, r</td><td>按照p中元素的顺序来进行排列组合,<br>每个元素不会重复出现</td><td>combinations([2,1],1) –&gt;<br> (2,), (1,)</td></tr><tr><td>combinations_with_replacement()</td><td>p, r</td><td>按照p中元素的顺序来进行排列组合，<br>每个元素可以重复出现</td><td>combinations_with_<br>replacement([1,2],2)<br>–&gt; (1, 1), (1, 2), (2, 2)</td></tr></tbody></table><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>如下的一些方法都是用来创建或者返回迭代器的，其中一些会返回无限长度的迭代器，如果要将他们用在另外的函数或者循环中的时候需要进行切片操作。</p><ul><li><p><code>itertools.chain(*iterables)</code><br>输入参数是一个或者多个迭代器对象，返回的内容是将这些迭代器中的所有元素拼接成为一个大的迭代器，需要注意的是，当作参数输入的若干个迭代器可以是不同的类型(区别于同种类型的序列相加的操作，如两个list相加或者两个string相加).<br><code>itertools.chain(*iterables)</code>类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def chain(*iterables):</span><br><span class="line">    # chain(&apos;ABC&apos;, &apos;DEF&apos;) --&gt; A B C D E F       </span><br><span class="line">    for iterable in iterables:</span><br><span class="line">        for element in iterable:</span><br><span class="line">            yield element</span><br></pre></td></tr></table></figure></li><li><p><code>classmethod chain.from_iterable(iterable)</code><br>将输入参数iterable中的每个可迭代对象中的元素合并成为一个大的迭代器，类似于以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def from_iterable(iterable):</span><br><span class="line">    # chain.from_iterable([&apos;ABC&apos;, &apos;DEF&apos;]) --&gt; A B C D E F</span><br><span class="line">    for item in iterable:</span><br><span class="line">        for element in item:</span><br><span class="line">            yield element</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.combinations(iterable, r)</code> 😢<br>返回一个由r个iterable元素组合而成的迭代器，如果iterable中的元素是经过排序的，那么返回的每个对象也都是经过排序的。iterbale中的每个元素都是按照它在iterable中所在的位置进行处理。<code>itertools.combinations(iterable, r)</code>类似于如下代码过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def combinations(iterable, r):</span><br><span class="line">    # combinations(&apos;ABCD&apos;, 2) --&gt; AB AC AD BC BD CD</span><br><span class="line">    # combinations(range(4), 3) --&gt; 012 013 023 123</span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    if r &gt; n:</span><br><span class="line">        return</span><br><span class="line">    indices = range(r)</span><br><span class="line">    yield tuple(pool[i] for i in indices)</span><br><span class="line">    while True:</span><br><span class="line">        for i in reversed(range(r)):</span><br><span class="line">            if indices[i] != i + n - r:</span><br><span class="line">                break</span><br><span class="line">        else:</span><br><span class="line">            return</span><br><span class="line">        indices[i] += 1</span><br><span class="line">        for j in range(i+1, r):</span><br><span class="line">            indices[j] = indices[j-1] + 1</span><br><span class="line">        yield tuple(pool[i] for i in indices)</span><br></pre></td></tr></table></figure></li></ul><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def combinations(iterable, r):</span><br><span class="line">    pool = tuple(iterable)</span><br><span class="line">    n = len(pool)</span><br><span class="line">    for indices in permutations(range(n), r):</span><br><span class="line">        if sorted(indices) == list(indices):</span><br><span class="line">            yield tuple(pool[i] for i in indices)</span><br></pre></td></tr></table></figure></p><ul><li><p><code>itertools.compress(data, selectors)</code><br>输入参数data和selectors均为迭代器对象，如果selector中某一元素返回真值，则返回对应位置data中的元素。类似于代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def compress(data,selectors):</span><br><span class="line">    # compress(&apos;ABCDEF&apos;, [1,0,1,0,1,1]) --&gt; A C E F</span><br><span class="line">    return (d for d,s in izip(data,selectors) if s)</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.count(start=0, step=1)</code><br>用于返回一个数值连续的迭代器，常作为<code>imap()</code>或者<code>izip()</code>的参数。等价于代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def count(start=0,step=1):</span><br><span class="line">    # count(10) --&gt; 10 11 12 13 14 ...</span><br><span class="line">    # count(2.5, 0.5) -&gt; 2.5 3.0 3.5 ...</span><br><span class="line">    n = start</span><br><span class="line">    while True:</span><br><span class="line">        yield n</span><br><span class="line">        n += step</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.cycle(iterable)</code><br>逐个返回iterable中的元素，并将每个元素备份，在iterable中元素耗尽的时候，重复的返回iterable对象的备份。等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def cycle(iterable):</span><br><span class="line">    container = []</span><br><span class="line">    for item in iterable:</span><br><span class="line">        yield item</span><br><span class="line">        container.append(item)</span><br><span class="line">    while container:</span><br><span class="line">        for element in container:</span><br><span class="line">            yield element</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.dropwhile(predicate, iterable)</code><br>如果predicate返回值为True,就将iterable中的元素抛弃，直到predicate返回False,返回iterable中剩下的元素。类似于代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def dropwhile(pred,iteration):</span><br><span class="line">    iterable = iter(iteration)</span><br><span class="line">    for x in iterable:</span><br><span class="line">        if not pred(x):</span><br><span class="line">            yield x</span><br><span class="line">            break</span><br><span class="line">    for x in iterable:</span><br><span class="line">        yield x</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.ifilter(predicate, iterable)</code><br>如果iterable中的元素element，在执行predicate(element)返回True,则将这个element返回。如果predicate为None,则返回iterable中的真值。类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def ifilter(pred,iterable):</span><br><span class="line">    if pred is None:</span><br><span class="line">        pred = bool</span><br><span class="line">    for item in iterable:</span><br><span class="line">        if pred(item):</span><br><span class="line">            yield item</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.ifilterfalse(predicate, iterable)</code><br>和<code>itertools.ifilter</code>相反，类似于代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def ifileterfalse(pred,iterable):</span><br><span class="line">    if pred is None:</span><br><span class="line">        pred = bool</span><br><span class="line">    for item in iterable:</span><br><span class="line">        if not pred(item):</span><br><span class="line">            yield item</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.imap(function, *iterables)</code><br>将来自于iterables中多个迭代器中的每次各选取一个元素作为function的参数，返回function执行后的结果.如果function为空，缺省值为tuple。区别于map，imap中的迭代器可以是无穷序列,并且imap中当最短的迭代器中没有元素的时候会结束，而不是使用None来代替。执行代码类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def imap(func,*iterables):</span><br><span class="line">    its = map(iter,iterables)</span><br><span class="line">    if func is None:</span><br><span class="line">        func = tuple</span><br><span class="line">    while True:</span><br><span class="line">        args = [next(it) for it in its]</span><br><span class="line">        yield func(*args)</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.islice(iterable, stop) itertools.islice(iterable, start, stop[, step])</code><br>与普通的slice方法不同，islice的参数start,stop或者step不能为负值，类似于代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def islice(iterable, *args):</span><br><span class="line">    # islice(&apos;ABCDEFG&apos;, 2) --&gt; A B</span><br><span class="line">    # islice(&apos;ABCDEFG&apos;, 2, 4) --&gt; C D</span><br><span class="line">    # islice(&apos;ABCDEFG&apos;, 2, None) --&gt; C D E F G</span><br><span class="line">    # islice(&apos;ABCDEFG&apos;, 0, None, 2) --&gt; A C E G</span><br><span class="line">    s = slice(*args)</span><br><span class="line">    it = iter(xrange(s.start or 0, s.stop or sys.maxint, s.step or 1))</span><br><span class="line">    nexti = next(it)</span><br><span class="line">    for i, element in enumerate(iterable):</span><br><span class="line">        if i == nexti:</span><br><span class="line">            yield element</span><br><span class="line">            nexti = next(it)</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.izip(*iterables)</code><br>与zip不同，izip的返回值是一个迭代器而不是list对象。运行代码类似于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def izip(*iterables):</span><br><span class="line">    iters = map(iter,iterables)</span><br><span class="line">    while iters:</span><br><span class="line">        yield tuple(map(next,iters))</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.repeat(object[, times])</code><br>生成一个重复出现object times次的迭代器，类似代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def repeat(object,times):</span><br><span class="line">    if times is None:</span><br><span class="line">        while True:</span><br><span class="line">            yield object</span><br><span class="line">    else:</span><br><span class="line">        for x in rang(times):</span><br><span class="line">            yield object</span><br></pre></td></tr></table></figure></li><li><p><code>itertools.starmap(function, iterable)</code><br>实现类似代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def starmap(func,iterable):</span><br><span class="line">    for item in iterable:</span><br><span class="line">        yield func(*item)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 标准库 </tag>
            
            <tag> 文档 </tag>
            
            <tag> itertools </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python2.7.13内建函数[读文档]</title>
      <link href="/2017/08/04/python2.7.13%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
      <url>/2017/08/04/python2.7.13%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>最近准备系统的看一下python文档，并将看到的东西记一下，所以<strong>[读文档]</strong>可能将会成为一个系列。<br>目前基本看完了内建函数部分，后续会继续更新(pass标记表示还未更新内容)。<br><a id="more"></a></p><ol><li>abs(x)<br> 返回x的绝对值,x可以是一个int型、long型或者是float型.</li><li><p>all(iterable)<br> 输入参数为一个可迭代对象,如果iterable中每一个元素都为True或者iterable是一个空的对象返回True,否则返回False. (New in version 2.5.)</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> element:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></li><li><p>any(iterable)<br> 如果参数iterable中有任一个值为True就返回True,否则返回False,如果iterable为空,返回False. (New in version 2.5.)</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">any</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> element:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></li><li><p>basestring() 🏭<br> basestring是str和unicode的超类,它不能被实例化或者被调用,但它可以用来检测一个对象是否是str或者unicode的实例,<code>isinstance(obj,basestring)</code>等价于<code>isinstance(obj, (str, unicode))</code>.</p></li><li><p>bin(x) 🏭<br> 参数x是一个int型数字,结果返回x的二进制字符串.</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: bin(<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">'0b1'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: bin(<span class="number">10</span>)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="string">'0b1010'</span></span><br></pre></td></tr></table></figure></li><li><p>class bool([x]) 🏭<br> bool型是int的字类,并且它不能再派生其他的任何子类,它有且仅有两个实例:True,False.<br> x参数在经过真值判断之后返回True或者False.</p></li><li>class bytearray([source[, encoding[, errors]]]) 🏭<br> pass</li><li>callable(object)<br> 如果object是一个可调用对象返回True,否则返回False(如果返回结果为True,不代表object()就一定能够成功,但是如果返回值是False,object()一定不会成功).这里要注意的是：类都是可调用对象(调用一个类,会返回这个类的一个实例),但是如果想要让类实例也是可调用对象则需要实现这个类<strong>call</strong>()方法.</li><li><p>chr(i)<br> 参数i必须是一个0-255范围内的整型数字,返回一个字符串,该字符串的ASCII码恰好等于i.</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: chr(<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">21</span>]: <span class="string">'\x00'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: chr(<span class="number">97</span>)</span><br><span class="line">Out[<span class="number">22</span>]: <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: chr(<span class="number">98</span>)</span><br><span class="line">Out[<span class="number">23</span>]: <span class="string">'b'</span></span><br></pre></td></tr></table></figure></li><li><p>classmethod(function) (装饰器) 🏅️<br>classmethod接收一个类作为默认的第一个参数,就像一个实例方法默认第一个参数是实例本身.classmethod是一个装饰器.    类方法(class method)可以直接通过Date.gen_date(str)调用,或者通过类实例调用Date().gen_date(str).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Date(object):</span><br><span class="line">    def __init__(self,month,day,year):</span><br><span class="line">        # 实例方法,self就是实例本身</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line">        self.year = year</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def gen_date(cls,str):</span><br><span class="line">        # 类方法,cls就是Date类</span><br><span class="line">        day, month, year = map(int, date_as_string.split(&apos;-&apos;))</span><br><span class="line">        date1 = cls(day, month, year)</span><br><span class="line">        return date1</span><br></pre></td></tr></table></figure></li><li><p>cmp(x, y)<br>比较x,y两个对象,根据比较的结果返回对应的值(如果<code>x&lt;y</code>返回负值,如果<code>x&gt;y</code>返回正值,如果<code>x==y</code>返回0)</p></li><li>compile(source, filename, mode[, flags[, dont_inherit]])<br>pass</li><li>class complex([real[, imag]])<br>pass</li><li>delattr(object, name)<br>参数是一个对象和一个字符串,delattr的作用就是删除对象object名字叫做name的属性.<code>delattr(x, foo)</code>等价于<code>del x.foo</code>.delattr是内建函数setattr的逆操作.</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class dict(**kwarg)</span><br><span class="line">   class dict(mapping, **kwarg)</span><br><span class="line">   class dict(iterable, **kwarg) 🏭</span><br></pre></td></tr></table></figure><p>pass</p></li><li>dir([object])<br>pass</li><li>divmod(a, b)<br>参数是两个数字,可以是int,long甚至float类型,返回值是两个数相除的商和余数.</li><li><p>enumerate(sequence, start=0)<br>参数sequence必须是一个序列、迭代器或者其他任何可迭代对象,返回值可以当作一个生成器对象,可以通过如下代码理解enumerate方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def enumerate(sequence, start=0):</span><br><span class="line">    n = start</span><br><span class="line">    for elem in sequence:</span><br><span class="line">        yield n, elem</span><br><span class="line">        n += 1</span><br></pre></td></tr></table></figure></li><li><p>eval(expression[, globals[, locals]])<br>pass</p></li><li>execfile(filename[, globals[, locals]])<br>pass</li><li>file(name[, mode[, buffering]])<br>pass</li><li><p>filter(function, iterable) 🏅️<br>参数function是一个返回值为bool型的函数,iterable是一个可迭代对象.如果iterable是一个string或者tuple,最终返回值也会保留原来的类型,其他的类型最终返回值是list类型.<br>可以这样理解filter:<br>filter(function, iterable)等价于<br>如果function不为None:[item for item in iterable if function(item)]<br>如果function为None:[item for item in iterable if item]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [7]: a = (1,2,3,4,5,6)</span><br><span class="line">In [8]: filter(lambda x:x&gt;3,a)</span><br><span class="line">Out[8]: (4, 5, 6)</span><br><span class="line"></span><br><span class="line">In [11]: filter(lambda x:x==&apos;l&apos;,a)</span><br><span class="line">Out[11]: &apos;lll&apos;</span><br><span class="line">In [12]: a = [1,2,3,4,5,6]</span><br><span class="line"></span><br><span class="line">In [13]: filter(lambda x:x&gt;3,a)</span><br><span class="line">Out[13]: [4, 5, 6]</span><br><span class="line">In [14]: a = [[],[1],[2],[]]</span><br><span class="line"></span><br><span class="line">In [15]: filter(None,a)</span><br><span class="line">Out[15]: [[1], [2]]</span><br></pre></td></tr></table></figure></li><li><p>class float([x]) 🏭<br>参数x可以是一个数字或者字符串,返回对应的float型数字.</p></li><li>format(value[, format_spec])<br>pass</li><li>class frozenset([iterable]) 🏭<br>参数是一个可迭代对象,返回一个frozenset对象.</li><li>getattr(object, name[, default])<br>参数object为一个对象,name为一个string,结果返回object对象名为name的属性值,<code>getattr(x,&#39;foo&#39;)</code>等价于<code>x.foo</code>.</li><li>globals()<br>pass</li><li>hasattr(object, name)<br>参数object为一个对象,name是一个string,如果object对象有名为name的属性返回True,否则返回False.它实际上是通过调用getattr(object,name)看是否会造成异常来判断的.</li><li><p>hash(object)<br>返回对象object的hash值,object对象必须是一个可哈希的类型,否则会报错.并且值相等的两个数字型对象的哈希值是一样的,不管这两个数字是int或者float.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [1]: hash(1)</span><br><span class="line">Out[1]: 1</span><br><span class="line"></span><br><span class="line">In [3]: a = [1]</span><br><span class="line">In [4]: hash(a)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-4-fe724719d9a1&gt; in &lt;module&gt;()</span><br><span class="line">----&gt; 1 hash(a)</span><br><span class="line">TypeError: unhashable type: &apos;list&apos;</span><br><span class="line"></span><br><span class="line">In [2]: hash(1) == hash(1.0000)</span><br><span class="line">Out[2]: True</span><br></pre></td></tr></table></figure></li><li><p>help([object])<br>调用python内建的帮助系统,例如<code>help(int) / help(str)</code>.</p></li><li>hex(x) 🏭<br>将一个整形数字变为一个以’0x’开头的小写16进制字符串.<br>x可以是一个int或者long类型对象,如果不是的话这个对象需要实现<code>__index__()</code>方法,并返回一个整形数字.</li><li><p>id(object)<br>返回一个对象的唯一标识,在它的生命周期内.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [9]: a</span><br><span class="line">Out[9]: [1]</span><br><span class="line"></span><br><span class="line">In [10]: id(a)</span><br><span class="line">Out[10]: 4411575760</span><br></pre></td></tr></table></figure></li><li><p>input([prompt])<br>pass</p></li><li>class int(x=0)<br>class int(x, base=10) 🏭<br>返回一个int对象,x可以是一个数字或者string.如果不指定x,返回0.</li><li>isinstance(object, classinfo)<br>如果对象object是类classinfo的一个实例或者是由classinfo派生类的实例，返回True否则返回False.需要注意的是classinfo可以是一个由多个类构成的元组，如果object是这个元组中某一个类的实例或者这些类中派生类的实例返回True,否则返回False.</li><li>issubclass(class, classinfo)<br>如果类class是classinfo的派生类，返回True,否则返回False.这里需要注意的是一个类可以被当作是它自己的子类。同样地，classinfo也可以是一个由多个类构成的元组，如果clas是这个元组中某个类的子类也会返回True.</li><li><p>iter(o[, sentinel]) 🏅️<br>返回值是一个迭代器对象。<br>第二参数sentinel是否存在对第一个o有比较大的影响。如果第二个参数不存在，第一个参数o必须是一个集合对象(实现了<code>__iter__()</code>方法的对象)或者实现了<code>__getitem__()方法的对象，并且取值参数必须是从0开始的整型</code>,否则在使用iter函数的时候会有TypeError的异常。<br>如果第二个参数存在，第一个参数o则必须是一个可调用对象，o这个可调用对象在被调用的时候会返回一个可迭代对象，每次对o的调用相当于执行o返回迭代器的<code>next()</code>方法，如果o的返回值和第二个参数值相同则会引发StopIteration异常，否则返回正常的值。举个例子🌰，逐行读取mydata.txt，当读到空白行的时候终止操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;mydata.txt&apos;) as fp:</span><br><span class="line">for line in iter(fp.readline, &apos;&apos;):</span><br><span class="line">    process_line(line)</span><br></pre></td></tr></table></figure></li><li><p>len(s)<br>返回一个对象的长度。参数可以是一个序列(string,bytes,tuple,list或者range)或者是一个集合(dict,set或者frozenset).</p></li><li>class list([iterable]) 🏭<br>返回一个list对象，参数是一个可迭代对象，最终返回的list对象中元素顺序和迭代器中元素的顺序保持一致。</li><li>locals()<br>pass</li><li>class long(x=0) 🏭<br>class long(x, base=10)<br>返回值是一个长整型数字，参数可以是一个字符串或者数字。</li><li><p>map(function, iterable, …) 🏅️<br>将参数可迭代对象iterable中的每个元素都传入function函数中，返回值是每个元素经过function函数调用之后的返回值构成的列表。<br>如果有多个可迭代对象传入，function函数也必须能够同时接受对应数量的参数。如果其中一个可迭代对象长度比较短，则会向function函数传入None作为替代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [26]: def map_func(a,b):</span><br><span class="line">    ...:     return a+b</span><br><span class="line">    ...:</span><br><span class="line">In [27]: a = [0,1,2,3,4]</span><br><span class="line">In [28]: b = [10,11,12,13,14]</span><br><span class="line">In [29]: map(map_func,a,b)</span><br><span class="line">Out[29]: [10, 12, 14, 16, 18]</span><br><span class="line"></span><br><span class="line">In [32]: a = [0,1,2,3,4,5,6,7]</span><br><span class="line">In [33]: b = [10,11,12,13,14]</span><br><span class="line">In [35]: def map_func(a,b):</span><br><span class="line">    ...:     return b,a</span><br><span class="line">    ...:</span><br><span class="line">In [36]: map(map_func,a,b)</span><br><span class="line">Out[36]: [(10, 0), (11, 1), (12, 2), (13, 3), (14, 4), (None, 5), (None, 6), (None, 7)]</span><br></pre></td></tr></table></figure></li><li><p>max(iterable[, key])<br>max(arg1, arg2, *args[, key])<br>返回一个可迭代对象中最大的元素或者多个对象的最大一个，这里的key是一个接受一个参数的排序函数，类似于list.sort()中的排序函数。</p></li><li>memoryview(obj) 🏭<br>返回一个memoryview对象。</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min(iterable[, key])</span><br><span class="line">   min(arg1, arg2, *args[, key])</span><br></pre></td></tr></table></figure><p>返回一个可迭代对象中的最小值或者几个对象中的最小值。于max()使用方法类似。</p></li><li>next(iterator[, default]) 🏅️<br>取出参数迭代器iterator的下一个值，等价于<code>iterator.next()</code>。如果给定了default，在迭代器中没有剩余元素的时候返回default的值，否则引发StopIteration异常。</li><li>class object<br>返回一个普通的新式类对象。object是所有新式类的基类。</li><li>oct(x)<br>将一个整型数字转为八进制字符串。</li><li>open(name[, mode[, buffering]]) 🏅️<br>打开一个文件，返回一个文件对象。如果文件不能被打开，会引发IOError异常。通常情况下在打开文件的时候都使用open()而避免直接使用file的构造函数。</li><li>ord(c)<br>给定一个长度为1的string，返回一个整型。这个方法是chr()的逆操作。</li><li>pow(x, y[, z])<br>返回值x的y次方。如果给定了z，就相当于是pow(x,y)%z。</li><li><code>print(*objects, sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout)</code><br>pass</li><li>class property([fget[, fset[, fdel[, doc]]]])<br>pass</li><li>range(stop)<br>range(start, stop[, step])<br>range能够十分方便地返回一个等差数列list,其中参数start缺省值为0，step缺省值是1.如果step是正值，返回的list就是一个递增数列，如果step为负值，返回的list就是一个递减数列。</li><li><p>raw_input([prompt])<br>如果参数prompt不为空，它会被写入标准输出并等待用户输入，并将用户输入值转为string并当作返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: s = raw_input(&apos;input something:&apos;)</span><br><span class="line">input something:ahhhhhhhhh</span><br><span class="line">In [2]: s</span><br><span class="line">Out[2]: &apos;ahhhhhhhhh&apos;</span><br></pre></td></tr></table></figure></li><li><p>reduce(function, iterable[, initializer]) 🏅️<br>关于reduce的解释直接使用文档中的代码好像更能解释清楚：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def reduce(function, iterable, initializer=None):</span><br><span class="line">    it = iter(iterable)</span><br><span class="line">    if initializer is None:</span><br><span class="line">        try:</span><br><span class="line">            initializer = next(it)</span><br><span class="line">        except StopIteration:</span><br><span class="line">            raise TypeError(&apos;reduce() of empty sequence with no initial value&apos;)</span><br><span class="line">    accum_value = initializer</span><br><span class="line">    for x in it:</span><br><span class="line">        accum_value = function(accum_value, x)</span><br><span class="line">    return accum_value</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [1]: a = [1]</span><br><span class="line">In [2]: reduce(lambda x,y:x+y,a)</span><br><span class="line">Out[2]: 1</span><br><span class="line">In [3]: reduce(lambda x,y:x+y,a,1)</span><br><span class="line">Out[3]: 2</span><br><span class="line"></span><br><span class="line">In [4]: a = [1,2]</span><br><span class="line">In [5]: reduce(lambda x,y:x+y,a)</span><br><span class="line">Out[5]: 3</span><br></pre></td></tr></table></figure></li><li><p>reload(module)<br>pass</p></li><li><p>repr(object)<br>返回一个对象的字符串形式。通常这个字符串可以用过eval()返回一个值等于object的对象。另外，通过<code>__repr__()</code>可以自定义<code>repr()</code>的返回内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [4]: a = [1,2]</span><br><span class="line">In [8]: b = repr(a)</span><br><span class="line"></span><br><span class="line">In [9]: eval(b) == a</span><br><span class="line">Out[9]: True</span><br><span class="line"></span><br><span class="line">In [10]: eval(b) is a</span><br><span class="line">Out[10]: False</span><br></pre></td></tr></table></figure></li><li><p>reversed(seq)<br>返回一个逆序的迭代器。参数seq必须是一个实现了<code>__reversed__()</code>方法的对象或者实现了<code>__len__()</code>方法并且<code>__getitem__()</code>方法的参数必须是从0开始的整型.</p></li><li><p>round(number[, ndigits])<br>参数number是一个浮点型数字，ndigits缺省值是0，round的作用就是一个四舍五入的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [18]: a = 1.554332</span><br><span class="line"></span><br><span class="line">In [19]: round(a)</span><br><span class="line">Out[19]: 2.0</span><br><span class="line"></span><br><span class="line">In [20]: round(a,1)</span><br><span class="line">Out[20]: 1.6</span><br><span class="line"></span><br><span class="line">In [21]: round(a,2)</span><br><span class="line">Out[21]: 1.55</span><br><span class="line"></span><br><span class="line">In [22]: round(a,3)</span><br><span class="line">Out[22]: 1.554</span><br></pre></td></tr></table></figure></li><li><p>class set([iterable]) 🏭<br>返回一个set对象，参数iterable是一个可迭代对象。</p></li><li>setattr(object, name, value)<br>这个方法和<code>getattr()</code>是一对，参数object是一个对象，name是一个字符串，value可以是任意值。name可以是一个新的属性名或者是一个已经存在的属性名。<code>setattr(x,&#39;name&#39;,value)</code>等价于<code>x.name = value</code></li><li>class slice(stop)<br>class slice(start, stop[, step])</li><li>sorted(iterable[, cmp[, key[, reverse]]]) 🏅️<br>pass</li><li><p>staticmethod(function)<br>staticmethod是一个装饰器，用于装起类中的static method。它不需要一个隐式的第一个参数。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">   @staticmethod</span><br><span class="line">   def f(arg1, arg2, ...):</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure><p>在调用的时候可以直接使用<code>C.f(*args)</code>或者<code>C().f(*args)</code>.</p></li><li>class str(object=’’) 🏭<br>返回一个string类型的对象。它和repr(object)有所不同,pass</li><li>sum(iterable[, start])<br>返回可迭代对象iterable中所有元素的和再加上start之后的结果。start缺省值是0.并且默认要求iterable中的元素一般都为数值型的，start不能是字符串类型。</li><li>super(type[, object-or-type])<br>pass</li><li>tuple([iterable]) 🏭<br>pass</li><li>class type(object)<br>class type(name, bases, dict)<br>pass</li><li>unichr(i)<br>pass</li><li>unicode(object=’’)<br>unicode(object[, encoding[, errors]])<br>pass</li><li>vars([object])<br>pass</li><li>xrange(stop)<br>xrange(start, stop[, step])<br>pass</li><li>zip([iterable, …])<br>pass</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 标准库 </tag>
            
            <tag> 文档 </tag>
            
            <tag> 内建函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中@classmethod和@staticmethod的理解</title>
      <link href="/2017/08/03/%E5%85%B3%E4%BA%8Epython%E7%9A%84@classmethod%E5%92%8C@staticmethod%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2017/08/03/%E5%85%B3%E4%BA%8Epython%E7%9A%84@classmethod%E5%92%8C@staticmethod%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>一直对python中@classmethod和@staticmethod的用法和区别不是很理解,一顿google之后发现还是stackoverflow真的是程序员的好朋友.在这个问题<a href="https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner" target="_blank" rel="noopener">Meaning of @classmethod and @staticmethod for beginner?</a>中,几个大神的回答还是很好的.</p><a id="more"></a><h1 id="Rostyslav-Dzinko这样说"><a href="#Rostyslav-Dzinko这样说" class="headerlink" title="@Rostyslav Dzinko这样说"></a><a href="https://stackoverflow.com/users/789649/rostyslav-dzinko" target="_blank" rel="noopener">@Rostyslav Dzinko</a>这样说</h1><p>虽然classmethod和staticmethod十分相似,但他们之间确实存在一些细微的差别:classmethod必须有一个类对象作为方法的第一个参数,然而staticmethod却可以不需要参数.<br>下面👇,举个例子🌰:</p><h2 id="样板代码"><a href="#样板代码" class="headerlink" title="样板代码"></a>样板代码</h2><p>假设我们需要一个类来处理和日期相关的信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Date(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, day=0, month=0, year=0):</span><br><span class="line">        self.day = day</span><br><span class="line">        self.month = month</span><br><span class="line">        self.year = year</span><br></pre></td></tr></table></figure></p><p>显然,这个类能够存储一些日期相关的信息,通过<strong>init</strong>方法,我们传入day,month和year能够实例化一个Date对象,其中<strong>init</strong>方法的第一个参数self就代表我们新建的Date实例.</p><h2 id="Class-Method"><a href="#Class-Method" class="headerlink" title="Class Method"></a>Class Method</h2><p>通过@classmethod我们可以比较优雅的完成一些任务.如果仅仅通过<strong>init</strong>方法来完成Date类的实例化,就必须这样实现:<code>x = Date(day,month,year)</code>.如果现在想要将一个日期的字符串形式(‘dd-mm-yy’)转为Date对象,我们需要完成这两个步骤:</p><ol><li>将字符串转为day,month,year三个整型对象或者一个包含三个值的元组;</li><li>通过<strong>init</strong>方法完成Date对象的实例化.<br>上边的两步实现过程就像这样:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">day, month, year = map(int, string_date.split(&apos;-&apos;))</span><br><span class="line">date1 = Date(day, month, year)</span><br></pre></td></tr></table></figure></li></ol><p>在其他编程语言中,以c++为例,它可以重构自己的构造函数来接受某个日期的字符串形式最终返回一个Date实例.但是python没有这样的特性,于是classmethod就在这里派上了用场:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@classmethod</span><br><span class="line">    def from_string(cls, date_as_string):</span><br><span class="line">        day, month, year = map(int, date_as_string.split(&apos;-&apos;))</span><br><span class="line">        date1 = cls(day, month, year)</span><br><span class="line">        return date1</span><br><span class="line">date2 = Date.from_string(&apos;11-09-2012&apos;)</span><br></pre></td></tr></table></figure></p><p>上边利用classmethod来完成将字符串转为Date实例主要有这些优势:</p><ol><li>将字符串转化的过程放在类中,并且能够重用;</li><li>封装的较好,符合面向对象思想;</li><li>classmethod中的cls代表Date,它不是类的一个实例,就是类对象本身,如果我们派生了其他的子类,它们也都能继承from_string方法.</li></ol><h2 id="Static-Method"><a href="#Static-Method" class="headerlink" title="Static Method"></a>Static Method</h2><p>说完了classmethod,接着唠一唠staticmethod.它其实和classmethod十分相似,但是它不需要像类方法或者普通的实例方法一样需要必须的参数(cls或者self).<br>再举个例子🌰:<br>通过classmethod我们完成了将一个字符串转为Date实例的过程,现在给我们一个字符串,在使用Date.from_string(‘str’)生成实例之前,判断这个str是否满足要求.<br>很显然,这个方法和类Date有密切的联系,但仅仅判断一个字符串是否满足转换的要求,并不需要实例化一个Date对象,这时候staticmethod就可以派上用场:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@staticmethod</span><br><span class="line">    def is_date_valid(date_as_string):</span><br><span class="line">        day, month, year = map(int, date_as_string.split(&apos;-&apos;))</span><br><span class="line">        return day &lt;= 31 and month &lt;= 12 and year &lt;= 3999</span><br><span class="line"></span><br><span class="line"># usage:</span><br><span class="line">is_date = Date.is_date_valid(&apos;11-09-2012&apos;)</span><br></pre></td></tr></table></figure></p><p>也就是说,staticmethod可以像一个普通的方法被调用,它与这个类有明确的相关性,但是不需要访问这个类内部的属性或者方法.</p><h1 id="Yaw-Boakye补充说"><a href="#Yaw-Boakye补充说" class="headerlink" title="@Yaw Boakye补充说"></a><a href="https://stackoverflow.com/users/1248059/yaw-boakye" target="_blank" rel="noopener">@Yaw Boakye</a>补充说</h1><p>Rostyslav Dzinko说的非常好,不过他(Yaw Boakye)从另外一个方面对classmethod和staticmethod的区别做了补充:<br>在上边的例子中,使用@classmethod from_string作为一个生成Date实例的工厂,然而通过@staticmethod也可以完成类似的操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Date:</span><br><span class="line">def __init__(self, month, day, year):</span><br><span class="line">    self.month = month</span><br><span class="line">    self.day   = day</span><br><span class="line">    self.year  = year</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  def display(self):</span><br><span class="line">    return &quot;&#123;0&#125;-&#123;1&#125;-&#123;2&#125;&quot;.format(self.month, self.day, self.year)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @staticmethod</span><br><span class="line">  def millenium(month, day):</span><br><span class="line">    return Date(month, day, 2000)</span><br><span class="line"></span><br><span class="line">new_year = Date(1, 1, 2013)               # Creates a new Date object</span><br><span class="line">millenium_new_year = Date.millenium(1, 1) # also creates a Date object. </span><br><span class="line"></span><br><span class="line"># Proof:</span><br><span class="line">new_year.display()           # &quot;1-1-2013&quot;</span><br><span class="line">millenium_new_year.display() # &quot;1-1-2000&quot;</span><br><span class="line"></span><br><span class="line">isinstance(new_year, Date) # True</span><br><span class="line">isinstance(millenium_new_year, Date) # True</span><br></pre></td></tr></table></figure></p><p>通过@staticmethod millenium我们现在也可以生成类似于工厂函数@classmethod from_string的功能,生成Date实例.但是这样的实现却有点硬编码的嫌疑,因为@staticmethod millenium的最终返回结果是通过<code>return Date(month, day, 2000)</code>这句代码实现的,也就是说它明确了返回对象就是就是一个Date的实例.<br>下面我们派生一个Date的子类DateTime:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class DateTime(Date):</span><br><span class="line">  def display(self):</span><br><span class="line">      return &quot;&#123;0&#125;-&#123;1&#125;-&#123;2&#125; - 00:00:00PM&quot;.format(self.month, self.day, self.year)</span><br><span class="line"></span><br><span class="line">datetime1 = DateTime(10, 10, 1990)</span><br><span class="line">datetime2 = DateTime.millenium(10, 10)</span><br><span class="line"></span><br><span class="line">datetime1.display() # returns &quot;10-10-1990 - 00:00:00PM&quot;</span><br><span class="line">datetime2.display() # returns &quot;10-10-2000&quot;</span><br></pre></td></tr></table></figure></p><p>我们可以看到<code>datetime1.display()</code>的返回值<code>&quot;10-10-1990 - 00:00:00PM&quot;</code>而<code>datetime2.display()</code>的返回值是<code>returns &quot;10-10-2000&quot;</code>,这是怎么回事？原因在于datetime1和datetime2实例创建的方法是不同的:</p><ol><li>datetime1通过DateTime的<strong>init</strong>方法生成 <code>isinstance(datetime1, DateTime) # True</code></li><li>datetime2通过DateTime.millenium方法生成    <code>isinstance(datetime2, DateTime) # False</code></li></ol><p>这里就可以看到@staticmethod和@classmethod的一些不同,将millenium使用@classmethod重写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@classmethod</span><br><span class="line">def millenium(cls, month, day):</span><br><span class="line">    return cls(month, day, 2000)</span><br></pre></td></tr></table></figure></p><p>这里的cls替代了之前的Date,它可以是任何一个派生出来的子类,millenium返回的实例当然也是对应的cls的实例.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">datetime1 = DateTime(10, 10, 1990)</span><br><span class="line">datetime2 = DateTime.millenium(10, 10)</span><br><span class="line"></span><br><span class="line">isinstance(datetime1, DateTime) # True</span><br><span class="line">isinstance(datetime2, DateTime) # True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">datetime1.display() # &quot;10-10-1990 - 00:00:00PM&quot;</span><br><span class="line">datetime2.display() # &quot;10-10-2000 - 00:00:00PM&quot;</span><br></pre></td></tr></table></figure></p><h2 id="小小的总结一下"><a href="#小小的总结一下" class="headerlink" title="小小的总结一下"></a>小小的总结一下</h2><p>通过这两个很精彩的解释,现在对@classmethod和@staticmethod有了进一步的理解:</p><ol><li>@classmethod,由于其强制要求有cls参数存在,可以更多的用于当作一个类实例工厂🏭,或者可以作为一个可以用于派生类中的构造函数;</li><li>@staticmethod,如果一个方法不需要使用类内部的属性和方法,但确实和类有明确的相关性,它就可以使用@staticmethod来修饰.</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> oop </tag>
            
            <tag> classmethod </tag>
            
            <tag> staticmethod </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mongodb最近频繁看的文档</title>
      <link href="/2017/07/25/mongodb%E6%9C%80%E8%BF%91%E9%A2%91%E7%B9%81%E9%9C%80%E8%A6%81%E7%9C%8B%E7%9A%84%E6%96%87%E6%A1%A3/"/>
      <url>/2017/07/25/mongodb%E6%9C%80%E8%BF%91%E9%A2%91%E7%B9%81%E9%9C%80%E8%A6%81%E7%9C%8B%E7%9A%84%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<p>最近在处理爬到的直播网站数据，由于将自己需要的数据都存在了一个collection里边，在提供api的时候需要各种操作数据，经常用到mongodb的aggreation，所以这两个文档就经常需要打开，这里也做个记录:</p><ul><li><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/" target="_blank" rel="noopener">管道操作符合管道表达式</a></li><li><a href="https://docs.mongodb.com/manual/core/views/" target="_blank" rel="noopener">mongodb3.4 read-only view</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aggregation </tag>
            
            <tag> read-only View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>celery和fabric的使用</title>
      <link href="/2017/07/19/celery%E5%92%8Cfabric%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/07/19/celery%E5%92%8Cfabric%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>很早就听说<a href="http://www.celeryproject.org/" target="_blank" rel="noopener">celery</a>和<a href="http://www.fabfile.org/" target="_blank" rel="noopener">fabric</a>这两个神器,最近同时在做两个自己的小项目，更新比较频繁，一遍一遍手动部署太过僵硬，所以才真正用到了这俩好东西。<br><a id="more"></a></p><h1 id="celery"><a href="#celery" class="headerlink" title="celery"></a>celery</h1><p>在用到celery之前，如果有定时任务这样的需求，我一般都是直接写crontab，但是如果单个任务时间消耗较长的话，使用celery就可以让长时间消耗的任务异步执行，避免程序主线程的阻塞。另外一点，celery结合<a href="http://flower.readthedocs.io/en/latest/" target="_blank" rel="noopener">flower</a>这个celery监控工具，能够让你看到自己的任务执行状况。</p><p>celery作为一个分布式任务调度模块，它拥有独立的职程（Worker）进程持续监视队列中是否有需要处理的新任务，是否有要处理的任务则取决于中间人（Broker）在客户端和职程间斡旋。Broker从客户端向队列添加消息，之后Broker把消息派送给Worker。<br>在真正使用的时候，也不会有多少难度。</p><ol><li><p>安装celery</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install celery</span><br></pre></td></tr></table></figure></li><li><p>选择一个中间人，我直接用redis，比较方便</p></li><li><p>新建celery app，douyu_app.py文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from celery import Celery</span><br><span class="line">import celery_douyu_config# celery配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Celery(&apos;douyuapp&apos;, include=[&apos;task_douyu&apos;])# task_douyu为celery任务</span><br><span class="line">app.config_from_object(&apos;celery_douyu_config&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.start()</span><br></pre></td></tr></table></figure></li><li><p>新建任务task_douyu.py文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from douyu_app import app</span><br><span class="line">from collector.danmu.CDouyu import Douyu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def SAVE_DOUYU_DATA():</span><br><span class="line">    douyu = Douyu()</span><br><span class="line">    douyu.getRoomInfos()</span><br></pre></td></tr></table></figure></li><li><p>celery配置celery_douyu_config.py文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from celery.schedules import crontab</span><br><span class="line"></span><br><span class="line">BROKER_URL = &apos;redis://127.0.0.1:6379/2&apos;# 任务发布队列</span><br><span class="line">CELERY_RESULT_BACKEND = &apos;redis://127.0.0.1:6379/3&apos;# 任务执行结果存储</span><br><span class="line"></span><br><span class="line">CELERY_TIMEZONE = &apos;Asia/Shanghai&apos; # 时区选择</span><br><span class="line"></span><br><span class="line">CELERYBEAT_SCHEDULE = &#123;</span><br><span class="line">    &apos;SAVE_DOUYU_ROOMINFO&apos;: &#123; # 任务名称</span><br><span class="line">        &apos;task&apos;: &apos;task_douyu.SAVE_DOUYU_DATA&apos;, # 具体任务 task_douyu.SAVE_DOUYU_DATA 是一个真正要执行的任务</span><br><span class="line">        &apos;schedule&apos;: crontab(minute=[40]), # 任务计划时间，每小时40分的时候执行</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A douyu_app worker -B --loglevel=info</span><br></pre></td></tr></table></figure></li></ol><p>这里的-B主要用于celery定时任务，通过heartbeat来通知Worker是否有任务需要执行。</p><p>我这里只是简单的用了一下celery，并且只用到了定时任务，celery作为一款分布式任务调度工具，肯定会有更多更厉害的用法，留待以后用到的时候再研究。</p><h1 id="fabric"><a href="#fabric" class="headerlink" title="fabric"></a>fabric</h1><p>之所以用到fabric还是因为自己比较懒，前边说到最近在频繁更新两个小项目，这两个项目都有向外提供api数据服务的部分，所以每次修改代码，运行测试，提交代码，ssh到远程主机pull最新代码，杀死原先服务进程，nohup最新服务。这个链路还是比较长的，并且有个项目长期的爬取网络数据，然后存储在mongodb中，自己的低配云主机硬盘有限，需要不定期地将数据迁移出来，所以想到了fabric这个好东西，应该可以满足自己的需求，自动化完成上述整个任务链路。</p><ol><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install fabric</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录创建fabfile.py(默认使用这个名字，如果想要自定义，在运行的时候fab -f xxx.py也是可以的)</p></li><li><p>配置远程主机<br>fabric是通过ssh的方式登录到远程主机的，可以通过用户名/密码的方式或者是通过密钥的形式，因为也就三台主机，也都是自己的机器，我选择使用密钥登陆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 配置~/.ssh/config</span><br><span class="line">Host host_name</span><br><span class="line">HostName ip or domain</span><br><span class="line">User user </span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"># 在fabfile中增加相关配置</span><br><span class="line">env.use_ssh_config = True</span><br><span class="line">env.hosts = [&apos;al&apos;, &apos;al1&apos;]  # 这里的名字就是config中的host_name</span><br><span class="line">env.roledefs = &#123;   # 不同的主机要是有不同的任务，可以通过指定role来进行区分</span><br><span class="line">    &apos;douyu&apos;: [&apos;al&apos;],   </span><br><span class="line">    &apos;other&apos;: [&apos;al1&apos;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加运行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@task</span><br><span class="line">def run_test():</span><br><span class="line">    with settings(warn_only=True):</span><br><span class="line">        result = local(&apos;python tester.py&apos;, capture=True)</span><br><span class="line">    if result.failed and not confirm(&quot;Tests failed. Continue anyway?&quot;):</span><br><span class="line">        abort(&quot;Aborting at user request.&quot;)</span><br></pre></td></tr></table></figure></li><li><p>提交代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@runs_once</span><br><span class="line">@task</span><br><span class="line">def pre_deploy():</span><br><span class="line">    local(&apos;git add -A &amp;&amp; git commit&apos;)</span><br><span class="line">    local(&apos;git push origin master &amp;&amp; git push tx master&apos;)</span><br></pre></td></tr></table></figure></li><li><p>更新代码，发布新的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def deploy_code(cmd):</span><br><span class="line">    code_dir = &apos;~/git/Hotroom&apos;</span><br><span class="line">    with settings(warn_only=True):</span><br><span class="line">        if run(&quot;ls &#123;&#125;&quot;.format(code_dir)).failed:</span><br><span class="line">            run(&quot;git clone hhttps://github.com/love3forever/Hotroom.git &#123;&#125;&quot;.format(code_dir))</span><br><span class="line">    with cd(code_dir):</span><br><span class="line">        run(&quot;git pull&quot;)</span><br><span class="line">        run(&quot;sudo pip install -r ./requirement.txt&quot;)</span><br><span class="line">        with cd(&apos;./hotroom&apos;):</span><br><span class="line">            pids = run(</span><br><span class="line">                &quot;ps -ef | grep celery | grep -v grep | awk &apos;&#123;print $2&#125;&apos;&quot;)</span><br><span class="line">            if pids:</span><br><span class="line">                pid_list = pids.split(&apos;\r\n&apos;)</span><br><span class="line">                for i in pid_list:</span><br><span class="line">                    with settings(warn_only=True):</span><br><span class="line">                        run(&apos;kill -9 %s&apos; % i)</span><br><span class="line">            run(&apos;pwd&apos;)</span><br><span class="line">            run(&quot;(nohup celery -A &#123;&#125; worker -B --loglevel=error &gt;&amp; /dev/null &lt; /dev/null &amp;) &amp;&amp; sleep 1&quot;.format(cmd))</span><br><span class="line">            run(&apos;echo deployed&apos;)</span><br></pre></td></tr></table></figure></li><li><p>备份还原数据库，清空数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def dump(db):</span><br><span class="line">    stamp = datetime.now().strftime(&apos;%y_%m_%d_%H_%M&apos;)</span><br><span class="line">    cd_dir = &apos;~/tars/dump/&apos;</span><br><span class="line">    dump_dir = &apos;~/tars/dump/dump_&#123;&#125;&apos;.format(stamp)</span><br><span class="line">    dump_tar = &apos;dump_&#123;&#125;.tar.gz&apos;.format(stamp)</span><br><span class="line">    local_dir = &apos;/Users/eclipse/Downloads/mongo34/dump/&apos;</span><br><span class="line">    local_tar_dir = &apos;/Users/eclipse/Downloads/mongo34/dump/dump_&#123;&#125;&apos;.format(</span><br><span class="line">        stamp)</span><br><span class="line">    local_dump_dir = &apos;/Users/eclipse/Downloads/mongo34/dump/dump_&#123;&#125;.tar.gz&apos;.format(</span><br><span class="line">        stamp)</span><br><span class="line">    with settings(warn_only=True):</span><br><span class="line">        run(&apos;mkdir -p &#123;&#125;&apos;.format(dump_dir))</span><br><span class="line">        run(&apos;mongodump -d &#123;&#125; -c Roominfo -o &#123;&#125; --gzip&apos;.format(db, dump_dir))</span><br><span class="line">    with cd(cd_dir):</span><br><span class="line">        run(&apos;ls&apos;)</span><br><span class="line">        run(&apos;tar -zcvf &#123;&#125; &#123;&#125;&apos;.format(dump_tar, &apos;dump_&#123;&#125;&apos;.format(stamp)))</span><br><span class="line">    with settings(warn_only=True):</span><br><span class="line">        get(&apos;~/tars/dump/&#123;&#125;&apos;.format(dump_tar), local_dir)</span><br><span class="line">        run(&apos;echo current db:&#123;&#125;&apos;.format(db))</span><br><span class="line">        run(&apos;mongo&apos;)</span><br><span class="line">        local(&apos;mkdir -p &#123;&#125;&apos;.format(local_tar_dir))</span><br><span class="line">        local(&apos;tar -zxvf &#123;&#125; -C &#123;&#125;&apos;.format(local_dump_dir, local_dir))</span><br><span class="line">        local(&apos;/Users/eclipse/Downloads/mongo34/bin/mongorestore --dir=&#123;&#125; \</span><br><span class="line">            --gzip&apos;.format(local_tar_dir))</span><br></pre></td></tr></table></figure></li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>目前都只用到了这两个库的一点点功能，相信在以后的工作中会让这俩库有更多的作用！</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> celery </tag>
            
            <tag> fabric </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>近期的一些总结</title>
      <link href="/2017/07/09/%E6%9C%80%E8%BF%91%E5%85%B3%E4%BA%8Epython%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
      <url>/2017/07/09/%E6%9C%80%E8%BF%91%E5%85%B3%E4%BA%8Epython%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>昨天看到自己手机上wunderlist上的提示“精通python”，任务是去年同一时间建立的。那时候我才刚刚毕业，还没去单位报道，在家里找了个练手项目，逐步学习python相关的东西：爬虫、web框架、机器学习等各方面，那时候想着要是用一年的时间好好来学，应该可以达到精通的程度了。<br>现在回过头来看，虽然没有达到自己预想的“精通”，但这一年还算充实，至少不是虚度时光，单是针对python相关的东西，自己也是从方方面面用了不少时间来学习、练习、思考。<br><a id="more"></a></p><h1 id="读好书"><a href="#读好书" class="headerlink" title="读好书"></a>读好书</h1><p>对于我来说，如果想要接触一门新技术，我会先去它的官网做初步的了解（主要了解它的主要用途、相关生态圈状况），然后在网上看一些关于它的一些成功应用案例，如果确定这是个不错的东西的话，我就会买上一两本评价较好的书（一只感觉要想快速掌握一门新技术的基本用法，看书是最节省时间的），当然如果没有相关书籍的话官方文档是最好的参考资料。<br>到现在为止，马上也快工作一年了，各类技术书籍也是没少买，不过现阶段让我学到最多的是这三本书：<a href="https://book.douban.com/subject/26852057/" target="_blank" rel="noopener">Python Web开发实战</a>、<a href="https://book.douban.com/subject/26381341/" target="_blank" rel="noopener">Python Cookbook</a>、<a href="https://book.douban.com/subject/27028517/" target="_blank" rel="noopener">流畅的Python</a>。之所以说是现阶段是因为，我觉得不管是技术书籍也好还是其他各种不同类型的书籍，你在不同的时间去读都会有不同的感受。<br>像我这样的选手，真正使用python进行开发的时间也就一年多，缺少很多实际工作总的经验，接触到的东西也比较少，而《Python Web开发实战》这本书就恰好解决了我的很多疑惑。这本书中关于flask的一些特性相关的东西倒是其次，我比较习惯的是这本书中关于实际开发中一些像supervisor、celery这样的好工具，一些像unittest、flake8这样的一些有很大用处的库以及作者在生产环境下python项目的部署等等。<br>《python cookbook》则可以作为一本工具书，书中每个小节的内容基本上都可以解决在实际编程过程中遇到到很具体的问题，并且书中一些示例代码也会让我认识到什么样的代码才是更加pythonic的，不仅是提高可读性更关键的是提高代码的执行效率。在了解到生成器的好处之后，我再也不直接返回一个巨大无比的list了。<br>之前对《流畅的Python》这本书也是略有耳闻，在中文版出来的第一时间就入手了，虽然到现在一直也没能读完，但是我很确定这本书确实不错。和《python cookbook》有点像，这本书的作者更愿意从python标准库出发，对python数据结构、函数、面向对象、并发和元编程等各个方面有比较深入的剖析。书中的很多内容都会让我有这种“居然还有这种操作”的感觉。总之，这本书能够让自己在考虑问题的时候更多的使用python的思维方式，并且在以后的代码风格上也会尽量的按照书中所说的要求执行。</p><h1 id="多练习"><a href="#多练习" class="headerlink" title="多练习"></a>多练习</h1><p>忘记是从哪里看到的这样的理论：作为一个技术人，要理解好技术二字，所谓技，可以理解为你在实际工作中一次又一次的重复的沉淀，而术则可以理解为自己在进行一项工作的时候的理论支撑，这两者也是相辅相承，而技术人的技术水平也会是一个螺旋上升的过程。<br>在读了很多书之后，<strong>刻意练习</strong>是必不可少的，如果工作环境恰好需要用到这项技术则最好，如果没有这样的条件，自己在生活中可以找多很多好点子可以通过自己的技术来实现。还是不得不说，<a href="https://www.wunderlist.com/zh/" target="_blank" rel="noopener">奇妙清单/wunderlist</a>是一款很不错的应用，可以实现多端同步，我经常用它来记录自己突然闪现的灵光。在有了自认为比较好的点子之后，就可以逐步细化实现方式，然后就可以动手开干。</p><h1 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h1><p>我自己的梦想是成为一个真正的全栈程序员，从设计、前端到交互、后端，然后可以自己在家办公，不用打卡上下班。现在看来好像还差的比较远，那就先定个小目标吧：在年底之前，巩固自己现有的技术栈：vue + python + mongodb，能够在有明确需求的情况下在最短的时间内满足需求。另外，好的工具能够有效提升生产力，好的工作流程也能减少自己在不必要地方的时间开支，自动化测试／部署也是下半年工作的一个重点。另外就是要养成总结的习惯，所以以后每个月至少更新三篇博客。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 读书 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cesium-terrain-builder在windows下的编译</title>
      <link href="/2017/06/30/cesium-terrain-builder%E5%9C%A8windows%E4%B8%8B%E7%9A%84%E7%BC%96%E8%AF%91/"/>
      <url>/2017/06/30/cesium-terrain-builder%E5%9C%A8windows%E4%B8%8B%E7%9A%84%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>最近在研究cesium，发现cesium 用的地形数据跟osgEarth的还不太一样，他们采用<a href="https://github.com/AnalyticalGraphicsInc/quantized-mesh" target="_blank" rel="noopener">quantized-mesh</a>这个数据格式，之前在osgEarth上用的地形瓦片在cesium上用不了，让人比较恼火。好在github上有人已经实现了从tif格式的dem数据转到.terrain格式的工具:<a href="https://github.com/homme/cesium-terrain-builder" target="_blank" rel="noopener">cesium-terrain-builder</a>，不过该项目在windows下编译让人比较难受，所以纪录一下整个过程。<br><a id="more"></a></p><h1 id="源码和工具下载"><a href="#源码和工具下载" class="headerlink" title="源码和工具下载"></a>源码和工具下载</h1><p>虽然作者在github上说这个项目只依赖gdal，不过在windows上发现它还依赖zlib（并且对这两个库的版本也有所要求），所以要想完整的编译整个项目需要分别下载这些源码：</p><ol><li><a href="https://github.com/homme/cesium-terrain-builder" target="_blank" rel="noopener">cesium-terrain-builder</a></li><li><a href="http://download.osgeo.org/gdal/2.0.2/gdal202.zip" target="_blank" rel="noopener">gdal-2.0.2</a></li><li><a href="https://zlib.net/zlib-1.2.11.tar.gz" target="_blank" rel="noopener">zlib-1.2.11</a></li><li><a href="https://cmake.org/files/v3.9/cmake-3.9.0-rc5-win64-x64.msi" target="_blank" rel="noopener">cmake-3.9.0</a></li><li><a href="">vs2017</a>(这个就看自己需求了，使用cmake生成自己对应的vs版本工程文件即可)</li></ol><h1 id="zlib编译生成"><a href="#zlib编译生成" class="headerlink" title="zlib编译生成"></a>zlib编译生成</h1><p>在完成zlib解压之后，使用cmake配置，生成vs工程：</p><ol><li>zlib cmake配置<br><img src="https://eclipsesv.com/pics/myblogzlib_cmake.png" alt="zlib_cmake_conf"></li><li>zlib vs工程配置<br><img src="https://eclipsesv.com/pics/myblogzlib_cmake_conf.png" alt="zlib_vs"></li><li>zlib 工程编译<br><img src="https://eclipsesv.com/pics/myblogzlib_make.png" alt="zlib_build"></li><li>生成结果<br>在完成debug和release之后，生成内容如下如所示：<br><img src="https://eclipsesv.com/pics/myblogzlib_result.png" alt="zlib_result">，其中include和lib文件夹在后边会有用到。</li></ol><h1 id="gdal编译生成"><a href="#gdal编译生成" class="headerlink" title="gdal编译生成"></a>gdal编译生成</h1><p>gdal通过<a href="">x64 Native Tools Command Prompt for VS 2017</a>工具进行编译：<br>打开这个命令行工具之后，cd进入到gdal源码目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd G:\gdal-2.0.2</span><br><span class="line">g:</span><br><span class="line">nmake /f makefile.vc MSVC_VER=1910 WIN64=YES</span><br><span class="line">nmake /f makefile.vc MSVC_VER=1910 WIN64=YES install</span><br><span class="line">nmake /f makefile.vc MSVC_VER=1910 WIN64=YES devinstall</span><br></pre></td></tr></table></figure></p><p>其中MSVC_VER代表的是VS的版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 1910 = 15.0(2017)</span><br><span class="line"># 1900 = 14.0(2015)</span><br><span class="line"># 1800 = 12.0(2013)</span><br><span class="line"># 1700 = 11.0(2012)</span><br><span class="line"># 1600 = 10.0(2010)</span><br><span class="line"># 1500 = 9.0 (2008)</span><br><span class="line"># 1400 = 8.0 (2005) - specific compilation flags, different from older VC++</span><br><span class="line"># 1310 = 7.1 (2003) # is it still supported ?</span><br><span class="line"># 1300 = 7.0 (2002) # is it still supported ?</span><br></pre></td></tr></table></figure></p><p>完成上述操作之后会默认在C盘生成gdal编译好的结果：<br><img src="https://eclipsesv.com/pics/mybloggdal_result.png" alt=""></p><h1 id="cesium-terrain-builder编译生成"><a href="#cesium-terrain-builder编译生成" class="headerlink" title="cesium-terrain-builder编译生成"></a>cesium-terrain-builder编译生成</h1><p>首先打开cesium-terrain-builder源码文件夹，将CMakeLists.txt拖入cmake，主要配置gdal和zlib的路径：<br><img src="https://eclipsesv.com/pics/cesium_tool.png" alt=""><br>完成配置之后，生成vs工程，直接编译即可。</p><h1 id="生成结果"><a href="#生成结果" class="headerlink" title="生成结果"></a>生成结果</h1><p>经过上边一番折腾之后，最终生成这些东西：<br><img src="https://eclipsesv.com/pics/ctb-tools.png" alt=""><br>他们的具体用法可以参考这里：<a href="https://github.com/homme/cesium-terrain-builder" target="_blank" rel="noopener">使用方法</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过这次折腾学会了使用vs的Native Tools，也知道使用cmake生成vs工程并不是什么复杂的事情，而最终目的就是参考这个开源工具的思路实现要python的切片工具。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> vs2017 </tag>
            
            <tag> gdal </tag>
            
            <tag> zlib </tag>
            
            <tag> cesium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最近一段时间的总结</title>
      <link href="/2017/05/31/%E6%9C%80%E8%BF%91%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2017/05/31/%E6%9C%80%E8%BF%91%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>上周我的几个研究生同学完成了毕业论文答辩，突然意识到已经毕业快要一年了。我从河北辞职回到武汉也有一个半月了，趁着现在手上的活不是很多，总结一下最近工作、学习和生活上的各种。<br><a id="more"></a></p><h1 id="new-work"><a href="#new-work" class="headerlink" title="new work"></a>new work</h1><p>之所以从河北的单位辞职，很大一步分原因是自己不喜欢那样的工作状态：没有明确的目标，宽泛的界限，无成长性的重复。现在的这家公司，做的是专业相关的东西，目前主要的工作范畴是爬数据、提供借口、页面展示，可以稍微吃一下自己的老本，总体来说工作压力不大，可支配时间充裕，比较适合我理想的状态（工作毕竟只是工作，有自己的时间去做喜欢的事情才最好）。<br>唯一感到不太好的就是来到这里之后成长没有预想的快，主要原因是刚开始做的东西大都是自己之前做过的（爬虫、写服务、jquery），所以最近开发工作基本停下来之后准备开始深入底层相关的内容学习。可能学习的过程会有些吃力，不过有更快的成长总归是好的。</p><h1 id="learn-something-new"><a href="#learn-something-new" class="headerlink" title="learn something new"></a>learn something new</h1><p>我一直是个喜欢鼓捣新技术的非专业三分钟热度选手，最近想要学一下一直想学但是被各种事情耽误的unity3d，买了几本书（一直还没看，哈哈哈）；另外就是机器学习，之前的几本书都只是看了一部分，感觉里边的一些东西理解起来略微吃力，也没有静下心来仔细去看去理解；还有就是工作需要的东西：osgearth，还是应了我很久之前说的那句话“该来的总归还是要来的”。</p><h1 id="happy-life"><a href="#happy-life" class="headerlink" title="happy life"></a>happy life</h1><p>想想这次工作调整给自己带来的最大的改变就是生活状态。截至目前，我的生活状态还是比较吻合自己还在学校的时候对未来的憧憬：一间独居小屋，一台性能强劲的电脑，一桌子想要读的技术书籍，可爱的女朋友（不知道啥时候才能在一个城市工作）还有一只喵星人。</p><h1 id="challenges"><a href="#challenges" class="headerlink" title="challenges"></a>challenges</h1><p>挑战一直都有，眼前主要的挑战主要有这些：</p><ul><li>尽快陪女朋友一起完成俺们俩的<a href="https://github.com/love3forever/gogo3" target="_blank" rel="noopener">vue小项目</a></li><li>静下心学osgearth相关内容（基本的场景渲染概念、流程，底层各种数据调度机制）</li><li>挤出时间把自己想读的书好好读完</li><li>调整自己的作息、增加锻炼时间（必须要控制体重啦）</li><li>做好一个合格的铲屎官</li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ubuntu16.04 nginx配置http2.0</title>
      <link href="/2017/05/25/ubuntu%E9%85%8D%E7%BD%AEhttp2.0/"/>
      <url>/2017/05/25/ubuntu%E9%85%8D%E7%BD%AEhttp2.0/</url>
      
        <content type="html"><![CDATA[<p>最近在为cesium（一个开源三维球）配置本地瓦片服务，想起自己之前研究过的http2.0会对瓦片数据调度效率有明显提升，特意给自己的开发环境配置了http2.0的环境。</p><p>google之后发现两个很好的教程<a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-nginx-with-http-2-support-on-ubuntu-16-04" target="_blank" rel="noopener">How To Set Up Nginx with HTTP/2 Support on Ubuntu 16.04</a>，<a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-16-04" target="_blank" rel="noopener">How To Secure Nginx with Let’s Encrypt on Ubuntu 16.04</a>特此记录！</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> nginx </tag>
            
            <tag> http2.0 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ubuntu mate16.04 apt源</title>
      <link href="/2017/05/13/ubuntu_mate_16%20apt%E6%BA%90/"/>
      <url>/2017/05/13/ubuntu_mate_16%20apt%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>最近准备使用ubuntu mate16搭建一套开发环境，记录一下使用到的apt源，阿里云的，速度还是挺不错的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> apt </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>requests库的Failed to establish a new connection</title>
      <link href="/2017/01/29/requests%E5%BA%93error/"/>
      <url>/2017/01/29/requests%E5%BA%93error/</url>
      
        <content type="html"><![CDATA[<p>使用python做爬虫的过程中，经常会在较短的时间内构建大量的连接向服务器请求数据，遇到了这样的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requests.exceptions.ConnectionError: HTTPConnectionPool(host=&apos;xxx&apos;, port=80):</span><br><span class="line">Max retries exceeded with url: /document/record/_search?pretty=true (Caused by NewConnectionError</span><br><span class="line">(&apos;&lt;requests.packages.urllib3.connection.HTTPConnection object at 0x7f544af9a5d0&gt;: Failed to establish a new connection: [Errno -3] Temporary failure in name resolution&apos;,))</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>最开始看到<code>Max retries exceeded with url</code>还以为是请求过于频繁，自己的ip地址被ban了，而后又通过requests库手动发出一条请求，并没有上边的错误，看来并不是ip被ban。<br>又看到<code>Temporary failure in name resolution</code>，会不会是域名解析的问题？也不会，单独一条请求是可以正常返回结果的，拿到底是怎么回事？<br>经过一番google，stackoverflow之后看到了这几个答案：</p><ul><li><a href="http://xiaorui.cc/2015/12/22/%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E7%94%A8requests%E8%AE%BF%E9%97%AEhttp-api%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/" target="_blank" rel="noopener">多进程下用requests访问http api时遇到的坑</a></li><li><a href="http://stackoverflow.com/questions/10115126/python-requests-close-http-connection" target="_blank" rel="noopener">Python-Requests close http connection</a></li></ul><p>结合自己出现问题的场景，应该就是因为在短时间内打开了太多的http连接，并且这些连接都是默认keep-alive的形式。<br>所以在request的header中添加了<code>&#39;Connection&#39;: close</code>，并且在每个请求完成之后time.sleep(0.01)。</p><p>修改之后，爬虫跑了一夜没再出问题，开心。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mongodb用户名密码登录</title>
      <link href="/2017/01/17/mongodb%E5%B8%A6%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/01/17/mongodb%E5%B8%A6%E5%AF%86%E7%A0%81%E9%AA%8C%E8%AF%81%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>写这篇博客是为了纪念最近闹的沸沸扬扬的大规模mongodb库被黑的事件，我自己也不幸中招，索性被黑的数据都是自己做试验的一些数据，并不是很重要。<br><a id="more"></a><br>可能是mongodb为了让人更加容易上手，默认情况下不用验证就可以操作数据库。但是如果想要确保自己mongodb的安全，可以通过<a href="https://docs.mongodb.com/manual/administration/security-checklist/" target="_blank" rel="noopener">多种方式</a>来实现。<br>其中最简便的是通过用户名和密码来验证。</p><h1 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h1><p>在对mongodb增加验证使用之前，需要增加一个admin用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./bin/mongo</span><br><span class="line">use admin</span><br><span class="line">db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    user: &quot;admin&quot;,</span><br><span class="line">    pwd: &quot;abc@123&quot;,</span><br><span class="line">    roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>上边这段命令指的是在admin库中增加管理员admin用户，他的密码是abc@123。有了admin账户之后，可以增加其他的用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    user: &quot;eclipse&quot;,</span><br><span class="line">    pwd: &quot;abc@123&quot;,</span><br><span class="line">    roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;Douyudata&quot; &#125;,</span><br><span class="line">             &#123; role: &quot;readWrite&quot;, db: &quot;Pandata&quot; &#125; ]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>而上边这些命令就是对具体操作数据库的用户：创建用户eclipse，密码abc@123，拥有对库Douyudata和Pandata的读写权限。<br>新增用户之后，可以在mongodb在启动的时候，通过加入–auth参数即可启动安全验证功能。例如：<code>./bin/mongod --dbpath ./db  --auth</code>。</p><h1 id="shell操作"><a href="#shell操作" class="headerlink" title="shell操作"></a>shell操作</h1><p>在通过上边的命令运行mongod之后，使用./bin/mongo打开shell连接mongodb。<br>连接之后看下数据库列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">2017-02-17T11:09:43.539+0800 E QUERY    [main] Error: listDatabases failed:&#123;</span><br><span class="line">&quot;ok&quot; : 0,</span><br><span class="line">&quot;errmsg&quot; : &quot;not authorized on admin to execute command &#123; listDatabases: 1.0 &#125;&quot;,</span><br><span class="line">&quot;code&quot; : 13,</span><br><span class="line">&quot;codeName&quot; : &quot;Unauthorized&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现已经受到mongodb权限认证机制的保护。<br>先用admin登录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">&gt; db.auth(&apos;admin&apos;,&apos;abc@123&apos;)</span><br><span class="line">1</span><br><span class="line">&gt; show dbs</span><br><span class="line">Douyu        0.180GB</span><br><span class="line">Douyudata    0.001GB</span><br><span class="line">admin        0.000GB</span><br><span class="line">lagou        0.000GB</span><br><span class="line">local        0.000GB</span><br><span class="line">test         0.000GB</span><br><span class="line">userManager  0.001GB</span><br></pre></td></tr></table></figure></p><p>需要注意的是，这个admin目前只是个用户管理员的角色，他对具体的数据库没有读写权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; use Douyu</span><br><span class="line">switched to db Douyu</span><br><span class="line">&gt; show tables</span><br><span class="line">2017-02-17T11:15:17.279+0800 E QUERY    [main] Error: listCollections failed: &#123;</span><br><span class="line">&quot;ok&quot; : 0,</span><br><span class="line">&quot;errmsg&quot; : &quot;not authorized on Douyu to execute command &#123; listCollections: 1.0, filter: &#123;&#125; &#125;&quot;,</span><br><span class="line">&quot;code&quot; : 13,</span><br><span class="line">&quot;codeName&quot; : &quot;Unauthorized&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要向对数据库进行读写，需要切换到对应的用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">&gt; db.auth(&apos;eclipse&apos;,&apos;abc@123&apos;)</span><br><span class="line">1</span><br><span class="line">&gt; use Douyudata</span><br><span class="line">switched to db Douyudata</span><br><span class="line">&gt; show tables</span><br><span class="line">Catalog</span><br><span class="line">Roominfo</span><br></pre></td></tr></table></figure></p><h1 id="pymongo中的认证方法"><a href="#pymongo中的认证方法" class="headerlink" title="pymongo中的认证方法"></a>pymongo中的认证方法</h1><p>我一般使用pymongo来连接mongodb，通过pymongo连接的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from pymongo import MongoClient</span><br><span class="line">class DB(object):</span><br><span class="line">    &quot;&quot;&quot;docstring for DB&quot;&quot;&quot;</span><br><span class="line">    def __init__(self, host=&apos;localhost&apos;, port=27017):</span><br><span class="line">        self.cli = MongoClient(host=host, port=port)</span><br><span class="line">    def switch_db(self, database):</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        切换到目标数据库，并进行权限验证</span><br><span class="line">        &apos;&apos;&apos;</span><br><span class="line">        if database and isinstance(database, str):</span><br><span class="line">            name = os.getenv(&apos;mongo_name&apos;)</span><br><span class="line">            pasw = os.getenv(&apos;mongo_pswd&apos;)</span><br><span class="line">            authdb = self.cli[&apos;admin&apos;]</span><br><span class="line">            try:</span><br><span class="line">                authdb.authenticate(name=name, password=pasw)</span><br><span class="line">            except Exception as e:</span><br><span class="line">                print(&quot;Erro accured during db authenticate:&#123;&#125;&quot;.format(str(e)))</span><br><span class="line">            self.db = self.cli[database]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>flask-socketio的一次使用记录</title>
      <link href="/2016/12/28/flask-socketio%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%8E%86/"/>
      <url>/2016/12/28/flask-socketio%E7%9A%84%E4%B8%80%E6%AC%A1%E4%BD%BF%E7%94%A8%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个小项目，其中一部分即时通信的功能我是通过flask-socketio来完成的后端代码编写。在尝试过程中遇到了一些问题，特在此记录，以备后用。<br><a id="more"></a><br>具体说来，想要实现的功能是这样的：每两个用户通过通过一个pair保存起来，而每个pair通过唯一的标识符加以区分；在用户连接到后端聊天服务器之后，后端通过该用户对应的pair标识符简历一个专属的聊天频道(room)；这个聊天频道只有这个pair中的两个人能够进入（类似于qq私聊）。</p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>现在具体流程已经很清楚了，要实现的功能也比较简单，所以具体实现如下：<br>首先，要建立一个socketio服务器实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from flask_socketio import SocketIO, Namespace</span><br><span class="line">from flask import Flask</span><br><span class="line">def createApp():</span><br><span class="line">    app = Flask(__name__)</span><br><span class="line">    app.config[&apos;SECRET_KEY&apos;] = &apos;wtf&apos;</span><br><span class="line">    return app</span><br><span class="line">app = createApp()</span><br><span class="line">socketio = SocketIO(app)</span><br></pre></td></tr></table></figure></p><p>现在有了这个socketio，我们就可以为他添加对应的事件：前端发来连接请求并且把该用户所属的pair标识符一并发来，我们需要接受连接请求并建立一个room，room建立之后，用户加入对应的room。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 前端请求</span><br><span class="line">var chat = io.connect(&apos;ws://localhost:4000&apos;);// 通过指定的ip和port连接后端</span><br><span class="line">chat.on(&apos;connect&apos;, function(data) &#123;</span><br><span class="line">    chat.emit(&apos;message&apos;,&#123;msg: &apos;&#123;&#123;roomid&#125;&#125;&apos;&#125;,function()&#123;//连接建立之后，向后端发送标识符</span><br><span class="line">        room = io.connect(&apos;ws://localhost:4000/&#123;&#123;roomid&#125;&#125;&apos;);//后端生成对应的room，并提供连接</span><br><span class="line">        room.on(&apos;liaoxian&apos;,function(data)&#123;//监听后端的事件</span><br><span class="line">            msgPanel.append(&apos;&lt;p&gt;&apos;+data+&apos;&lt;/p&gt;&lt;br&gt;&apos;)</span><br><span class="line">        &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 后端处理</span><br><span class="line"># 由于在实际运行中，可能会有大量的room需要建立，通过class将room抽象出来会更方便</span><br><span class="line">class ChatRoom(Namespace):</span><br><span class="line">    def on_connect(self):</span><br><span class="line">        print(&apos;client connected to room&apos;)</span><br><span class="line"></span><br><span class="line">    def on_disconnect(self):</span><br><span class="line">        print(&apos;client disconnected from room&apos;)</span><br><span class="line"># 自定义的事件，前边需要加上on_</span><br><span class="line">    def on_liaoxian(self, msg):</span><br><span class="line">        print(&apos;running liaoxian&apos;)</span><br><span class="line">        print(msg)</span><br><span class="line">        self.send(msg)</span><br><span class="line">    def on_recv(self, data):</span><br><span class="line">        self.emit(&apos;liaoxian&apos;, data[&apos;msg&apos;])</span><br><span class="line">@socketio.on(&apos;message&apos;)</span><br><span class="line">def getMsg(sss):</span><br><span class="line">    print(sss)</span><br><span class="line">    room = sss[&apos;msg&apos;]</span><br><span class="line">    newRoom = ChatRoom(&apos;/&#123;&#125;&apos;.format(room))# 通过制定的room生成对应的聊天频道</span><br><span class="line">    socketio.on_namespace(newRoom)</span><br></pre></td></tr></table></figure><p>通过上边很简单的代码就可以完成一个简单的点到点即时通信应用，详细代码在我的<a href="">github</a>中。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> flask </tag>
            
            <tag> socketio </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>flask几种部署方式实践</title>
      <link href="/2016/12/12/flask%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E5%AE%9E%E8%B7%B5/"/>
      <url>/2016/12/12/flask%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>flask作为一款轻量级web框架，具有诸多优点。我喜欢它的原因是它具有高度的可扩展性，广泛的各类插件，丰富的开发文档。在开发调试过程中，我们往往会简单的使用flask自带的web服务器。但是在实际的生产环境中，flask自带的web服务器很难满足需求。<br><a id="more"></a><br>所以，在生产环境中，部署flask应该用什么呢？这首先就不得不说WSGI了。</p><h1 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h1><p>WSGI(python web server gateway interface)，python web服务器网关接口。它是python语言定义的web服务器和web应用程序之间的一种简单通用的接口。WSGI可以分为两个部分：一个是服务器或者说是网关，另一个可以成为web应用或者说是应用框架。在处理来自前端的请求是，服务器会为应用程序提供环境上下文及一个回调函数。在应用程序完成请求之后，将先前的回调函数结果返回给前端。因此，对于flask而言，这里的WSGI可以起到的功能：</p><ol><li>重写环境变量，根据目标url将请求消息路由到对应的应用对象；</li><li>允许在一个进程中运行多个web应用程序或者框架；</li><li>可以起到负载均衡远端请求的作用；</li><li>对请求或者返回内容进行处理。</li></ol><p>因此，只要遵照WSGI协议的web应用都可以部署在对应的webserver之后。或者说WSGI之于python，就如同Fastcgi之于php。</p><h1 id="独立的WSGI容器"><a href="#独立的WSGI容器" class="headerlink" title="独立的WSGI容器"></a>独立的WSGI容器</h1><p>如果同时有好几个东西在面前，能够实现的功能类似，我肯定会选择更容易操作的。在flask部署这件事情上，我会选择一些独立的WSGI容器来部署flask。</p><h2 id="gunicorn"><a href="#gunicorn" class="headerlink" title="gunicorn"></a>gunicorn</h2><p><a href="http://gunicorn.org/" target="_blank" rel="noopener">gunicorn</a>是一个unix用的WSGI HTTP服务器。它是从ruby的unicorn项目中移植过来的。它基于”pre-fork worker”模型，会预先开启大量进程，等待并处理接收到的请求，每个单独进程可以同时处理它们各自接到的请求，避免进程启动和销毁的开销。但是gunicorn是基于阻塞式的io，并发能力稍弱。如果要想用它来部署flask应用相当简便。</p><ul><li>第一步，要通过pip安装gunicorn，<code>pip install gunicorn</code></li><li>在安装完成之后，通过命令：<code>gunicorn -w 4 -b 127.0.0.1:4000 run:app</code>就可以将所要启动的flask应用程序启动。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">→ gunicorn -w 4 -b 127.0.0.1:4000 run:app</span><br><span class="line">[2016-12-12 21:44:16 +0800] [81837] [INFO] Starting gunicorn 19.6.0</span><br><span class="line">[2016-12-12 21:44:16 +0800] [81837] [INFO] Listening at: http://127.0.0.1:4000 (81837)</span><br><span class="line">[2016-12-12 21:44:16 +0800] [81837] [INFO] Using worker: sync</span><br><span class="line">[2016-12-12 21:44:16 +0800] [81840] [INFO] Booting worker with pid: 81840</span><br><span class="line">[2016-12-12 21:44:16 +0800] [81841] [INFO] Booting worker with pid: 81841</span><br><span class="line">[2016-12-12 21:44:16 +0800] [81842] [INFO] Booting worker with pid: 81842</span><br><span class="line">[2016-12-12 21:44:16 +0800] [81843] [INFO] Booting worker with pid: 81843</span><br></pre></td></tr></table></figure></li></ul><p>其中-w指的是预定义的工作进程数，-b指的是要绑定的ip和端口，run是flask的启动python文件，app则是flask应用程序实例。比如说，我的run.py文件中是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(debug=True, host=&apos;0.0.0.0&apos;, port=4000)</span><br></pre></td></tr></table></figure></p><h2 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h2><p><a href="http://www.tornadoweb.org/" target="_blank" rel="noopener">Tornado</a>，它是一款开源的可伸缩、非阻塞式的web服务器和工具集。在高并发的应用场景中有不错的效果。同样，要想通过Tornado来部署flask也是很简便的：</p><ul><li>第一步，通过pip安装<code>pip install tornado</code></li><li>第二部，在你的flask启动文件夹中新建py文件，然后输入这些内容，在启动的时候通过这个新建的文件启动即可:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from tornado.wsgi import WSGIContainer</span><br><span class="line">from tornado.httpserver import HTTPServer</span><br><span class="line">from tornado.ioloop import IOLoop</span><br><span class="line">from run import app</span><br><span class="line">http_server = HTTPServer(WSGIContainer(app))</span><br><span class="line">http_server.listen(4000)</span><br><span class="line">IOLoop.instance().start()</span><br></pre></td></tr></table></figure></li></ul><h2 id="Gevent"><a href="#Gevent" class="headerlink" title="Gevent"></a>Gevent</h2><p><a href="http://www.gevent.org/" target="_blank" rel="noopener">Gevent</a>是一个基于协同程序的python库，与tornado的部署方式类似，通过gevent部署flask也是十分的便利：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from gevent.wsgi import WSGIServer</span><br><span class="line">from run import app</span><br><span class="line">http_server = WSGIServer((&apos;&apos;, 4000), app)</span><br><span class="line">http_server.serve_forever()</span><br></pre></td></tr></table></figure></p><h1 id="nginx-http代理"><a href="#nginx-http代理" class="headerlink" title="nginx http代理"></a>nginx http代理</h1><p>单纯依靠上述的这些wsgi容器在生产环境中还是不够的，往往还要在这些容器前边在部署一个nginx做http转发。nginx可以起到负载均衡、流量控制、日志管理等等更加精细的工作。对nginx的配置文件做简单的修改即可完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line"></span><br><span class="line">    server_name _;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log;</span><br><span class="line">    error_log  /var/log/nginx/error.log;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass         http://127.0.0.1:4000/;</span><br><span class="line">        proxy_redirect     off;</span><br><span class="line"></span><br><span class="line">        proxy_set_header   Host             $host;</span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="其他的部署方式"><a href="#其他的部署方式" class="headerlink" title="其他的部署方式"></a>其他的部署方式</h1><p>当然，除了通过上述几个wsgi容器来简单的部署flask以外，还有其他几种方式也可以选择：<a href="http://www.pythondoc.com/flask/deploying/mod_wsgi.html" target="_blank" rel="noopener">mod_wsgi</a>、<a href="http://www.pythondoc.com/flask/deploying/uwsgi.html" target="_blank" rel="noopener">uwsgi</a>、<a href="http://www.pythondoc.com/flask/deploying/fastcgi.html" target="_blank" rel="noopener">fastcgi</a>、<a href="http://www.pythondoc.com/flask/deploying/cgi.html" target="_blank" rel="noopener">cgi</a>。</p><h1 id="进程管理工具supervisor"><a href="#进程管理工具supervisor" class="headerlink" title="进程管理工具supervisor"></a>进程管理工具supervisor</h1><p>最近在找flask生产环境部署相关的内容，无意间碰到一个神器：<a href="http://supervisord.org/" target="_blank" rel="noopener">supervisord</a>。<br>它是一个使用python编写的进程管理工具，可以很方便的开启、关闭或者重启进程。当你的主机不小心挂掉的时候，通过配制好的supervisord可以很方便的重启服务而不用一行一行敲命令。要想使用supervisord，只需要这几步：</p><ul><li>第一步，当然还是安装：<code>sudo pip install supervisor</code></li><li>安装完成之后，主要的任务就是要完成配置文件：<code>echo_supervisord_conf &gt; /path/to/supervisord.conf</code>，先将supervisord的相关配置导出到指定路径以供修改；</li><li><p>下面主要修改我们比较关注的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[program:usercenter]</span><br><span class="line">directory = /home/leon/projects/usercenter ; 程序的启动目录</span><br><span class="line">command = gunicorn -c gunicorn.py wsgi:app  ; 启动命令，可以看出与手动在命令行启动的命令是一样的</span><br><span class="line">autostart = true     ; 在 supervisord 启动的时候也自动启动</span><br><span class="line">startsecs = 5        ; 启动 5 秒后没有异常退出，就当作已经正常启动了</span><br><span class="line">autorestart = true   ; 程序异常退出后自动重启</span><br><span class="line">startretries = 3     ; 启动失败自动重试次数，默认是 3</span><br><span class="line">user = leon          ; 用哪个用户启动</span><br><span class="line">redirect_stderr = true  ; 把 stderr 重定向到 stdout，默认 false</span><br><span class="line">stdout_logfile_maxbytes = 20MB  ; stdout 日志文件大小，默认 50MB</span><br><span class="line">stdout_logfile_backups = 20     ; stdout 日志文件备份数</span><br><span class="line">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span><br><span class="line">stdout_logfile = /data/logs/usercenter_stdout.log</span><br></pre></td></tr></table></figure></li><li><p>按照上边的内容，完成修改之后，比如说我的这个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[program:flask]</span><br><span class="line">command=python ./app/main/run.py</span><br><span class="line">[program:getmsg]</span><br><span class="line">command=python ./app/dataCollector/Collector/rocket.py</span><br></pre></td></tr></table></figure></li></ul><p>进入对应的目录，键入<code>supervisord -c manage.conf</code>就可以了</p><ul><li>接下来通过supervisorctl就可以查看当前进程运行的状态，启动或者关闭指定进程了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">→ supervisorctl -c  manage.conf</span><br><span class="line">flask                            RUNNING   pid 79541, uptime 4:43:15</span><br><span class="line">getmsg                           STOPPED   Dec 12 07:17 PM</span><br><span class="line">supervisor&gt; stop flask</span><br><span class="line">flask: stopped</span><br><span class="line">supervisor&gt; status</span><br><span class="line">flask                            STOPPED   Dec 12 09:43 PM</span><br><span class="line">getmsg                           STOPPED   Dec 12 07:17 PM</span><br></pre></td></tr></table></figure></li></ul><h1 id="crontab在python虚拟环境中的使用"><a href="#crontab在python虚拟环境中的使用" class="headerlink" title="crontab在python虚拟环境中的使用"></a>crontab在python虚拟环境中的使用</h1><p>使用python开发的同学往往会使用virtualenv来使自己的开发环境纯净不受干扰，我在使用过程中需要将一个python脚本通过crontab定期执行。在编写了对应的crontab配置文件之后，并没有按照预想的方式来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,15,30,45 * * * * python /home/eclipse/git/env/DouyuFan/app/dataCollector/Collector/allRooms.py</span><br></pre></td></tr></table></figure></p><p>感觉明明没有问题，可脚本为什么不执行呢，思考一下，由于是在虚拟环境中运行，直接通过python+脚本文件的方式，使用的python解译器是系统中的python而不是虚拟环境中的那个。所以上边的crontab配置改成这样就可以顺利运行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,15,30,45 * * * * /home/eclipse/git/env/bin/python /home/eclipse/git/env/DouyuFan/app/dataCollector/Collector/allRooms.py</span><br></pre></td></tr></table></figure></p><h1 id="关于python学习相关的想法"><a href="#关于python学习相关的想法" class="headerlink" title="关于python学习相关的想法"></a>关于python学习相关的想法</h1><p>由于自己缺乏在实际生产环境中的工作经验，这方面知识有很大一部分欠缺。只能通过自己慢慢摸索。另外，看了前几天刚买的python cookbook之后，感觉像是进入了python的新世界，有很多方法和内容都是之前没有尝试过的，未来要走的路还有很长，加油！</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>如何让你的代码更加pythonic</title>
      <link href="/2016/11/28/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E5%8A%A0pythonic/"/>
      <url>/2016/11/28/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9B%B4%E5%8A%A0pythonic/</url>
      
        <content type="html"><![CDATA[<p>对于开发者而言，代码风格是一件很重要的事情，它往往会关系到你代码的可读性甚至是执行效率。对于python而言，经常会在招聘要求中有一条：<strong>pythonic的代码</strong>。那究竟什么是pythonic，什么样的代码才是pythonic的代码，我自己也一直有让自己的代码更加pythonic，总结平时的工作学习就有了如下这些。<br><a id="more"></a></p><h1 id="为什么要让代码pythonic"><a href="#为什么要让代码pythonic" class="headerlink" title="为什么要让代码pythonic"></a>为什么要让代码pythonic</h1><p>在网上找到一些这方面的<a href="http://safehammad.com/downloads/python-idioms-2014-01-16.pdf" target="_blank" rel="noopener">资料</a>：</p><blockquote></blockquote><ul><li>Programs must be written for people to read, and only incidentally for machines to execute.</li><li>There should be one - and preferably only one - obvious way to do it.</li><li>The use of commonly understood syntax or coding constructs can aid readability and clarity.<br>Some idioms can be faster or use less memory than their “non-idiomatic” counterparts.<br>Python’s idioms can make your code Pythonic!</li></ul><p>如上所说，pythonic的代码会明显增加代码整体的可读性。并且，经过大家多年来的实际经验已经摸索出一些比较明确的规则来让代码pythonic。另外，pythonic的代码往往除了提高可读性以外会有更快的运行速度和更少的内存占用。</p><h1 id="pythonic的一些实践"><a href="#pythonic的一些实践" class="headerlink" title="pythonic的一些实践"></a>pythonic的一些实践</h1><h2 id="Make-a-script-both-importable-and-executable"><a href="#Make-a-script-both-importable-and-executable" class="headerlink" title="Make a script both importable and executable"></a>Make a script both importable and executable</h2><p>这里可以通过如下的示例来说明白：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># non-idiomatic</span><br><span class="line">def main():</span><br><span class="line">    print(&quot;now we&apos;re in module&quot;, __name__)</span><br><span class="line">   </span><br><span class="line">print(&apos;Excuted from the command line&apos;)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><p>对于上边这小段内容，如果它仅仅是单个存在的话，直接执行是没有问题的，但是当它被当作module在别的地方被import的话，main()函数会在被引入的时候自动执行。而通过在合适的位置添加<code>if __name__ == &#39;__main__&#39;:</code>判断，则可以更好的组织自己的代码。对于我自己来说，我可能在某个module中顺势写了一些测试方法，在被别的地方引入的时候，这些测试方法我不想让它执行，把它们放在判断语句之后会是一个不错的选择。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># pythonic</span><br><span class="line">def main():</span><br><span class="line">    print(&quot;now we&apos;re in module&quot;, __name__)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print(&apos;do some test&apos;)</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p><h2 id="Test-for-“truthy”-and-“falsy”-values"><a href="#Test-for-“truthy”-and-“falsy”-values" class="headerlink" title="Test for “truthy” and “falsy” values"></a>Test for “truthy” and “falsy” values</h2><p>python中关于真假值的判断，常用的集中类型可以参考这个表：</p><table><thead><tr><th>类型</th><th>TRUE</th><th>FALSE</th></tr></thead><tbody><tr><td>字符串</td><td>非空的字符串</td><td>空字符串</td></tr><tr><td>数字</td><td>非0</td><td>0</td></tr><tr><td>容器</td><td>len(x)!=0</td><td>len(x)=0</td></tr></tbody></table><p>如何判断真假值，则有一些常用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># pythonic</span><br><span class="line">name = &apos;Safe&apos;</span><br><span class="line">pets = [&apos;Dog&apos;, &apos;Cat&apos;, &apos;Hamster&apos;]</span><br><span class="line">owners = &#123;&apos;Safe&apos;: &apos;Cat&apos;, &apos;George&apos;: &apos;Dog&apos;&#125;</span><br><span class="line">if name and pets and owners:</span><br><span class="line">    print(&apos;We have pets!&apos;)</span><br><span class="line"># non-idiomatic</span><br><span class="line">if name != &apos;&apos; and len(pets) &gt; 0 and owners != &#123;&#125;:</span><br><span class="line">    print(&apos;We have pets!&apos;)</span><br></pre></td></tr></table></figure></p><h2 id="Use-in-where-possible"><a href="#Use-in-where-possible" class="headerlink" title="Use in where possible"></a>Use in where possible</h2><p>尽量使用in关键字来判断一个元素是否存在于一个容器中，这个容器可以是list，dict，set，string或者是你自己实现了<strong>contains</strong>方法的类。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># pythonic</span><br><span class="line">name = &apos;Safe Hammad&apos;</span><br><span class="line">if &apos;H&apos; in name:</span><br><span class="line">    print(&apos;This name has an H in it!&apos;)</span><br><span class="line"># non-idiomatic</span><br><span class="line">name = &apos;Safe Hammad&apos;</span><br><span class="line">if name.find(&apos;H&apos;) != -1:</span><br><span class="line">    print(&apos;This name has an H in it!&apos;)</span><br></pre></td></tr></table></figure></p><p>或者用in配合for来遍历一个序列，它可以是list，set，dict，string或者是你自己实现了<strong>iter</strong>方法的类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># pythonic</span><br><span class="line">pets = [&apos;Dog&apos;, &apos;Cat&apos;, &apos;Hamster&apos;]</span><br><span class="line">for pet in pets:</span><br><span class="line">    print(&apos;A&apos;, pet, &apos;can be very cute!&apos;)</span><br><span class="line"># non-idiomatic</span><br><span class="line">pets = [&apos;Dog&apos;, &apos;Cat&apos;, &apos;Hamster&apos;] i=0</span><br><span class="line">while i &lt; len(pets):</span><br><span class="line">    print(&apos;A&apos;, pets[i], &apos;can be very cute!&apos;)</span><br><span class="line">    i += 1</span><br></pre></td></tr></table></figure></p><h2 id="Swap-values-without-temp-variable"><a href="#Swap-values-without-temp-variable" class="headerlink" title="Swap values without temp variable"></a>Swap values without temp variable</h2><p>感觉这个特性很厉害（我自己用的很少，以后要多注意），可以通过一个简单的表达式交换两个元素的值，并且不需要中间变量的参与：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># pythonic</span><br><span class="line">a, b = 5, 6</span><br><span class="line">print(a, b)</span><br><span class="line">a, b = b, a</span><br><span class="line">print(a, b)</span><br><span class="line"># 5, 6 # 6, 5</span><br><span class="line"># 5, 6</span><br><span class="line"># non-idiomatic</span><br><span class="line">a, b = 5, 6</span><br><span class="line">print(a, b)</span><br><span class="line">temp = a a = b</span><br><span class="line">b = temp print(a, b)</span><br><span class="line"># 6, 5</span><br></pre></td></tr></table></figure></p><h2 id="Build-strings-using-sequence"><a href="#Build-strings-using-sequence" class="headerlink" title="Build strings using sequence"></a>Build strings using sequence</h2><p>在连接字符串的时候，通过str.join()方法耗用的时间是和传递给join方法的字符串长度线性相关的；而重复的使用‘+’来拼接字符串耗用的时间与字符串长度平方关系递增。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># pythonic</span><br><span class="line">chars = [&apos;S&apos;, &apos;a&apos;, &apos;f&apos;, &apos;e&apos;]</span><br><span class="line">name = &apos;&apos;.join(chars)</span><br><span class="line">print(name)           # Safe</span><br><span class="line"># non-idiomatic</span><br><span class="line">chars = [&apos;S&apos;, &apos;a&apos;, &apos;f&apos;, &apos;e&apos;]</span><br><span class="line">name = &apos;&apos;</span><br><span class="line">for char in chars:</span><br><span class="line">    name += char</span><br><span class="line">print(name)           # Safe</span><br></pre></td></tr></table></figure></p><h2 id="转换值类型的最佳实践"><a href="#转换值类型的最佳实践" class="headerlink" title="转换值类型的最佳实践"></a>转换值类型的最佳实践</h2><p>通过一个实例可以更好的说明这条原则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># pythonic</span><br><span class="line">d = &#123;&apos;x&apos;: &apos;5&apos;&#125;</span><br><span class="line">try:</span><br><span class="line">value = int(d[&apos;x&apos;])</span><br><span class="line">except (KeyError, TypeError, ValueError):</span><br><span class="line">value = None</span><br><span class="line"># non-idiomatic</span><br><span class="line">d = &#123;&apos;x&apos;: &apos;5&apos;&#125;</span><br><span class="line">if &apos;x&apos; in d and \</span><br><span class="line">   isinstance(d[&apos;x&apos;], str) and \</span><br><span class="line">   d[&apos;x&apos;].isdigit():</span><br><span class="line">    value = int(d[&apos;x&apos;])</span><br><span class="line">else:</span><br><span class="line">value = None</span><br></pre></td></tr></table></figure></p><p>在我自己的实际使用中，也经常会出现这种情况，通过网页抓去到的id号或者是商品的价格往往是str类型的，我想把它当作数字存在库里仅仅通过<code>value = int(strValue)</code>是很不安全的。而通过上述的方法可以以更安全的方法得到自己想要的结果。<br>另外，在python中抛出异常的代价对比与java这种要小很多。</p><h2 id="Enumerate"><a href="#Enumerate" class="headerlink" title="Enumerate"></a>Enumerate</h2><p>Enumerate 从python2.3引进，它多用于for循环中得到元素在容器中所在的位置，使用Enumerate可以有效的避免大量的<code>count += 1</code>这样的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># pythonic</span><br><span class="line">names = [&apos;Safe&apos;, &apos;George&apos;, &apos;Mildred&apos;]</span><br><span class="line">for i, name in enumerate(names):</span><br><span class="line">    print(i, name)   #  0 Safe, 1 George etc.</span><br><span class="line"># non-idiomatic</span><br><span class="line">names = [&apos;Safe&apos;, &apos;George&apos;, &apos;Mildred&apos;]</span><br><span class="line">count = 0</span><br><span class="line">for name in names:</span><br><span class="line">    print(i, name)   #  0 Safe, 1 George etc.</span><br><span class="line">    count += 1</span><br></pre></td></tr></table></figure></p><h2 id="Build-lists-using-list-comprehensions"><a href="#Build-lists-using-list-comprehensions" class="headerlink" title="Build lists using list comprehensions"></a>Build lists using list comprehensions</h2><p>更多的使用列表推导式来构建list，在通常情况下，列表推导式会比使用container.append(x)更加简洁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># pythonic</span><br><span class="line">data = [7, 20, 3, 15, 11]</span><br><span class="line">result = [i * 3 for i in data if i &gt; 10]</span><br><span class="line">print(result)   # [60, 45, 33]</span><br><span class="line"># non-idiomatic</span><br><span class="line">data = [7, 20, 3, 15, 11]</span><br><span class="line">result = []</span><br><span class="line">for i in data:</span><br><span class="line">    if i &gt; 10:</span><br><span class="line">        result.append(i * 3)</span><br><span class="line">print(result)   # [60, 45, 33]</span><br></pre></td></tr></table></figure></p><h2 id="Create-dict-from-keys-and-values-using-zip"><a href="#Create-dict-from-keys-and-values-using-zip" class="headerlink" title="Create dict from keys and values using zip"></a>Create dict from keys and values using zip</h2><p>如果想要将两个现有的list合并为键值对组合，通过zip方法会是一个不错的选择:<code>d = dict(zip(keys, values))</code><br>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># pythonic</span><br><span class="line">keys = [&apos;Safe&apos;, &apos;Bob&apos;, &apos;Thomas&apos;]</span><br><span class="line">values = [&apos;Hammad&apos;, &apos;Builder&apos;, &apos;Engine&apos;]</span><br><span class="line">d = dict(zip(keys, values))</span><br><span class="line">print(d)  # &#123;&apos;Bob&apos;: &apos;Builder&apos;,</span><br><span class="line">          #   &apos;Safe&apos;: &apos;Hammad&apos;,</span><br><span class="line">          #   &apos;Thomas&apos;: &apos;Engine&apos;&#125;</span><br><span class="line"># non-idiomatic</span><br><span class="line">keys = [&apos;Safe&apos;, &apos;Bob&apos;, &apos;Thomas&apos;]</span><br><span class="line">values = [&apos;Hammad&apos;, &apos;Builder&apos;, &apos;Engine&apos;]</span><br><span class="line">d = &#123;&#125;</span><br><span class="line">for i, key in enumerate(keys):</span><br><span class="line">    d[keys] = values[i]</span><br><span class="line">print(d)   # &#123;&apos;Bob&apos;: &apos;Builder&apos;,</span><br><span class="line">           #   &apos;Safe&apos;: &apos;Hammad&apos;,</span><br><span class="line">           #   &apos;Thomas&apos;: &apos;Engine&apos;&#125;</span><br></pre></td></tr></table></figure></p><h1 id="路漫漫而修远"><a href="#路漫漫而修远" class="headerlink" title="路漫漫而修远"></a>路漫漫而修远</h1><p>当然，上述的这些仅仅是冰山一角，在自己写代码的过程中应当尽量遵守这些准则，努力提高自己的代码质量。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
            <tag> pythonic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读Mongodb权威指南有感</title>
      <link href="/2016/11/25/%E8%AF%BBMongodb%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/"/>
      <url>/2016/11/25/%E8%AF%BBMongodb%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>由于之前从图书馆借的书已经到期了，前天下午趁着好天气去图书馆了一趟，顺便借回来两本<a href="https://book.douban.com/subject/25798102/" target="_blank" rel="noopener">《Mongodb权威指南》</a>和<a href="https://book.douban.com/subject/25856314/" target="_blank" rel="noopener">《Web性能权威指南》</a>。没想到两天时间就把前边那本看完了。总体感觉还不错，这本书写的比较细致，很适合入门学习，同时在看书的过程中，我发现了之前没有主要到的一些知识点，并且改变了我之前的一些错误认识，所以还是很有必要记录一下的。<br><a id="more"></a></p><h1 id="没注意到的点"><a href="#没注意到的点" class="headerlink" title="没注意到的点"></a>没注意到的点</h1><h2 id="TTL索引"><a href="#TTL索引" class="headerlink" title="TTL索引"></a>TTL索引</h2><p>TTL(time-to-live)索引在mongodb中主要起到的作用就是在指定时间里，如果一条记录都没有发生变化就会被自动移除，可以起到类似redis中EXPIRE命令的作用。它的用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在表col中为lastOp字段建立TTL索引，过期时间是60*60，单位为秒</span><br><span class="line">db.col.ensuerIndex(&#123;&apos;lastOp&apos;:1&#125;,&#123;&apos;expireAfterSecs&apos;:60*60&#125;)</span><br></pre></td></tr></table></figure></p><p>注意点：</p><ol><li>TTL索引必须建立在日期类型的字段上</li><li>TTL索引不能够是复合索引，但是如果建立了TTL索引，它可以在排序和查询中对检索速度有优化</li><li>在实际应用中，如果建立了这种索引，为防止删除正在进行的会话，可以在进行操作的过程中update这个字段</li></ol><h2 id="explain"><a href="#explain" class="headerlink" title="explain()"></a>explain()</h2><p>数据入了库，如何能够在最短的时间内检索出来是一个很重要的问题。在mongodb中，有各式各样的索引：最为普通的单字段索引、多个字段联合起来的复合索引、上边刚说到的TTL索引还有针对地理空间的地理空间索引。索引往往会对检索效率有质的提升，但是如何才能够知道自己建立的索引有没有起作用？explain()和hint()这两个方法可以给你一个答复。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"># 未建立索引</span><br><span class="line">&gt; db.Position.find(&#123;&apos;company&apos;:&apos;拉勾网&apos;&#125;).explain()</span><br><span class="line">&#123;</span><br><span class="line">&quot;queryPlanner&quot; : &#123;</span><br><span class="line">&quot;plannerVersion&quot; : 1,</span><br><span class="line">&quot;namespace&quot; : &quot;lagou.Position&quot;,</span><br><span class="line">&quot;indexFilterSet&quot; : false,</span><br><span class="line">&quot;parsedQuery&quot; : &#123;</span><br><span class="line">&quot;company&quot; : &#123;</span><br><span class="line">&quot;$eq&quot; : &quot;拉勾网&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;winningPlan&quot; : &#123;</span><br><span class="line">&quot;stage&quot; : &quot;COLLSCAN&quot;,</span><br><span class="line">&quot;filter&quot; : &#123;</span><br><span class="line">&quot;company&quot; : &#123;</span><br><span class="line">&quot;$eq&quot; : &quot;拉勾网&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;direction&quot; : &quot;forward&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;rejectedPlans&quot; : [ ]</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"># 索引之后</span><br><span class="line">&gt; db.Position.find(&#123;&apos;company&apos;:&apos;拉勾网&apos;&#125;).explain()</span><br><span class="line">&#123;</span><br><span class="line">&quot;queryPlanner&quot; : &#123;</span><br><span class="line">&quot;plannerVersion&quot; : 1,</span><br><span class="line">&quot;namespace&quot; : &quot;lagou.Position&quot;,</span><br><span class="line">&quot;indexFilterSet&quot; : false,</span><br><span class="line">&quot;parsedQuery&quot; : &#123;</span><br><span class="line">&quot;company&quot; : &#123;</span><br><span class="line">&quot;$eq&quot; : &quot;拉勾网&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;winningPlan&quot; : &#123;</span><br><span class="line">&quot;stage&quot; : &quot;FETCH&quot;,</span><br><span class="line">&quot;inputStage&quot; : &#123;</span><br><span class="line">&quot;stage&quot; : &quot;IXSCAN&quot;,</span><br><span class="line">&quot;keyPattern&quot; : &#123;</span><br><span class="line">&quot;company&quot; : 1</span><br><span class="line">&#125;,</span><br><span class="line">&quot;indexName&quot; : &quot;company_1&quot;,</span><br><span class="line">&quot;isMultiKey&quot; : false,</span><br><span class="line">&quot;multiKeyPaths&quot; : &#123;</span><br><span class="line">&quot;company&quot; : [ ]</span><br><span class="line">&#125;,</span><br><span class="line">&quot;isUnique&quot; : false,</span><br><span class="line">&quot;isSparse&quot; : false,</span><br><span class="line">&quot;isPartial&quot; : false,</span><br><span class="line">&quot;indexVersion&quot; : 2,</span><br><span class="line">&quot;direction&quot; : &quot;forward&quot;,</span><br><span class="line">&quot;indexBounds&quot; : &#123;</span><br><span class="line">&quot;company&quot; : [</span><br><span class="line">&quot;[\&quot;拉勾网\&quot;, \&quot;拉勾网\&quot;]&quot;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;rejectedPlans&quot; : [ ]</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，在建立索引前后，explain()的结果在”winningPlan”字段中有明显不同，未建立索引的时候：<code>&quot;stage&quot; : &quot;COLLSCAN&quot;</code>建立索引之后：<code>&quot;stage&quot; : &quot;IXSCAN&quot;</code>。前者的COLLSCAN表示的意思是通过全表扫描的方式检索，后边的则是通过已经建立的索引进行检索。<br>再来一例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 未建立索引</span><br><span class="line">&gt; db.Position.find(&#123;&apos;loc&apos;:&#123;$near:&#123;$geometry:&#123;type:&apos;Point&apos;,coordinates:[113,40]&#125;&#125;&#125;&#125;).explain()</span><br><span class="line">2016-11-25T14:13:23.421+0800 E QUERY    [main] Error: explain failed: &#123;</span><br><span class="line">&quot;ok&quot; : 0,</span><br><span class="line">&quot;errmsg&quot; : &quot;error processing query: ns=lagou.PositionTree: GEONEAR  field=loc maxdist=1.79769e+308 isNearSphere=0\nSort: &#123;&#125;\nProj: &#123;&#125;\n planner returned error: unable to find index for $geoNear query&quot;,</span><br><span class="line">&quot;code&quot; : 2,</span><br><span class="line">&quot;codeName&quot; : &quot;BadValue&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 建立索引</span><br><span class="line">&gt; db.Position.ensureIndex(&#123;loc:&apos;2dsphere&apos;&#125;)</span><br><span class="line">&#123;</span><br><span class="line">&quot;createdCollectionAutomatically&quot; : false,</span><br><span class="line">&quot;numIndexesBefore&quot; : 2,</span><br><span class="line">&quot;numIndexesAfter&quot; : 3,</span><br><span class="line">&quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line"># 索引之后</span><br><span class="line">&gt; db.Position.find(&#123;&apos;loc&apos;:&#123;$near:&#123;$geometry:&#123;type:&apos;Point&apos;,coordinates:[113,40]&#125;&#125;&#125;&#125;).explain()</span><br><span class="line">&#123;</span><br><span class="line">&quot;queryPlanner&quot; : &#123;</span><br><span class="line">...,</span><br><span class="line">&quot;winningPlan&quot; : &#123;</span><br><span class="line">&quot;stage&quot; : &quot;GEO_NEAR_2DSPHERE&quot;,</span><br><span class="line">&quot;keyPattern&quot; : &#123;</span><br><span class="line">&quot;loc&quot; : &quot;2dsphere&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;indexName&quot; : &quot;loc_2dsphere&quot;,</span><br><span class="line">&quot;indexVersion&quot; : 2</span><br><span class="line">&#125;,</span><br><span class="line">&quot;rejectedPlans&quot; : [ ]</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于之前一直只是停留在会用mongodb的阶段，像类似explain()这样的数据库调优的方法会用的比较少。现在的话感觉还是仔细研究关于mongodb的各个方面还是很有必要的。不能在使用的过程中只会有“啊！好特么快呀！”或者是“沃艸，怎么这么慢”的感性认识，知道如何让它变快才是重点。</p><h2 id="如何用索引"><a href="#如何用索引" class="headerlink" title="如何用索引"></a>如何用索引</h2><p>还记得当初曾经去南通封闭开发，遇到一个问题，由于在mongodb中一个集合存的数据过多，造成在检索的时候出现超时的情况。如果没有记错的话，我记得造成检索失败的原因是由于那个集合的大小超出了我笔记本的物理内存大小，通过普通的“全表扫描”的方法已经无法完成正常的检索。在建立了索引之后，数据量增大10倍检索速度也是杠杠的。<br>所以说，索引对于数据库来说是极其重要的，当然，这个东西我会在以后深入研究它的原理。在平常的使用过程中，对于一个集合，该不该建立索引，如何建立索引，都是很应该考虑的事情。</p><blockquote><p>索引通常适用的情况：在集合数据量较大的时候，同时经常需要查询的字段索引基数较大的情况。这里所说的索引基数指的是集合中某个字段拥有不同值的数量，一个字段的索引基数越高，在这个键上建立索引就越有用，这是因为索引能够快速地讲搜索范围缩小。另外，如果你需要进行地理空间方面的检索，2dsphere或者2d索引是必须的。</p></blockquote><h2 id="mongodb自带工具"><a href="#mongodb自带工具" class="headerlink" title="mongodb自带工具"></a>mongodb自带工具</h2><p>在各个版本的mongodb发行版中，bin目录下除了mongo和mongod其他几个工具也都很好用：<br>使用mongostat可以实时看到当前mongod实例的运行和负载情况，mongotop则类似linux系统中的top工具，mongofiles则可以很方便的操作数据库的gridfs。其他的各个工具相信在以后的使用中都会有接触。</p><h1 id="错误的认识"><a href="#错误的认识" class="headerlink" title="错误的认识"></a>错误的认识</h1><p>由于之前的实践比较少，也没有耐着性子仔细系统的学习mongodb，直到看了这本书才发现之前有很多理解是错的（并且我在用的时候还真的是这样干的），这部分错误认识主要集中在mongodb的副本集合分片那部分。</p><h2 id="关于副本集"><a href="#关于副本集" class="headerlink" title="关于副本集"></a>关于副本集</h2><p>之前总是想着副本集是用以缓解mongodb读写压力，进行读写分离用的，primary节点负责数据写入，各个secondary节点则从primary实时获取最新数据，并提供给应用程序读取数据的能力。仔细看了这本书之后，感觉之前真是很傻很天真，而且深切觉得这种分布式存储在实现过程中要考虑的东西是那么多。</p><blockquote><p>使用副本集可以将数据保存到多台服务器上，建议在所有的生产环境中都要使用。使用mongodb的副本集，即使一台或者多台服务器出错，也可以保证应用程序正常运行和数据安全。副本集是一组服务器，其中有一个主服务器primary，用于处理来自客户端的请求（当然是包括读和写），还有多个备份服务器secondary，用以保存主服务器的数据副本。如果主服务器崩溃，备份服务器会选举出一个成员将其升级为主服务器。</p></blockquote><p>其中最大的误解在与副本集成员数据同步的原理。如上边所说，我一直以为从节点的数据都是实时从主节点上读取到的，所以主节点负责写入数据，在写入的同时从节点复制数据（这样会给主节点造成较大的负载），所以从节点就来负责数据的读取吧。我完全都没意识到数据一致性的问题（对于数据时效性要求较高的情况）还有如果在写入负载大的时候，从节点还从主节点读取数据，主节点不就崩了吗。<br>而实际上副本集实现数据同步是这样的：</p><blockquote><p>副本集用以在多台服务器之间备份数据，mongodb的复制功能是通过操作日志oplog实现的，操作日志包含了主节点的每一次写操作。oplog是主节点的local数据库中的一个固定集合。备份节点通过查询这个集合就可以知道需要进行复制的操作。每个从节点都维护自己的oplog，记录每一次从主节点复制数据的操作，并且每个副本集成员都可以作为同步源提供给其他成员。</p></blockquote><h2 id="关于分片"><a href="#关于分片" class="headerlink" title="关于分片"></a>关于分片</h2><p>由于之前用到的数据量还没有大到必须使用分片的程度，这次看书也是对分片有了重新的认识。<br>分片主要用于将数据拆分，将数据分散存放到不同的机器上，mongodb支持自动分片，可以使数据库架构对应用程序不可见，简化系统管理。mongodb的分片允许你创建一个包含许多台机器的集群，也就是说上边所说的副本集可以作为分片的一个节点，每个分片用于维护一个数据集的子集。<br>分片可以带来的优势：</p><ul><li>增加可用RAM</li><li>增加可用磁盘空间</li><li>减轻单台服务器的负载</li><li>提升整个系统的吞吐量</li></ul><h1 id="一些其他的想法"><a href="#一些其他的想法" class="headerlink" title="一些其他的想法"></a>一些其他的想法</h1><p>到目前为止，最新的mongodb版本已经推出到3.4。mongodb的发展不能说不快，这款对开发者极其友好的数据库真的可以下功夫仔细学习、研究和使用。一些好的特性：除了相对高效的读写之外，Aggregation、map-reduce都可以应用在大数据处理上，官方提供的主流开发语言的驱动，和spark结合的connector在数据实时分析上也会有不错的效果。<br>而上边说到的这些东西，我想只有通过自己不断的实践练习才能在实际应用中游刃有余。</p>]]></content>
      
      
      <categories>
          
          <category> Mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书 </tag>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mongodb Aggregation Pipleline</title>
      <link href="/2016/11/23/mongodb_Aggregation/"/>
      <url>/2016/11/23/mongodb_Aggregation/</url>
      
        <content type="html"><![CDATA[<p>Mongodb作为目前最流行的nosql数据库之一，它给我们提供了海量数据的管理能力。而现在正处于大数据最为火热的时代，如何将海量的数据转化为可用的信息，这一步至关重要，面向应用而设计的mongodb在基础的数据分析上提供了aggregation这一功能，足以满足很多日常需求。<br><a id="more"></a></p><h1 id="管道（Aggregation-Pipeline）"><a href="#管道（Aggregation-Pipeline）" class="headerlink" title="管道（Aggregation Pipeline）"></a>管道（Aggregation Pipeline）</h1><p>在mongodb中，Aggregation的操作方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate( [ &#123; &lt;stage&gt; &#125;, ... ] )</span><br></pre></td></tr></table></figure></p><p>而其中的stage则是构成管道的每个部分，可以由一个或者多个stage来构成。管道是mongodb数据聚合的一个新框架，类似于数据处理的管道，或者说是像*nix系统中的管道。对于collection，由多个stage构成的管道能够实现分组、过滤等功能，文档每经过一个stage就过进行对应的操作并把操作结果输出给下一个stage。因此，构成管道的stage则至关重要，它能直接决定最终的处理结果。<br>每个stage由<strong>Stage Operators</strong>（管道操作符）和<strong>Expression Operators</strong>（管道表达式）构成。</p><h1 id="管道操作符"><a href="#管道操作符" class="headerlink" title="管道操作符"></a>管道操作符</h1><p>管道操作符，可以理解为每个stage你要对目标数据进行的操作，目前主要包括以下几种操作符：</p><h2 id="project"><a href="#project" class="headerlink" title="$project"></a>$project</h2><p>对于$project操作符来说，官方的解释是这样的：</p><blockquote><p>Reshapes each document in the stream, such as by adding new fields or removing existing fields. For each input document, outputs one document.</p></blockquote><p>也就是说，$project操作符能够完成增加、删除、重命名字段，控制流向下一个stage的数据组织形式。<br>以我抓去的拉勾网招聘数据为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 原始数据</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b3&quot;),</span><br><span class="line">&quot;category&quot; : &quot;技术&quot;,</span><br><span class="line">&quot;url&quot; : &quot;https://www.lagou.com/zhaopin/Java/&quot;,</span><br><span class="line">&quot;tag&quot; : &quot;后端开发&quot;,</span><br><span class="line">&quot;name&quot; : &quot;Java&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 聚合方法</span><br><span class="line">db.Category.aggregate(&#123;$project:&#123;category:1,链接:&quot;$url&quot;,分类:&#123;tag:&quot;$tag&quot;,name:&quot;$name&quot;&#125;&#125;&#125;)</span><br><span class="line"># 输出结果</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b3&quot;),</span><br><span class="line">&quot;category&quot; : &quot;技术&quot;,</span><br><span class="line">&quot;链接&quot; : &quot;https://www.lagou.com/zhaopin/Java/&quot;,</span><br><span class="line">&quot;分类&quot; : &#123;</span><br><span class="line">&quot;tag&quot; : &quot;后端开发&quot;,</span><br><span class="line">&quot;name&quot; : &quot;Java&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="match"><a href="#match" class="headerlink" title="$match"></a>$match</h2><blockquote><p>Filters the document stream to allow only matching documents to pass unmodified into the next pipeline stage. $match uses standard MongoDB queries. For each input document, outputs either one document (a match) or zero documents (no match).</p></blockquote><p>$match运算符，用于筛选出符合目标条件的数据传给下一个stage。它的用法和普通的find()类似，以下例来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># find()查询</span><br><span class="line">db.Category.find(&#123;category:&quot;技术&quot;&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b3&quot;),</span><br><span class="line">&quot;category&quot; : &quot;技术&quot;,</span><br><span class="line">&quot;url&quot; : &quot;https://www.lagou.com/zhaopin/Java/&quot;,</span><br><span class="line">&quot;tag&quot; : &quot;后端开发&quot;,</span><br><span class="line">&quot;name&quot; : &quot;Java&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 聚合方法</span><br><span class="line">db.Category.aggregate(&#123;$match:&#123;category:&quot;技术&quot;&#125;&#125;)</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b3&quot;),</span><br><span class="line">&quot;category&quot; : &quot;技术&quot;,</span><br><span class="line">&quot;url&quot; : &quot;https://www.lagou.com/zhaopin/Java/&quot;,</span><br><span class="line">&quot;tag&quot; : &quot;后端开发&quot;,</span><br><span class="line">&quot;name&quot; : &quot;Java&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="limit"><a href="#limit" class="headerlink" title="$limit"></a>$limit</h2><blockquote><p>Passes the first n documents unmodified to the pipeline where n is the specified limit. For each input document, outputs either one document (for the first n documents) or zero documents (after the first n documents).</p></blockquote><p>与普通查询类似，limit用以限制输出文档数量，在aggregtion中的使用方式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 常规查询</span><br><span class="line">&gt; db.Category.find(&#123;category:&quot;技术&quot;&#125;).limit(3).pretty()</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b3&quot;),</span><br><span class="line">&quot;category&quot; : &quot;技术&quot;,</span><br><span class="line">&quot;url&quot; : &quot;https://www.lagou.com/zhaopin/Java/&quot;,</span><br><span class="line">&quot;tag&quot; : &quot;后端开发&quot;,</span><br><span class="line">&quot;name&quot; : &quot;Java&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b4&quot;),</span><br><span class="line">&quot;category&quot; : &quot;技术&quot;,</span><br><span class="line">&quot;url&quot; : &quot;https://www.lagou.com/zhaopin/Python/&quot;,</span><br><span class="line">&quot;tag&quot; : &quot;后端开发&quot;,</span><br><span class="line">&quot;name&quot; : &quot;Python&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b5&quot;),</span><br><span class="line">&quot;category&quot; : &quot;技术&quot;,</span><br><span class="line">&quot;url&quot; : &quot;https://www.lagou.com/zhaopin/PHP/&quot;,</span><br><span class="line">&quot;tag&quot; : &quot;后端开发&quot;,</span><br><span class="line">&quot;name&quot; : &quot;PHP&quot;</span><br><span class="line">&#125;</span><br><span class="line"># aggregation</span><br><span class="line">&gt; db.Category.aggregate(&#123;$limit:3&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b3&quot;),</span><br><span class="line">&quot;category&quot; : &quot;技术&quot;,</span><br><span class="line">&quot;url&quot; : &quot;https://www.lagou.com/zhaopin/Java/&quot;,</span><br><span class="line">&quot;tag&quot; : &quot;后端开发&quot;,</span><br><span class="line">&quot;name&quot; : &quot;Java&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b4&quot;),</span><br><span class="line">&quot;category&quot; : &quot;技术&quot;,</span><br><span class="line">&quot;url&quot; : &quot;https://www.lagou.com/zhaopin/Python/&quot;,</span><br><span class="line">&quot;tag&quot; : &quot;后端开发&quot;,</span><br><span class="line">&quot;name&quot; : &quot;Python&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b5&quot;),</span><br><span class="line">&quot;category&quot; : &quot;技术&quot;,</span><br><span class="line">&quot;url&quot; : &quot;https://www.lagou.com/zhaopin/PHP/&quot;,</span><br><span class="line">&quot;tag&quot; : &quot;后端开发&quot;,</span><br><span class="line">&quot;name&quot; : &quot;PHP&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="skip"><a href="#skip" class="headerlink" title="$skip"></a>$skip</h2><blockquote><p>Skips the first n documents where n is the specified skip number and passes the remaining documents unmodified to the pipeline. For each input document, outputs either zero documents (for the first n documents) or one document (if after the first n documents).</p></blockquote><p>skip也是一个很常用的操作，用以跳过输入文档前n个文档之后进行下一步操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 常规全表扫描</span><br><span class="line">&gt; db.Category.find().skip(1).limit(1)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b4&quot;), &quot;category&quot; : &quot;技术&quot;, &quot;url&quot; : &quot;https://www.lagou.com/zhaopin/Python/&quot;, &quot;tag&quot; : &quot;后端开发&quot;, &quot;name&quot; : &quot;Python&quot; &#125;</span><br><span class="line">&gt; db.Category.find().limit(1)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b3&quot;), &quot;category&quot; : &quot;技术&quot;, &quot;url&quot; : &quot;https://www.lagou.com/zhaopin/Java/&quot;, &quot;tag&quot; : &quot;后端开发&quot;, &quot;name&quot; : &quot;Java&quot; &#125;</span><br><span class="line"># aggregation操作</span><br><span class="line">&gt; db.Category.aggregate(&#123;$limit:1&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b3&quot;), &quot;category&quot; : &quot;技术&quot;, &quot;url&quot; : &quot;https://www.lagou.com/zhaopin/Java/&quot;, &quot;tag&quot; : &quot;后端开发&quot;, &quot;name&quot; : &quot;Java&quot; &#125;</span><br><span class="line">&gt; db.Category.aggregate(&#123;$skip:1&#125;,&#123;$limit:1&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b4&quot;), &quot;category&quot; : &quot;技术&quot;, &quot;url&quot; : &quot;https://www.lagou.com/zhaopin/Python/&quot;, &quot;tag&quot; : &quot;后端开发&quot;, &quot;name&quot; : &quot;Python&quot; &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，同样是limit(1)，在增加了skip操作之后，返回的结果是不相同的。</p><h2 id="lookup"><a href="#lookup" class="headerlink" title="$lookup"></a>$lookup</h2><blockquote><p>Performs a left outer join to another collection in the same database to filter in documents from the “joined” collection for processing.</p></blockquote><p>可以看到，$lookup的作用就是进行一个类似sql中left join的操作，而每个lookup操作需要有四个参数传入：</p><ul><li>from 确定要进行lookup的集合名，该集合必须与当前进行aggregate操作的集合在同一个库中，并且不能分片</li><li>localField 制定要进行操作的列名，用以和下边通过from确定的集合中foreignField指定的列名进行匹配</li><li>foreignField 指定由from确定的集合要进行lookup操作的列名</li><li>as 两个集合匹配完成之后，在当前结合中添加的一列</li></ul><p>通过下例来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.Position.aggregate(&#123;$lookup:&#123;from:&quot;Category&quot;,localField:&quot;name&quot;,foreignField:&quot;name&quot;,as:&quot;jobInfo&quot;&#125;&#125;,&#123;$skip:1&#125;,&#123;$limit:1&#125;).pretty()</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;582ee2b6b7f3d15abcf7174c&quot;),</span><br><span class="line">&quot;positionid&quot; : 2342819,</span><br><span class="line">&quot;salary&quot; : &quot;8k-15k&quot;,</span><br><span class="line">&quot;name&quot; : &quot;Java&quot;,</span><br><span class="line">&quot;detailUR&quot; : &quot;https://www.lagou.com/jobs/2342819.html&quot;,</span><br><span class="line">&quot;companyid&quot; : 25439,</span><br><span class="line">&quot;company&quot; : &quot;Udesk－企业级智能客服平台&quot;,</span><br><span class="line">&quot;experience&quot; : &quot;经验1-3年&quot;,</span><br><span class="line">&quot;tag&quot; : &quot;后端开发&quot;,</span><br><span class="line">&quot;address&quot; : &quot;西直门南大街2号成铭大厦C座16层（西直门地铁站C口）&quot;,</span><br><span class="line">&quot;category&quot; : &quot;技术&quot;,</span><br><span class="line">&quot;loc&quot; : &#123;</span><br><span class="line">&quot;type&quot; : &quot;Point&quot;,</span><br><span class="line">&quot;coordinates&quot; : [</span><br><span class="line">116.35735297,</span><br><span class="line">39.93921106</span><br><span class="line">]</span><br><span class="line">&#125;,</span><br><span class="line">&quot;jobInfo&quot; : [</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;582ee2a0b7f3d15aaebf35b3&quot;),</span><br><span class="line">&quot;category&quot; : &quot;技术&quot;,</span><br><span class="line">&quot;url&quot; : &quot;https://www.lagou.com/zhaopin/Java/&quot;,</span><br><span class="line">&quot;tag&quot; : &quot;后端开发&quot;,</span><br><span class="line">&quot;name&quot; : &quot;Java&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，通过name字段将Category和Position两个集合关联起来，并且Category中对应的数据在输出中以jobInfo表示。</p><h2 id="group"><a href="#group" class="headerlink" title="$group"></a>$group</h2><blockquote><p>Groups input documents by a specified identifier expression and applies the accumulator expression(s), if specified, to each group. Consumes all input documents and outputs one document per each distinct group. The output documents only contain the identifier field and, if specified, accumulated fields.</p></blockquote><p>$group也是一个sql中常用的操作符，它可以很方便的按照字段来进行一些统计工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.Position.aggregate(&#123;$group:&#123;_id:&quot;$name&quot;,count:&#123;$sum:1&#125;&#125;&#125;)</span><br><span class="line">&#123; &quot;_id&quot; : &quot;游戏制作人&quot;, &quot;count&quot; : 343 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;产品总监&quot;, &quot;count&quot; : 90 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;产品部经理&quot;, &quot;count&quot; : 53 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;网页产品设计师&quot;, &quot;count&quot; : 4 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;产品实习生&quot;, &quot;count&quot; : 13 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;游戏策划&quot;, &quot;count&quot; : 291 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;电商产品经理&quot;, &quot;count&quot; : 301 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;数据产品经理&quot;, &quot;count&quot; : 450 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;产品助理&quot;, &quot;count&quot; : 65 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;移动产品经理&quot;, &quot;count&quot; : 18 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;BI工程师&quot;, &quot;count&quot; : 9 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;售前工程师&quot;, &quot;count&quot; : 9 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;硬件开发其它&quot;, &quot;count&quot; : 450 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;射频工程师&quot;, &quot;count&quot; : 60 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;热传导&quot;, &quot;count&quot; : 2 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;模具设计&quot;, &quot;count&quot; : 11 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;DSP开发&quot;, &quot;count&quot; : 6 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;企业软件其它&quot;, &quot;count&quot; : 21 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;系统集成&quot;, &quot;count&quot; : 110 &#125;</span><br><span class="line">&#123; &quot;_id&quot; : &quot;驱动开发&quot;, &quot;count&quot; : 129 &#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，在进行$group操作的时候，必须要指定一个_id的字段名，并且这个操作都是在内存中进行，如果数据量很大的时候需要额外的参数（将会在以后的文章中提到）。</p><h2 id="其他的操作符"><a href="#其他的操作符" class="headerlink" title="其他的操作符"></a>其他的操作符</h2><p>上述几个是用的比较多的几个。其他的操作符还有$unwind、$sample、$sort、$indexStats、$out等。在以后使用中如果遇到的话在来这更新。</p><h1 id="管道表达式"><a href="#管道表达式" class="headerlink" title="管道表达式"></a>管道表达式</h1><p>上边的几个例子已经有所体现，就是说，在进行aggreagtion的时候，每个stage都是由一个管道表达式作为动词，按照对应的限制进行操作，而管道表达式则可以构成丰富的操作限制，从而得到想要的结果，其中$group操作符中的$sum则是众多管道表达式中的一个。<br>而跟多的管道表达式可以参考<a href="https://docs.mongodb.com/v3.2/reference/operator/aggregation/" target="_blank" rel="noopener">这里</a>了解。</p><h1 id="mongodb-campass"><a href="#mongodb-campass" class="headerlink" title="mongodb campass"></a>mongodb campass</h1><p>通过mongodb自身的aggregation操作，合理使用管道表达式和管道操作符可以完成大量的分析统计工作，这里不得不得说一下mongodb官方提供的数据库可视化工具<strong><a href="https://www.mongodb.com/download-center?jmp=docs#compass" target="_blank" rel="noopener">mongodb compass</a></strong>。有了这个工具（有windows和mac版本），感觉其他的可视化工具都弱爆了，强烈推荐！</p>]]></content>
      
      
      <categories>
          
          <category> mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
            <tag> aggregation </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python基础知识</title>
      <link href="/2016/11/16/python%E5%9F%BA%E7%A1%80/"/>
      <url>/2016/11/16/python%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>最近回顾一下python相关的知识点，主要内容会包括一些常用库文档的关键内容（重温一遍加深记忆），一些重要的关键字，pythonic代码风格注意的内容等等。这些重要的内容会持续更新。<br><a id="more"></a></p><h1 id="requests中文文档"><a href="#requests中文文档" class="headerlink" title="requests中文文档"></a>requests中文文档</h1><ol><li>通过<code>import requests</code>引入requests包；</li><li>requests提供了各种http动词操作方式：包括’get’,’post’,’put’,’delete’,’head’和’options’；</li><li><p>正常情况下，通过浏览器访问，要传递给服务器的参数可能会通过url中?之后的键值对的形式进行，在request中，可以将这些键值对以python字典的形式传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">params = &#123;&apos;x&apos;:&apos;1&apos;,&apos;y&apos;:&apos;2&apos;&#125;</span><br><span class="line">requests.get(&apos;https://eclipsesv.com&apos;,params = parmas)</span><br></pre></td></tr></table></figure></li><li><p>通过requests获取到的服务器返回内容可以通过这些方式来获取：<br><strong>正常情况下</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(&apos;https://eclipsesv.com&apos;)</span><br><span class="line">print response.text  #这样可以得到requests自动解码后的服务器内容</span><br></pre></td></tr></table></figure></li></ol><p>通过<code>response.encoding</code>可以获取到当前的requests编码方式。<br><strong>二进制响应内容</strong>：<br>除了上述的text方法获取服务器内容，通过<code>response.content</code>也可以获取到二进制形式的服务器内容，以图片为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">from io import BytesIO</span><br><span class="line">img = Image.open(BytesIO(response.content))</span><br></pre></td></tr></table></figure></p><p><strong>json格式响应内容</strong><br>requests中内置有一个json解码器，通过一下方式可以获取到来自服务器的json内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(&apos;http://xxxxx&apos;)</span><br><span class="line">jsonValue = response.json()</span><br></pre></td></tr></table></figure></p><p><strong>原始响应内容</strong><br>这种方式目前还不知道能干啥，用于获取来自服务器的原始套接字响应，通过<code>response.raw</code>来获取。</p><ol start="5"><li>请求头定制<br>如果需要定制请求的header，只需要按照requests规定的形式传一个字典给headers即可。类似这样子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">host = &quot;http://www.douyu.com&quot;</span><br><span class="line">agent = &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.86 Safari/537.36&apos;</span><br><span class="line">accept = &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;</span><br><span class="line">connection = &quot;keep-alive&quot;</span><br><span class="line">CacheControl = &quot;no-cache&quot;</span><br><span class="line">UpgradeInsecureRequests = 1</span><br><span class="line">headers = &#123;</span><br><span class="line">    &apos;User-Agent&apos;: agent,</span><br><span class="line">    &apos;Host&apos;: HOST,</span><br><span class="line">    &apos;Accept&apos;: accept,</span><br><span class="line">    &apos;Cache-Control&apos;: CacheControl,</span><br><span class="line">    &apos;Connection&apos;: connection,</span><br><span class="line">    &apos;Upgrade-InsecureRequests&apos;: UpgradeInsecureRequests</span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(url,headers=headers)</span><br></pre></td></tr></table></figure></li></ol><p>这样就可以了，这招在爬取网站数据的时候会很常用。</p><ol start="6"><li>响应状态码和请求头<br>通过<code>response.status_code</code>即可获取到来自服务器的反馈状态码；<br>通过<code>response.headers</code>即可得到目前请求的请求头是怎样的。</li><li>cookie<br>与设置headers类似，将想要伪造的cookie按照字典的形式在请求中加入即可<code>requests.get(url,cookies=cookies)</code>。</li><li>超时设置<br>通过设置requests的timeout在指定的秒数之后停止等待服务器<code>requests.get(url,timeout=0.1)</code>，这里所说的等待时间是指在timeout时间内服务器没有任何响应则会触发异常，而不是整个请求的耗时。</li><li>另外一些高级用法（主要是和session相关的内容）可以参考<a href="http://docs.python-requests.org/zh_CN/latest/user/advanced.html#advanced" target="_blank" rel="noopener">这里</a>。</li></ol><h1 id="bs4-中文文档"><a href="#bs4-中文文档" class="headerlink" title="bs4 中文文档"></a>bs4 中文文档</h1><p>bs4可以从html或是xml中提取数据，对于bs4而言，比较重要的是四种对象的类型：<strong>Tag , NavigableString , BeautifulSoup , Comment</strong>。</p><h2 id="四种类型"><a href="#四种类型" class="headerlink" title="四种类型"></a>四种类型</h2><ol><li><strong>Tag</strong>：<br>这里的tag与xml或是html中原生文档的tag相同，tag有两个重要的属性name和attribute。每个tag都有名字，通过.name可以获取到tag的名字<code>tag.name</code>，attribute则是tag的属性，tag的属性操作类似于字典：<code>tag[&#39;class&#39;]或是tag[&#39;id&#39;]</code>这样的，也可直接通过tag.attrs获取到一个装载tag属性的字典。某些时候，tag某个属性可能有多个值，比如class、rel等，这个时候，通过’tag[‘class’]’获取到的则是一个list列表。</li><li><strong>NavigableString</strong><br>这里的NavigableString可以认为是tag中的字符串，比如<code>&lt;p&gt;hello world&lt;/p&gt;</code>，此处的hello world即是NavigableString。要想获取到NavigableString，可以通过tag.string来获取，直接获取到的内容可以通过unicode(tag.string)来转换为unicode。另外，NavigableString不可以编辑，但是可以通过replace_with()方法来替换。</li><li><strong>BeautifulSoup</strong><br>BeautifulSoup表示的是整个文档的全部内容，通过BeautifulSoup(response.text)即可生成BeautifulSoup对象。</li><li><strong>Comment</strong><br>html或是xml文档中，注释部分很常见，而在BeautifulSoup中，注释则是以Comment的形式存在。</li></ol><h2 id="find-amp-select"><a href="#find-amp-select" class="headerlink" title="find&amp;select"></a>find&amp;select</h2><p>对于我来说，BeautifulSoup最常用的就是解析html文件，所以这次还是捡重点来，了解到上述的几种类型之后就可以通过find或者是select来找到自己想要的页面内容并把它们结构化存储到数据库中。</p><ol><li><strong>过滤器</strong><br>在这之前还得好好看看过滤器：过滤器可以用在tag，name，节点的属性，字符串以及它们的混合中。<br>字符串过滤器：是最简单的过滤器，在搜索方法中传入一个字符串参数，比如要搜索所有的<code>&lt;img&gt;</code>标签<code>soup.find_all(&#39;img&#39;)</code>；<br>正则表达式过滤器：传入正则表达式作为参数，通过match()来匹配内容，比如找出所有以b开头的标签<code>soup.find_all(re.compile(&quot;^b&quot;))</code>；<br>列表过滤器：将列表作为参数传入，返回与列表中匹配的任一元素，比如要找多所有<code>&lt;a&gt;,&lt;b&gt;</code>标签：<code>soup.find_all([&quot;a&quot;,&quot;b&quot;])</code>；<br>方法过滤器：这个就变态了，如果没有合适的过滤器，可以自己来改造，写一个方法，返回true表示当前元素满足条件，如果不满足返回false，比如如下的方法表示如果包含class属性同时不包含id属性，则返回true：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def has_class_not_id(tag):</span><br><span class="line">return tag.has_attr(&apos;class&apos;) and not tag.has_attr(&apos;id&apos;)</span><br></pre></td></tr></table></figure></li></ol><p>然后将这个方法传给find_all()，就可以获取到满足上述条件的tag:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(has_class_not_id)</span><br></pre></td></tr></table></figure></p><ol start="2"><li><strong>find_all(name , attrs , recursive , text , **kwargs)</strong><br>刚又重新看了一遍关于find_all()的说明，发现之前没怎么用这个方法真是个失误啊！<br>name参数：查找所有名字为name的tag，搜索name参数的值可以使用任一上述类型的过滤器；<br>attrs参数：如果想要通过tag的属性来查找，可以通过这样的形式；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(id=&apos;link2&apos;)    #直接查找id为目标值的tag</span><br><span class="line">soup.find_all(href=re.compile(&quot;elsie&quot;))    #通过正则表达式查找</span><br><span class="line">soup.find_all(id=True)    #用true查找，拥有id属性的tag</span><br><span class="line">soup.find_all(href=re.compile(&quot;elsie&quot;), id=&apos;link1&apos;)    #多个属性同时查找</span><br><span class="line">data_soup.find_all(attrs=&#123;&quot;data-foo&quot;: &quot;value&quot;&#125;)    #某些html5属性不能直接查询的时候可以通过这样的形式查找</span><br></pre></td></tr></table></figure></li></ol><p>text参数：通过text参数可以搜索文档中字符串内容。同样text接受各种过滤器。<br>limit参数：find_all()方法会返回全部的搜索内容，通过limit可以限制返回数量<code>soup.find_all(&quot;a&quot;, limit=2)</code>；<br>recursive参数：find_all()方法默认会检索当前tag所有子节点以及孙节点，如果只想搜索tag直接的子节点的话可以通过设置recursive值来加以限制<code>soup.html.find_all(&quot;title&quot;, recursive=False)</code>recursive=true；<br>另外，可以通过css样式查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.find_all(&quot;a&quot;, class_=&quot;sister&quot;)    #由于class是python关键字，所以class变为class_</span><br><span class="line">soup.find_all(class_=re.compile(&quot;itl&quot;))</span><br></pre></td></tr></table></figure></p><p>总之，通过class来查询的方法也可以使用各种不同的过滤器。</p><ol start="3"><li><strong>select方法</strong><br>select()主要通过文档的css样式进行选择：<br>通过tag标签逐层查找：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">soup.select(&quot;title&quot;)</span><br><span class="line"># [&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;]</span><br><span class="line">soup.select(&quot;p nth-of-type(3)&quot;)</span><br><span class="line"># [&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</span><br></pre></td></tr></table></figure></li></ol><p>通过某个tag标签下的直接子标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.select(&quot;head &gt; title&quot;)</span><br><span class="line"># [&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;]</span><br></pre></td></tr></table></figure></p><p>查找兄弟节点标签(这个地方没看太懂，还需要回头再看)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">soup.select(&quot;#link1 ~ .sister&quot;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot;  id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span><br><span class="line">soup.select(&quot;#link1 + .sister&quot;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span><br></pre></td></tr></table></figure></p><p>通过css类名查找:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">soup.select(&quot;.sister&quot;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span><br></pre></td></tr></table></figure></p><p>通过tag的id查找：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soup.select(&quot;#link1&quot;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span><br></pre></td></tr></table></figure></p><p>通过检索是否存在某个属性来查找：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">soup.select(&apos;a[href]&apos;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span><br></pre></td></tr></table></figure></p><p>通过属性值来查找：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">soup.select(&apos;a[href=&quot;http://example.com/elsie&quot;]&apos;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span><br><span class="line">soup.select(&apos;a[href^=&quot;http://example.com/&quot;]&apos;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span><br><span class="line">soup.select(&apos;a[href$=&quot;tillie&quot;]&apos;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span><br><span class="line">soup.select(&apos;a[href*=&quot;.com/el&quot;]&apos;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> requests </tag>
            
            <tag> bs4 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows下hexo+github搭建个人博客</title>
      <link href="/2016/11/06/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2016/11/06/hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>之前自己的博客也是托管在github上，但是访问速度有时候欠佳，并且缺少个人定制的感觉，所以就放在了自己的云主机上，周末恰巧有个机会让我重新温习一下hexo在github上托管的过程。<br><a id="more"></a></p><h1 id="所需软件"><a href="#所需软件" class="headerlink" title="所需软件"></a>所需软件</h1><p>要完成博客的搭建，大致需要这些内容：</p><ul><li>已完成邮件激活的github账号（如果未激活无法使用github的pages，也就无法让github托管）</li><li><a href="https://git-scm.com/downloads/" target="_blank" rel="noopener">git客户端</a></li><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodejs</a>（因为hexo是由node驱动的）</li><li><a href="http://pad.haroopress.com/" target="_blank" rel="noopener">Haroopad</a>，各个操作系统都有对应的版本</li></ul><h1 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h1><h2 id="github的相关配置"><a href="#github的相关配置" class="headerlink" title="github的相关配置"></a>github的相关配置</h2><ol><li>你要申请一个github账号，并且用邮箱激活；</li><li>创建一个repo，名称<strong>必须</strong>按照这样的格式：username.github.io，也就是说，如果你的用户名是wangerdan，那创建的项目名称就必须是wangerdan.github.io；</li><li>把你电脑的公钥上传到github的ssh key列表中，具体操作可参考<a href="http://blog.csdn.net/houyp520/article/details/9401745" target="_blank" rel="noopener">这篇</a>，这样做的原因是等下hexo推送需要使用ssh模式连接github；</li></ol><h2 id="其他软件安装"><a href="#其他软件安装" class="headerlink" title="其他软件安装"></a>其他软件安装</h2><p>包括git客户端，nodejs还有Haroopad这三个，都是一路next就可以了。</p><h2 id="hexo安装和配置以及推送"><a href="#hexo安装和配置以及推送" class="headerlink" title="hexo安装和配置以及推送"></a>hexo安装和配置以及推送</h2><ol><li><p>hexo-cli：之前安装好了git客户端之后，在文件夹中右键会有gitBash选项，找个文件夹，比如说文件夹叫blog，进入之后，打开gitbash，键入：<code>npm install -g hexo-cli</code>，就会自动完成安装；</p></li><li><p>安装完成hexo-cli之后，键入<code>hexo init</code>会完成博客的初始化，顺便<code>npm install</code>，完成安装；</p></li><li><p>可以先测试一下，键入<code>hexo server</code>，打开浏览器，访问localhost:4000看是否有初始的页面；</p></li><li><p>如果上述步骤都正常完成，现在需要做的就是把博客内容推送到github上，键入<code>npm install hexo-deployer-git --save</code>，安装deploy组件；</p></li><li><p>安装完成后，修改刚才blog文件夹里边的_config.yml文件，把下边一段改成你自己的即可；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:username/username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>推送博客：完成上述内容之后，通过命令<code>hexo deploy</code>就可以把当前的内容推送到github上，通过<a href="https://username.github.io/" target="_blank" rel="noopener">https://username.github.io/</a> 这个链接就可以访问了。</p></li></ol><h1 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h1><p><a href="http://www.tuicool.com/articles/ueI7naV" target="_blank" rel="noopener">hexo的操作方法</a><br><a href="https://git-scm.com/book/zh/v1/%E8%B5%B7%E6%AD%A5" target="_blank" rel="noopener">git学习</a><br><a href="https://segmentfault.com/markdown" target="_blank" rel="noopener">markdown语法</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十月</title>
      <link href="/2016/10/31/%E5%8D%81%E6%9C%88/"/>
      <url>/2016/10/31/%E5%8D%81%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<p>对比去年的这个时候，自己每天疲于奔命，参加各种笔试、面试，经历了一次次希望、失望。而现在的我坐在洒满阳光的屋子里，听着陈奕迅的歌，状态也是好到爆（当然这得益于30号晚上表白成功，现在想想都怀疑是不是在做梦呢）。<br>不知不觉已经工作了三个月，想借这篇博客记录一下十月份的一些事情。</p><p>记东西，依旧是流水账，这样以后看起来也能想得清楚。<br><a id="more"></a></p><h1 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h1><p>哈哈哈，第一周当然是十一假期啦，因为好久都没完整过完整整七天的十一长假，并且好久也没再秋天的时候回家。所以经过了长达两周的刷票之后终于买到了30号晚上回家的卧铺。因为一直都想自己攒一台电脑，正好赶上这个假期，那就在家搞机吧。2号在京东上买的所有配件就到齐了，挽起袖子开干。由于是第一次组装机器，到3号凌晨才弄妥。<br>剩下几天就是出去溜达，最有意思的还是陪好朋友一起去丈量新房（他过年就要结婚了，我也能当个伴郎沾沾喜气）。比较遗憾的就是只陪爸妈一起出去逛了一次公园。<br>七天一晃就过去了，7号下午坐车返程，没想到现在高铁也有那么多无座的票，带了两个行李箱的我只好被挤在车门口。</p><h1 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h1><p>节前领导就布置了任务，让做一个全景地图项目，第二周主要是查找相关的资料和可用的软件。由于之前也没弄过这东西，进度稍微有点慢（其实主要还是自己偷懒了）。找到目前大家做全景用的比较多的一款软件<a href="http://krpano.com/" target="_blank" rel="noopener">Krpano</a>，相关的国内参考网站<a href="http://www.krpano360.com/" target="_blank" rel="noopener">Krpano中文网</a>。一个处理全景照片的软件<a href="http://www.ptgui.com/download.html" target="_blank" rel="noopener">PTGUI</a>。用这俩东西和单位给的一些数据初步做了一些全景场景，了解了krpano的运行机理。对全景地图项目有了初步的技术路线构想：无非就是把全景场景和地图关联起来，而全景场景也都是由静态图片构成的，所以处理好全景场景控制、全景照片存储和读取已经他们和地理位置的关联就可以了。<br>当然不能不提第二周愉快的周末时光，从这周开始，每周末都和小伙伴们一起守望开黑（开黑吗？我麦克雷贼6）。</p><h1 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h1><p>想通了大致的技术路线，这周主要是尝试把整个流程走通，并且有了如下这个技术流程图。<br><img src="https://eclipsesv.com/pics/%E6%8A%80%E6%9C%AF%E6%B5%81%E7%A8%8B.png?attname=" alt="技术流程.png"><br>其中的一些细节：</p><ul><li>全景照片经过加工可以生成对应的全景瓦片以及拍摄点位坐标信息</li><li>瓦片是更多照片的集合，大量的全景照片生成的瓦片仅仅通过文件夹难以管理，结合点位信息将生成的瓦片直接导入到MongoDB中；</li><li>MongoDB+Nginx可以提供一个高性能的瓦片服务器，点位矢量图可以通过适当的缓冲区分析生成对应的全景覆盖范围（点位缓冲矢量图）；</li><li>Flask作为一个web开发框架，可以有效处理来自前端的数据访问；</li><li>GeoServer可以将生成的点位缓冲区矢量图发布生成wms服务提供调用；</li><li>天地图提供的api作为地图底图，Krpano.js用以在浏览器中生成全景场景，plugin.js是通过自己开发加入全景场景的插件（可以提供诸如鹰眼、雷达功能）。</li></ul><h1 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h1><p>有了技术路线，想清楚了具体的实现细节，并且上周已经初步完成了各个模块之间的串联。这周主要是写代码，用代码批量完成大规模全景照片的场景生成，提取全景照片的空间信息，完成全景瓦片的入库，全景服务器代码的编写，krpano插件以及前端post数据的js。另外就是处理矢量数据，用geoserver发地图热点范围wms。<br>整个流程基本上算是用上了我现在的整套技术栈，感觉还不错。</p><h1 id="另外一些事情"><a href="#另外一些事情" class="headerlink" title="另外一些事情"></a>另外一些事情</h1><p>目前全景地图整个技术流程可以走通，但是还有一些细节问题：场景初始角度、热点链接位置、鹰眼地图上视线范围等等。<br>最近在学习<a href="http://leafletjs.com/" target="_blank" rel="noopener">leaflet</a>，也接触到<a href="https://www.mapbox.com" target="_blank" rel="noopener">Mapbox</a>，三哥说想做个应用，我也是好久没写自己的项目了，俩人一起搞可能不会那么boring，所以那就好好搞啦。<br>周日，QQ推送健康消息，看到上周总共就走了1W多步，以后每天下午下班都要去锻炼才行啦（大哥你得多运动啊）。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flask </tag>
            
            <tag> mongodb </tag>
            
            <tag> krpano </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>菜鸟在springboot使用中遇到的问题和解决方法</title>
      <link href="/2016/09/21/%E8%8F%9C%E9%B8%9F%E5%9C%A8springboot%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2016/09/21/%E8%8F%9C%E9%B8%9F%E5%9C%A8springboot%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>人的惰性真是可怕啊！<br>差不多从中秋以来，都一直处于偷懒的状态，基本上没学习什么新东西，这都要归功于暴雪家的魔兽世界和守望先锋了。玩了这么久，是该总结下这段时间遇到的问题和已经找到的解决方法了，省的以后再遇到这些问题。</p><a id="more"></a><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>前段时间，领导让学习java并尝试做一个用户管理模块，使用cas管理用户登陆。由于之前也是没做过这类东西，所以在这个过程中主要遇到的问题有这些：</p><ol><li>cas服务器的配置；</li><li>集成cas客户端到springboot中；</li><li>如何使用springboot默认的模版<a href="http://www.thymeleaf.org/" target="_blank" rel="noopener">thymeleaf</a>；</li><li>前端数据如何传给服务器端；</li><li>服务器端在接受不同类型数据的时候，如何做出响应的处理，获取前端传送的数据；</li><li>后端发送的数据传给前端，如何通过模版来表现。</li></ol><p>大致归纳起来就是这些，由于是java新手，虽然之前接触过mvc类型的框架，但是在面对这些问题的时候，还是会出这样那样的问题。</p><h1 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h1><p>上边的这些问题，有的甚至花费了我一天的时间，详细的记录这些问题已经解决方法对之后的学习肯定会有帮助。</p><h2 id="cas服务器的配置方法"><a href="#cas服务器的配置方法" class="headerlink" title="cas服务器的配置方法"></a>cas服务器的配置方法</h2><p>在我看来，cas可以当做是类似譬如数据库一样提供服务的东西，而它的作用则是为系统模块提供单点登录功能。各个系统模块通过集成cas客户端，并完成响应的配置即可实现用户登录管理。<br>要想模块获得单点登录功能，第一步要先完成自己tomcat对https的支持：</p><h3 id="1-tomcat的https配置方法"><a href="#1-tomcat的https配置方法" class="headerlink" title="1.tomcat的https配置方法"></a>1.tomcat的https配置方法</h3><p>这一步操作可以参考网上相关教程，比较多，我参考的主要是<a href="http://www.cnblogs.com/richaaaard/p/5035812.html" target="_blank" rel="noopener">这个</a>，特别要注意的是，在配置秘钥的时候，输入名字和姓氏、组织单位和组织的时候，一定要配置成自己的服务器域名。<br>比如我在自己的hosts文件中增加了一条<code>127.0.0.1 cas.eclipsesv.com</code>，我在本地进行测试，就把上边要配置的内容写成cas.eclipsesv.com。<br>另外要注意的就是在配置过程中一定要细心，注意字母大小写，文件路径这些东西。</p><h3 id="2-获取cas-server"><a href="#2-获取cas-server" class="headerlink" title="2.获取cas server"></a>2.获取cas server</h3><p>在完成https配置之后从cas官网上下载完整的cas server，地址在<a href="http://developer.jasig.org/cas/cas-server-4.0.0-release.zip" target="_blank" rel="noopener">这里</a>；<br>完成下载之后，解压压缩包，将modules文件夹中的cas-server-webapp-4.0.0.war复制出来，放在配置好的tomcat的webapp文件夹中。<br>这个时候，cas就算差不多配置完成了。</p><h3 id="3-自定义cas-server"><a href="#3-自定义cas-server" class="headerlink" title="3.自定义cas server"></a>3.自定义cas server</h3><p>默认的cas server只能按照配置文件中的用户名和密码进行登录，并且登录页面和登出页面都是cas官方提供的，自己如果要用的话肯定是要改改的。</p><p>我们学习过程中用的是oralce数据库，所以要给cas server提供访问oracle的能力，从数据库中读取用户名和密码。<br>完成这一步需要做两个操作，在cas的lib文件夹中增加commons-pool-1.5.7、commons-dbcp-1.4、ojdbc6这三个jar包；</p><p>另外就是在tomcat/webapps/cas/文件夹中的deployerConfigContext.xml中增加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;casDataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;</span><br><span class="line">   &lt;property name=&quot;driverClassName&quot;&gt;</span><br><span class="line">     &lt;value&gt;oracle.jdbc.driver.OracleDriver&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property name=&quot;url&quot;&gt;</span><br><span class="line">     &lt;value&gt;jdbc:oracle:thin:@10.211.55.17:1521:xe&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;    </span><br><span class="line">   &lt;property name=&quot;username&quot;&gt;</span><br><span class="line">     &lt;value&gt;wangmeng&lt;/value&gt;    </span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">   &lt;property name=&quot;password&quot;&gt;</span><br><span class="line">     &lt;value&gt;abc123&lt;/value&gt;</span><br><span class="line">   &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;primaryAuthenticationHandler&quot; </span><br><span class="line">    class=&quot;org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;casDataSource&quot; /&gt;</span><br><span class="line">    &lt;property name=&quot;sql&quot; value=&quot;select PASSWORD from USERS where USER_NAME = ?&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>其中上边的bean中是关于数据库的连接，包括数据库ip、端口和实例名以及登录用户名和密码；后边一个bean中则是关于操作用户表的内容，以及查询语句。</p><p>另外，如果要自定义cas serveer的默认登录和登出页面，可以在cas文件夹中的WEB-INF/view/jsp/default/ui/中完成修改，casLogoutView.jsp是登出页面，casLoginView.jsp是登录页面。</p><p>经过以上三步操作cas server配置基本就可以完成了。</p><h2 id="springboot集成cas"><a href="#springboot集成cas" class="headerlink" title="springboot集成cas"></a>springboot集成cas</h2><p>在这里，我使用的是Shiro，并主要参考了这两篇博客，<a href="http://blog.csdn.net/catoop/article/details/50534006" target="_blank" rel="noopener">spring boot集成shiro和cas</a>和<a href="http://howiefh.github.io/2015/05/19/shiro-cas-single-sign-on/" target="_blank" rel="noopener">Shiro &amp; CAS 实现单点登录</a>。按照这两篇博客中讲的内容就可以把cas客户端即成到springboot中了。</p><h2 id="thymeleaf模版的使用"><a href="#thymeleaf模版的使用" class="headerlink" title="thymeleaf模版的使用"></a>thymeleaf模版的使用</h2><p>thymeleaf 是springboot 默认使用的模版，在官网上可以找到比较丰富的文档，讲的还是比较好的。我在使用中主要用到了后端传对象给thymeleaf进行渲染，thymeleaf循环、判断这些很基本的功能。打算这周参考官方文档再系统的过一遍它的其它功能。</p><h2 id="前端post数据给后端"><a href="#前端post数据给后端" class="headerlink" title="前端post数据给后端"></a>前端post数据给后端</h2><p>在这个小模块的开发过程中，前端post数据我主要是用两种方式，form表单提交和ajax传输。</p><h3 id="form表单结合thymeleaf"><a href="#form表单结合thymeleaf" class="headerlink" title="form表单结合thymeleaf"></a>form表单结合thymeleaf</h3><p>由于使用了thymeleaf模版，因此表单提交的方法变得更加简便：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method=&quot;POST&quot; th:action=&quot;@&#123;&apos;/newDiscussion/&apos;+$&#123;groupid.groupID&#125;&#125;&quot; th:object=&quot;$&#123;newDiscuss&#125;&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;form-group&quot;&gt; </span><br><span class="line">        &lt;label for=&quot;groupname&quot;&gt;讨论组名&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; th:field=&quot;*&#123;discussionName&#125;&quot; class=&quot;form-control&quot; id=&quot;groupname&quot;&gt;&lt;/input&gt;</span><br><span class="line">        &lt;label for=&quot;desc&quot;&gt;描述&lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; th:field=&quot;*&#123;desc&#125;&quot; class=&quot;form-control&quot; id=&quot;desc&quot;&gt;&lt;/input&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>以上述代码为例，该表单是填写信件讨论组相关的内容，我需要做的只是在对应的input中完成newDiscuss对象discussionName、desc属性的填写即可完成。而newDiscuss对象是怎么来的，将会在后边有详细解释。</p><h3 id="ajax数据传输"><a href="#ajax数据传输" class="headerlink" title="ajax数据传输"></a>ajax数据传输</h3><p>除了form表单，我可能需要在点击某个按钮之后将某些东西post给后端，并做出响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function sendData()&#123;</span><br><span class="line">    var addusers = [];</span><br><span class="line">    uniqueGroup = $(&quot;h2[name=&apos;uniqueGroup&apos;]&quot;).attr(&quot;id&quot;);</span><br><span class="line">    addusers.push(uniqueGroup);</span><br><span class="line">    $(&quot;input[type=&apos;checkbox&apos;]&quot;).each(</span><br><span class="line">                    function() &#123;</span><br><span class="line">                        if($(this)[0].checked==true)</span><br><span class="line">                        &#123;</span><br><span class="line">                            userid = ($(this).attr(&quot;id&quot;));</span><br><span class="line">                            addusers.push(userid);</span><br><span class="line">                        &#125;     </span><br><span class="line">                    &#125;</span><br><span class="line">                );</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url:&quot;http://cas.eclipsesv.com:9000/group/adduser&quot;,</span><br><span class="line">        data:JSON.stringify(addusers),</span><br><span class="line">        type:&quot;post&quot;,</span><br><span class="line">        contentType: &quot;application/json; charset=utf-8&quot;,</span><br><span class="line">        dataType:&quot;json&quot;,</span><br><span class="line">        success:function(responseText)&#123;</span><br><span class="line">                $(&apos;#myModal&apos;).modal(&apos;hide&apos;);</span><br><span class="line">                var groupid = responseText.redirect;</span><br><span class="line">                    var url = &quot;http://cas.eclipsesv.com:9000/group/&quot;+groupid;</span><br><span class="line">                    window.location.href = url</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是要完成将一个由用户id组成的数组post给后端，并在数据传输成功之后将页面重定向。</p><h2 id="后端如何解析来自前端的数据"><a href="#后端如何解析来自前端的数据" class="headerlink" title="后端如何解析来自前端的数据"></a>后端如何解析来自前端的数据</h2><p>对应上述前端post数据方法，springboot也有对应的数据解析方法：</p><h3 id="解析form表单提交的数据"><a href="#解析form表单提交的数据" class="headerlink" title="解析form表单提交的数据"></a>解析form表单提交的数据</h3><p>刚才提到，前端在提交form表单的时候，只需要完成newDiscuss对应属性的填写即可，而这个newDiscuss对象则是我在form表单页面中通过模版嵌入的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/group/&#123;groupid&#125;&quot;,method = RequestMethod.GET)</span><br><span class="line">public String group(@PathVariable String groupid,Model model)&#123;</span><br><span class="line">    DiscussionGroup discussionGroup = new DiscussionGroup();</span><br><span class="line">    model.addAttribute(&quot;newDiscuss&quot;, discussionGroup);</span><br><span class="line">    return &quot;group&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前端get此页面的时候，new一个DiscussionGroup对象，在模版中用newDiscuss代表它，这样就可以在前端填写表单的时候完成newDiscuss属性的设置。</p><p>在完成属性填写之后，后端解析数据通过以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/newDiscussion/&#123;groupid&#125;&quot;,method = RequestMethod.POST)</span><br><span class="line">public String newDiscussion(@PathVariable String groupid,ModelMap model, DiscussionGroup discussionGroup)&#123;</span><br><span class="line">    if (discussionGroup != null) &#123;</span><br><span class="line">        System.out.print(groupid);</span><br><span class="line">    &#125;</span><br><span class="line">    ControllerHelper helper = new ControllerHelper(userDAOImpl, groupUserDAOImpl, groupDAOImpl,</span><br><span class="line">            discussionDAOImpl,commentDAOImpl);</span><br><span class="line">    helper.newDiscussionGroup(discussionGroup,helper.getCurrentUser().getUserId(),groupid);</span><br><span class="line">    return &quot;redirect:/group/&quot;+groupid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在函数签名中对应写一个DiscussionGroup对象，用以接受刚刚的newDiscuss，就是这样简单。需要额外做的就是在DiscussionGroup中完成相应属性的getter和setter以及默认构造函数。</p><h3 id="解析ajax提交的数据"><a href="#解析ajax提交的数据" class="headerlink" title="解析ajax提交的数据"></a>解析ajax提交的数据</h3><p>不同于上边form表单提交那样，接受ajax传输的数据需要按照下边这样来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/comments/delete&quot;,method = RequestMethod.POST)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Map&lt;String, String&gt;  delComment(@RequestBody String[] userArray)&#123;</span><br><span class="line">    ControllerHelper helper = new ControllerHelper(userDAOImpl, groupUserDAOImpl, groupDAOImpl,</span><br><span class="line">            discussionDAOImpl,commentDAOImpl);</span><br><span class="line">    if (userArray[0] != null) &#123;</span><br><span class="line">        String groupid = helper.delComment(userArray[0]);</span><br><span class="line">        System.out.println(userArray[0]+&quot;评论已删除&quot;);</span><br><span class="line">        Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;();</span><br><span class="line">        result.put(&quot;redirect&quot;, groupid);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要用到@ResponseBody注解，并且这次返回给前端的数据也不是具体的某个view名，而是实实在在的数据，比如说一个键值对，而返回的数据可以在ajax的sucess中处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">success:function(responseText)&#123;</span><br><span class="line">    $(&apos;#myModal&apos;).modal(&apos;hide&apos;);</span><br><span class="line">    var groupid = responseText.redirect;</span><br><span class="line">        var url = &quot;http://cas.eclipsesv.com:9000/group/&quot;+groupid;</span><br><span class="line">        window.location.href = url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>上边写的都是作为一个入门菜鸟在学习过程中遇到的问题和一些稚嫩的解决方法，后边会遇到更复杂的问题，我也会一如即往的记录自己的成长过程。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>想要走出舒适区</title>
      <link href="/2016/08/26/%E6%83%B3%E8%A6%81%E8%B5%B0%E5%87%BA%E8%88%92%E9%80%82%E5%8C%BA/"/>
      <url>/2016/08/26/%E6%83%B3%E8%A6%81%E8%B5%B0%E5%87%BA%E8%88%92%E9%80%82%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="工作一个月的感受"><a href="#工作一个月的感受" class="headerlink" title="工作一个月的感受"></a>工作一个月的感受</h1><p>到今天为止，已经入职一个月了，没想到时间过的这么快，想想这个月的生活，我好像已经快要适应现在的生活节奏了。<br><a id="more"></a><br>现在是晚上11点46分，和大脸刀了一晚，室友在看着手机准备睡觉，但是我有点睡不着，我快要适应的这种生活和我想象的还是不太一样，现在有点太过舒适了。住在单位的单身公寓，办公室和住室就在一层，两步就到。早上八点半到十一点半，中间休息到两点半，下午五点半又下班了。不用忍受拥挤的地铁，不用为上班迟到害怕，没有老板在边上监视你的一举一动，没有让人难以忍受的工作压力。<br>第一个月，由于没有具体的工作任务，领导只是说现在让学习，那就暂且总结一下这个月我都学到了什么。</p><h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><p>刚来第一周，被发配到办公楼，没有网络，没有工作任务。</p><ul><li>我也是只好继续做之前的python小项目，完善了抓取斗鱼网站数据的功能。把内容都总结道hack on douyu 系列的博客里边。</li><li>另外就是学了一下arcgis官方提供的python库，感觉以后工作应该会用到。</li><li>另外就是又重新看了一遍redis设计与实现这本书，对redis作者高超技艺的崇拜之感又增加了不少。</li></ul><h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><p>这周开始逐渐暂停了douyu项目的更新，想用之前学到的东西真正用起来，想要用flask重写自己的博客。</p><ul><li>学会了使用blueprint来灵活扩展flask</li><li>学会使用wtform来写页面</li><li>另外oauth登录方式也做了一些了解，并作了Github和Battlenet的oauth登录</li><li>重新看了mongodb官方文档，尤其是data aggrigation方面的东西</li></ul><p>本打算用battlenet的api来获取一下国服的数据，谁知道特么的网易不开发国服数据。初步了解了一下github提供的api功能。<br>另外就是出去出了两天差，感受了下这边的工作状态。</p><h2 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h2><p>这周领导回来了，说让学习java，买了java核心技术大致看了一遍，回顾了oop的内容，这周其实主要是看书，另外就是看spring官网的guide，配置java开发环境。周末去河北省图书馆逛了一趟，借了两本书。以后有时间还是要多去图书馆。</p><h2 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h2><p>就是这周了，java核心技术看完之后，主要是动手操作。学会了使用maven创建java项目，利用springboot的便利作了一个在线聊天室。这周的工作主要是和之前学习的flask类比，了解了spring中mvc各方面如何构建，如何走通整个流程。<br>另外就是在前端方面又仔细学习了一下，主要是bootstrap。<br>另外不得不提的是，周二去看了一直想看的《谍影重重5》，电影不错，就是晃得很。。。</p><h1 id="日子怎么过"><a href="#日子怎么过" class="headerlink" title="日子怎么过"></a>日子怎么过</h1><p>这四周就这样过来了，我想如果是要在公司的话，肯定是不会有这样多的时间用来学习，不过一个月下来之后，感受有两个：</p><ol><li>学习内容不够多</li><li>学习动力不足</li></ol><p>java现在可以说是入了门，但是没有实际项目来做，感觉比较虚，我得有个想法，自己先操练起来。python的话，感觉基础知识掌握的差不多，带的两本书要尽快看完。<br>另外，之后的工作效率要有所提升，要自己加压，把时间放在学习上，利用这段宝贵的时间提升自我价值。<br>好了，现在有点困了，睡了睡了。<br>噢，对了，秋天来了，我最喜欢的北方的秋天。加油吧！</p>]]></content>
      
      
      <categories>
          
          <category> 心情文字 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用IDEA和maven快速搭建SpringBoot项目</title>
      <link href="/2016/08/25/springboot/"/>
      <url>/2016/08/25/springboot/</url>
      
        <content type="html"><![CDATA[<p>由于单位项目使用java开发，框架用的spring，之前一直觉得java特别麻烦，所以一直避免和java接触，这下跑不掉了。所以近两周一直在学习java。在此记录一下学习过程，和下一步学习计划。<br><a id="more"></a></p><h1 id="书籍和文档"><a href="#书籍和文档" class="headerlink" title="书籍和文档"></a>书籍和文档</h1><p>一般情况下，如果我对某个技术感兴趣的话，我会先去找这方面比较经典的书，找了网上的评价之后，发现<a href="https://book.douban.com/subject/3146174/" target="_blank" rel="noopener">Java核心技术</a>这本书比较不错，果断买来。</p><p>第一周记本上都在看书，也是在再次对OOP有了重新的认识。看过书之后，准备再学习一下spring，网上看了参考资料并不是很多，不过我看spring官网上的<a href="https://spring.io/guides" target="_blank" rel="noopener">guide</a>很不错，可以参考着撸一遍。另外就是一个<a href="http://websystique.com/spring-4-mvc-tutorial/" target="_blank" rel="noopener">教程</a>，关于spring mvc的。</p><h1 id="搞起"><a href="#搞起" class="headerlink" title="搞起"></a>搞起</h1><p>有了书和文档的帮助之后，自然要实际操作起来才行。在操作之前我也是看了不少相关的帖子，最后选则IDEA来开发，而springboot更是极大的减少了java开发的复杂程度，减少了大量的xml配置文件。下面就详细介绍如何使用IDEA配合maven快速搭建一个springboot程序吧。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p>使用IDEA新建maven项目：<br><img src="https://eclipsesv.com/pics/%E6%96%B0%E5%BB%BAmaven.png" alt="新建maven项目"><br>选择maven，勾选archetype，选择maven-archetype-webapp。然后完成一些设置就可以进入到项目文件了。</p><h2 id="maven源设置"><a href="#maven源设置" class="headerlink" title="maven源设置"></a>maven源设置</h2><p>有过用maven管理项目经验的都知道，使用maven默认的源速度特别慢，经常是写代码的时间还没等待jar包下载的时间长。经过我的一番搜索发现阿里云提供的maven源在国内还是比较优质的。需要做的很简单，只需要在IDEA中稍微修改一下settings文件即可。<br>右键pom.xml文件，选择maven选项，点击打开settings.xml，在其中增加如下这段配置文件保存即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">        &lt;mirror&gt;</span><br><span class="line">            &lt;id&gt;nexus-aliyun&lt;/id&gt;</span><br><span class="line">            &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">            &lt;name&gt;Nexus aliyun&lt;/name&gt;</span><br><span class="line">            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">        &lt;/mirror&gt;</span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure><p>效果就是这样<img src="https://eclipsesv.com/pics/settings.png" alt="settings.xml">。</p><h2 id="依赖项导入"><a href="#依赖项导入" class="headerlink" title="依赖项导入"></a>依赖项导入</h2><p>利用springboot进行开发webapp，我在使用中需要导入这些依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-thymeleaf --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.4.0.RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>由于配置了maven源，这些依赖项下载速度还是挺快的。</p><h2 id="码码码"><a href="#码码码" class="headerlink" title="码码码"></a>码码码</h2><p>配置好这些东西之后，就可以码起来了。首先要在src文件夹下新建一个目录作为Soucres Root：<br><img src="https://eclipsesv.com/pics/source.png" alt="Sources Root"><br>在这里，我把java作为Soucres Root，由于使用了springboot，只需要用java代码写好controller即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.eclipsesv.HelloController;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by eclipse on 16/8/26.</span><br><span class="line"> */</span><br><span class="line">@Controller</span><br><span class="line">public class Hello &#123;</span><br><span class="line">    @RequestMapping(&quot;/&quot;)</span><br><span class="line">    public String index()&#123;</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@Controller和@RequestMapping配合使用就可以完成一个简单的路由映射，上边的这段代表如果访问url为”/“会返回名为”index”的视图，而这里的视图只需要写一个名为index的html 并把它放在/resources/templates中即可。<br>然后只需要写一个main函数就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.eclipsesv;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by eclipse on 16/8/26.</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String... arg)&#123;</span><br><span class="line">        SpringApplication.run(Application.class,arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@SpringBootApplication可以完成项目的自动配置，它会在启动的时候找到项目中由@Controller标识的区域，并解析@RequestMapping完成自动路由映射。<br>现在整个项目结构如下图所示：</p><p><img src="https://eclipsesv.com/pics/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="项目结构"></p><h2 id="run起来"><a href="#run起来" class="headerlink" title="run起来"></a>run起来</h2><p>在完成这些之后，需要做一下项目的启动配置，如图：<br><img src="https://eclipsesv.com/pics/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE.png" alt="启动配置"><br>然后直接点run就可以了。</p><p><img src="https://eclipsesv.com/pics/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-26%20%E4%B8%8A%E5%8D%889.18.22.png" alt="运行效果"></p><p>整个过程除了pox.xml需要自己配置以外，并不需要另外的配置项，大大简化了项目配置的复杂程度。感觉还是不错的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis设计与实现笔记（复制）</title>
      <link href="/2016/08/08/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
      <url>/2016/08/08/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>使用命令slaveof <host> <port> 来实现一个redis-server复制另一个redis-server，其中发出此命令的server为从服务器另一个成为主服务器。<br>另外，可以通过配置文件redis.conf来实现上述命令的功能：</port></host></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><hr><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>在redis中，复制的实现主要通过两个步骤：同步和命令传播。</p><ol><li><p>同步(sync)</p><p> 同步的过程细分为一下几个过程：</p><ul><li>从服务器(slave)向主服务器(master)发送SYNC命令；</li><li>master接收到SYNC命令之后，执行BGSAVE，后台生成RDB文件；</li><li>BGSAVE完成后，master将RDB文件发送给slave，slave接收到RDB文件之后，将自身状态同步至master执行BGSAVE时候的状态；</li><li>master将纪录在缓存区中的命令发送给slave，slave执行那些命令，完成主从状态同步。</li></ul></li><li><p>命令传播(command propagate)</p><p> 在同步操作完成之后，主从达到一致，后续阶段主从之间的一致状态通过命令传播来完成。</p></li></ol><hr><h2 id="完全同步和部分同步"><a href="#完全同步和部分同步" class="headerlink" title="完全同步和部分同步"></a>完全同步和部分同步</h2><p>我们知道，master在执行BGSAVE命令之后，会消耗大量的服务器资源用以生成RDB文件，如果服务器中已经有较多的键值，不仅完成BGSAVE命令耗时长，生成的RDB文件也会相对较大，通过网络将RDB文件发送给slave也会占用大量的网络资源。</p><p>如果说一个slave之前没有进行过复制操作，它完全的同步master数据还情有可原，但如果一个slave在复制过程中由于各种原因中断了和master的连接，明明已经复制了很多内容在完成重连之后还要从头开始，于情于理都说不过去。</p><p>于是，在Redis2.8版本之后，同步操作由PSYNC替代之前的SYNC，同步操作细分为完全同步(full resynchronization)和部分同步(partial resynchronization)。部分同步的出现就是为了避免重复同步大量slave已经同步过了的数据。为了实现部分同步，Redis设计了三个变量来进行控制：</p><ol><li>复制偏移量(replication offset)</li></ol><pre><code>复制偏移量是master和slave都会维护的一个量，当master向slave传播n个字节数据时，master的复制偏移量会增加n，相应的，slave在接到来自master的n个字节之后，slave的复制偏移量也会增加n，通过对比master和slave的复制偏移量可以很容易得知主从是否达到一致状态；</code></pre><ol start="2"><li><p>复制积压缓冲区(replication backlog)</p><p> 复制积压缓冲区是master维护的一个定长的先进先出队列，默认大小为1mb，可以通过配置文件中repl-backlog-size来修改。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Set the replication backlog size. The backlog is a buffer that accumulates</span><br><span class="line"># slave data when slaves are disconnected for some time, so that when a slave</span><br><span class="line"># wants to reconnect again, often a full resync is not needed, but a partial</span><br><span class="line"># resync is enough, just passing the portion of data the slave missed while</span><br><span class="line"># disconnected.</span><br><span class="line">#</span><br><span class="line"># The bigger the replication backlog, the longer the time the slave can be</span><br><span class="line"># disconnected and later be able to perform a partial resynchronization.</span><br><span class="line">#</span><br><span class="line"># The backlog is only allocated once there is at least a slave connected.</span><br><span class="line">#</span><br><span class="line"># repl-backlog-size 1mb</span><br></pre></td></tr></table></figure><p> 复制积压缓冲区的运行机理是这样的：</p><p> master在将命令传播给slave的时候，也会将这些命令写入到复制积压缓冲区中，并记录每个字节在复制偏移量，在断线重连的slave向master发出PSYNC进行同步的时候，slave会将自身的复制偏移量offset一并发出，master则将slave的offset在复制积压缓冲区中查找，看看它是否存在，如果存在的话则执行部分同步，否则执行完全同步。</p></li><li><p>服务器运行ID(run ID)</p><p> 每个Redis服务器，无论是master还是slave它们在启动的时候都会有一个由40个随机十六进制字符组成的运行ID。在进行初次复制的时候，master会将自身的run ID发送给slave，slave保存此值，在断线重连的时候，通过对比当前master的run ID是否和之前的相同来选择尝试部分同步还是完全同步。</p></li></ol><hr><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>以host同为127.0.0.1端口号分别为6379、6380的两个Redis实例的复制过程为例：<br>其中6379为master、6380为slave。</p><ol><li><p>使用redis-cli连接slave：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -p 6380</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>在slave的客户端上执行命令：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF 127.0.0.1 6379</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>slave将127.0.0.1和6379分别保存到服务器状态masterhost和masterport属性里边，master向slave的客户端返回OK，表示复制命令已经接收，真正的复制操作开始</p></li><li><p>建立套接字：</p><p> 在SLAVEOF 命令执行之后slave根据masterhost和masterport创建连向master的套接字，完成套接字创建之后，slave为这个套接字关联一个专门用于复制工作的文件事件处理器，负责后续的复制工作(包括接收RDB文件、后续master传来的写命令等)；</p><p> 在master一端，接收到slave的套接字连接之后，master讲其看作是一个连接到主服务器的客户端看待。</p></li><li><p>slave成为master之后，首先向master发送PING命令，用以检测slave和master之间的套接字读写状态是否正常，同时也可以监测master能否正常响应命令。如果master正常返回PONG作为响应，则可以进行下一步的操作，否则slave将会断开与master的连接并重新连接。</p></li><li><p>身份认证：在slave接收到master的PONG返回之后，下一步要尽心的则是完成身份认证。</p><ul><li>如果master没有设置requirepass选项，并且slave也没有设置masterauth选项，那么master讲继续执行slave发送的命令，复制工作可以正常进行</li><li>如果从服务器设置的masterauth与master的requirepass一致，复制工作可以正常进行，否则，master会返回invalid password错误</li><li>如果master设置了requirepass，而slave未设置masterauth，master会返回一个NOAUTH错误，反之，master未设置requirepass而slave设置了masterauth，master会返回no password is set 错误</li></ul></li><li><p>发送端口信息：身份认证通过之后，slave将执行REPLCONF listening-port <port>，向master发送从服务器的监听端口号，master接到此命令之后，设置slave-listening-port属性，slave-listening-port 可以通过在master的客户端上执行INFO REPLICATION 命令看到。</port></p></li><li><p>同步：slave向master发送PSYNC命令，进行同步操作，将自己的状态更新至master的状态</p></li><li><p>命令传播：完成同步之后，进入命令传播的阶段，这时候master在执行写操作以后，都会将其传给slave，slave接收之后执行命令达到和master一致的状态</p></li><li><p>心跳检测：在命令传播的过程中，slave默认会每秒向master发送命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &lt;replication offset&gt;</span><br></pre></td></tr></table></figure><p>发送此命令有三个作用：</p><ul><li>检测主从服务器的网络连接状态</li><li>辅助实现min-slave选项</li><li>检测命令丢失</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最简便的爬虫效率提升方法</title>
      <link href="/2016/08/02/multiprocessing.dummy/"/>
      <url>/2016/08/02/multiprocessing.dummy/</url>
      
        <content type="html"><![CDATA[<p>昨晚发现放在腾讯云主机上通过crontab定时执行用以爬去斗鱼分类页面数据的爬虫在执行的时候速度特别慢，于是想通过多线程来提高效率。<br>打开浏览器，键入关键字“python 多线程”，发现大多数内容都是使用threading、Queue这些看起来很笨重的实例。不过直到multiprocessing.dummy出现在眼前之后，一切都变得辣么简单。</p><a id="more"></a><h1 id="multiprocessing-dummy-与多线程"><a href="#multiprocessing-dummy-与多线程" class="headerlink" title="multiprocessing.dummy 与多线程"></a>multiprocessing.dummy 与多线程</h1><p>multiprocessing.dummy 是multiprocessing的一个子库，二者的不同之处就是前者应用于线程后者主要应用于进程，而它们实现并行化操作的关键则是map()函数。<br>以我的两段代码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def insert_info():</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    通过遍历游戏分类页面获取所有直播间</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    session = requests.session()</span><br><span class="line">    pagecontent = session.get(Directory_url).text</span><br><span class="line">    pagesoup = BeautifulSoup(pagecontent)</span><br><span class="line">    games = pagesoup.select(&apos;a&apos;)</span><br><span class="line">    col.drop()</span><br><span class="line">    for game in games:</span><br><span class="line">        links = game[&quot;href&quot;]</span><br><span class="line">        Qurystr = &quot;/?page=1&amp;isAjax=1&quot;</span><br><span class="line">        gameurl = HOST + links + Qurystr</span><br><span class="line">        gamedata = session.get(gameurl).text</span><br><span class="line">        flag = get_roominfo(gamedata)</span><br><span class="line">    aggregateData()</span><br></pre></td></tr></table></figure><p>上边这段是之前运行在云主机速度真的跟爬似的代码，通过Directory_url这个地址，获取到页面中所有的<a></a>标签，并获取到它们的’href’，再逐条获取每个链接中的内容，获取想要的东西，最终完成入库工作。所有的一切都看似按部就班哈。在我的笔记本上做测试，完成所有2032条数据的爬取共耗时<strong>140.5s</strong>(好特么慢＝。＝)。</p><p>但是在加入multiprocessing.dummy之后，真的是有飞一般的感觉：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing.dummy import Pool</span><br><span class="line"></span><br><span class="line">pool = Pool()</span><br><span class="line"></span><br><span class="line">def insert_info():</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    通过遍历游戏分类页面获取所有直播间</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    session = requests.session()</span><br><span class="line">    pagecontent = session.get(Directory_url).text</span><br><span class="line">    pagesoup = BeautifulSoup(pagecontent)</span><br><span class="line">    games = pagesoup.select(&apos;a&apos;)</span><br><span class="line">    gameurl = [HOST + url[&quot;href&quot;] + &quot;/?page=1&amp;isAjax=1&quot; for url in games]</span><br><span class="line">    col.drop()</span><br><span class="line">    g = lambda link: session.get(link).text</span><br><span class="line">    gamedata = pool.map(g, gameurl)</span><br><span class="line">    ginfo = lambda data: get_roominfo(data)</span><br><span class="line">    pool.map(ginfo, gamedata)</span><br><span class="line">    aggregateData()</span><br></pre></td></tr></table></figure><p>同样通过Directory_url这一地址获取页面中所有标签<a></a>，然后通过pool.map(g, gameurl)完成’href’值的获取，最后再用一次pool.map(ginfo,gamedata)完成所有页面内容的提取和入库。再一次测试，只需要<strong>33.1s</strong>即可完成。</p><p>更多详细信息可以参考<a href="https://docs.python.org/2/library/multiprocessing.html" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hack On Douyu -- 4</title>
      <link href="/2016/07/31/HackOnDouyu--4/"/>
      <url>/2016/07/31/HackOnDouyu--4/</url>
      
        <content type="html"><![CDATA[<p>原本打算使用<a href="http://selenium-python.readthedocs.io/" target="_blank" rel="noopener">selenium</a>给这个小项目做自动化测试的，没成想selenium功能如此强大，那就顺势做个自动抢鱼丸的小工具吧。😊<br><a id="more"></a></p><h1 id="Selenium是什么"><a href="#Selenium是什么" class="headerlink" title="Selenium是什么"></a>Selenium是什么</h1><p>Selenium是一款由ThoughtWorks公司开发的web自动化测试工具，它可以让测试人员编写的测试代码直接在浏览器中进行测试，并且它提供了当前绝大多数现代浏览器的驱动。同时Selenium也拥有很多开发语言版本的驱动。我使用的就是python版本的驱动。具体安装步骤可以参考<a href="http://selenium-python.readthedocs.io/" target="_blank" rel="noopener">这里</a>。<br>具体来说，Selenium可以模拟大多数的页面操作：填写表单、拖拽页面、页面切换、返回上一页面、前进到下一页面等。<br>告诉了Selenium网址之后，它可以自动打开指定的浏览器，并且待页面完全加载之后分别通过页面元素的id、name、XPath、Link Text、tag、class或者是css选择器完成元素的选择。<br>选定了页面元素之后可以按照预期完成一些列动作。</p><h1 id="Talk-is-cheap-Show-you-my-code"><a href="#Talk-is-cheap-Show-you-my-code" class="headerlink" title="Talk is cheap, Show you my code"></a>Talk is cheap, Show you my code</h1><p>整个项目的代码在<a href="https://github.com/wangmengcn/DouyuFan" target="_blank" rel="noopener">github</a>上托管，感兴趣的同学可以前去浏览。整个抢鱼丸礼物的过程可以由这个图来说明：<br><img src="https://eclipsesv.com/pics/%E6%96%97%E9%B1%BC%E5%BC%B9%E5%B9%95%E7%9B%91%E5%90%AC.png" alt="自动抢鱼丸流程"></p><p>具体步骤如下：</p><ol><li>与斗鱼弹幕服务器建立连接，监听当前最热门房间弹幕，由于火箭礼物消息会通过广播向所有直播间发送，所以只需要根据火箭消息的标识符来判定火箭消息即可；</li><li>火箭消息接收之后可以将其转存到redis中，利用pub/sub完成火箭消息的广播和订阅；</li><li>订阅redis火箭消息频道，获取当前可以抢鱼丸的房间完整url；</li><li>利用selenium打开浏览器并访问指定直播间，自动发送弹幕消息，并且点击抢鱼丸的按钮，最终完成自动抢鱼丸礼物的整个流程。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 获取全频道播放的火箭信息</span><br><span class="line">def get_rocket(data):</span><br><span class="line">    try:</span><br><span class="line">        sender_id = re.search(&apos;\/sn@=(.+?)\/&apos;, data).group(1)</span><br><span class="line">        recver_id = re.search(&apos;\/dn@=(.+?)\/&apos;, data).group(1)</span><br><span class="line">        recver_room = re.search(&apos;\/drid@=(.+?)\/&apos;, data).group(1)</span><br><span class="line">        gift = re.search(&apos;\/gn@=(.+?)\/&apos;, data).group(1)</span><br><span class="line">        rocketmsg = &#123;&#125;</span><br><span class="line">        rocketmsg[&quot;sender_id&quot;] = sender_id</span><br><span class="line">        rocketmsg[&quot;recver_id&quot;] = recver_id</span><br><span class="line">        rocketmsg[&quot;recver_room&quot;] = recver_room</span><br><span class="line">        rocketmsg[&quot;gift&quot;] = gift</span><br><span class="line">        rocketmsg[&quot;date&quot;] = datetime.now()</span><br><span class="line">        col.insert_one(rocketmsg, bypass_document_validation=False)</span><br><span class="line">        publishvalue = &#123;&#125;</span><br><span class="line">        publishvalue[&quot;sender_id&quot;] = sender_id</span><br><span class="line">        publishvalue[&quot;recver_id&quot;] = recver_id</span><br><span class="line">        publishvalue[&quot;recver_room&quot;] = recver_room</span><br><span class="line">        publishvalue[&quot;gift&quot;] = gift</span><br><span class="line">        castRocket(publishvalue)</span><br><span class="line">        print sender_id, &quot;送给房间号为:&quot;, recver_room, &quot;的&quot;, recver_id, &quot;一个&quot;,\</span><br><span class="line">            gift, &quot;&lt;&quot;, datetime.now(), &quot;&gt;&quot;</span><br><span class="line">        # 在此处完成自动抢鱼丸流程</span><br><span class="line">        getGift(str(recver_room))</span><br><span class="line">    except Exception, e:</span><br><span class="line">        print &quot;error occur:&quot;, repr(data)</span><br><span class="line">    finally:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>在此过程中，起到关键作用的selenium主要扮演如下图所示的角色：</p><p><img src="https://eclipsesv.com/pics/selenium%20driver.png" alt=""></p><ol><li>获取浏览器cookie，这样就免去了破解斗鱼帐号自动登录的麻烦；</li><li>获取指定元素，比如找到弹幕发送窗口，输入弹幕信息，发送弹幕，点击抢鱼丸按钮；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.action_chains import ActionChains</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getGift(roomid):</span><br><span class="line"># 这里是指定firefox的cookie位置</span><br><span class="line">    fp = webdriver.FirefoxProfile(</span><br><span class="line">        r&apos;/Users/eclipse/Library/Application Support/Firefox/Profiles/tmsbsjpg.default&apos;)</span><br><span class="line">    browser = webdriver.Firefox(fp)</span><br><span class="line">    browser.implicitly_wait(15)  # seconds</span><br><span class="line">    browser.get(&quot;http://www.douyu.com/&quot; + roomid)</span><br><span class="line">    try:</span><br><span class="line">    # 找到弹幕聊天窗口，输入聊天内容</span><br><span class="line">        indexvideo = browser.find_element_by_class_name(&apos;cs-textarea&apos;)</span><br><span class="line">        print type(indexvideo)</span><br><span class="line">        indexvideo.send_keys(&apos;2333333333333&apos;)</span><br><span class="line">        print indexvideo</span><br><span class="line">        time.sleep(7)</span><br><span class="line">        sendbut = browser.find_element_by_class_name(&apos;b-btn&apos;)</span><br><span class="line">        ActionChains(browser).move_to_element(</span><br><span class="line">            indexvideo).click(sendbut).perform()</span><br><span class="line">        gift = browser.find_element_by_class_name(&apos;peck-cdn&apos;)</span><br><span class="line">    except Exception, e:</span><br><span class="line">        print str(e)</span><br><span class="line">        browser.quit()</span><br><span class="line"></span><br><span class="line">    times = 0</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">        # 点击抢鱼丸按钮，在完成之后，按钮消息，继续点击出现异常，自动关闭浏览器即可</span><br><span class="line">            ActionChains(browser).move_to_element(gift).click(gift).perform()</span><br><span class="line">            time.sleep(2)</span><br><span class="line">            print times</span><br><span class="line">            times += 1</span><br><span class="line">        except Exception, e:</span><br><span class="line">            print &apos;completed by an error&apos;</span><br><span class="line">            browser.quit()</span><br></pre></td></tr></table></figure><h1 id="老板，来份鱼丸"><a href="#老板，来份鱼丸" class="headerlink" title="老板，来份鱼丸"></a>老板，来份鱼丸</h1><p>按照上述方法完成编码之后，我用自己的帐号测试了一下，效果是这样的：<br><img src="https://eclipsesv.com/pics/danmu.gif" alt=""></p><p>发现斗鱼可能是做了限制，每个人大概一天只能抢到2000个左右的鱼丸(斗鱼：本来为代码写测试的，谁让你没事干抢我们鱼丸的？！，我：生无可恋.jpg)，娱乐而已，不过说句心里话，selenium可真的是个好东西。</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hack On Douyu -- 3</title>
      <link href="/2016/07/27/HackOnDouyu--3/"/>
      <url>/2016/07/27/HackOnDouyu--3/</url>
      
        <content type="html"><![CDATA[<p>在拥有了数据获取和存储的能力之后，如何利用好这些数据成为一个问题。<br>本来也一直打算把之前学习的flask框架用起来，现在有了这些数据，我打算利用这些数据做一个对斗鱼网站的小型监控页面。<br><a id="more"></a></p><h1 id="初步构想"><a href="#初步构想" class="headerlink" title="初步构想"></a>初步构想</h1><p>通过弹幕可以基本上获取到所有的斗鱼火箭礼物发送和接收情况以及这些火箭发送的时间，因此可以利用这些数据得到每天每个小时斗鱼全站火箭的发送情况，利用发送者的id和接收者的id可以统计出每天的火箭排名。每天的数据在凌晨完成统计汇总，可以构成历史数据。<br>在这个小项目中，我主要用到两种方法完成前后端数据交互：一种是直接根据请求url知道前端需要的数据具体是什么，我就直接在后端完成数据的获取和处理，通过flask模板完成要返回的页面；另一种方法则是实时性比较强的或者是需要和前端js有交集的我才用socket.io完成数据交互。</p><p>通过抓取斗鱼直播间分类的静态页面可以按照人气值进行排名，获取到当前的热门房间，利用这些房间id可以获取到该直播间的直播视频数据，在flash插件上就可以直接转播(本来一直很纠结视频流如何获取，在参考了dotamax的转播方法之后就醒悟了)。</p><p>另外，在获取实时聊天弹幕的时候可以获取到火箭发送信息，将这些信息通过redis转发，再由socket.io提供给前端页面，实时推送火箭礼物消息。</p><h1 id="火箭发送数据交互"><a href="#火箭发送数据交互" class="headerlink" title="火箭发送数据交互"></a>火箭发送数据交互</h1><p>上边说到，火箭发送信息通过弹幕获取，在数据库中存储包括发送者id、接收者id和发送时间，这些数据同样可以通过redis完成pub/sub。<br>因此为了得到每日火箭逐小时发送情况，在后端完成了数据的预处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">def sortbyDay(date):</span><br><span class="line">    if isinstance(date, datetime):</span><br><span class="line">        year = date.year</span><br><span class="line">        m = date.month</span><br><span class="line">        d = date.day</span><br><span class="line">        singledate = datetime(year, m, d)</span><br><span class="line">        print singledate</span><br><span class="line">        singledata = []</span><br><span class="line">        count = 0</span><br><span class="line">        hour = range(0, 24)</span><br><span class="line">        for h in hour:</span><br><span class="line">            data = []</span><br><span class="line">            value = &#123;&#125;</span><br><span class="line">            start = datetime(year, m, d, h, 0, 0)</span><br><span class="line">            end = datetime(year, m, d, h, 59, 59)</span><br><span class="line">            daydata = col.find(</span><br><span class="line">                &#123;&apos;date&apos;: &#123;&apos;$gt&apos;: start, &apos;$lt&apos;: end&#125;&#125;, &#123;&apos;_id&apos;: 0&#125;)</span><br><span class="line">            if daydata is not None:</span><br><span class="line">                for item in daydata:</span><br><span class="line">                    data.append(item)</span><br><span class="line">                    count = count + 1</span><br><span class="line">            else:</span><br><span class="line">                data = None</span><br><span class="line">            value[&apos;hour&apos;] = h</span><br><span class="line">            value[&apos;rockets&apos;] = data</span><br><span class="line">            singledata.append(value)</span><br><span class="line">        if count != 0:</span><br><span class="line">            insertdata = &#123;</span><br><span class="line">                &apos;date&apos;: singledate,</span><br><span class="line">                &apos;data&apos;: singledata,</span><br><span class="line">                &apos;count&apos;: count</span><br><span class="line">            &#125;</span><br><span class="line">            return insertdata</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br></pre></td></tr></table></figure><p>通过输入指定的日期date，在数据库中检索该天内rocket表中所有数据，返回当天火箭礼物总量、以及每个小时火箭的发送量。<br>在获取到每天所有火箭数据之后，统计每天发送者和接收者排名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def valuebyHour(date):</span><br><span class="line">    daydata = sortbyDay(date)</span><br><span class="line">    count = 0</span><br><span class="line">    hourvalue = []</span><br><span class="line">    sendervalue = &#123;&#125;</span><br><span class="line">    recvervalue = &#123;&#125;</span><br><span class="line">    if daydata is not None:</span><br><span class="line">        count = daydata[&apos;count&apos;]</span><br><span class="line">        hourdata = daydata[&apos;data&apos;]</span><br><span class="line">        for h in hourdata:</span><br><span class="line">            hourvalue.append(len(h[&apos;rockets&apos;]))</span><br><span class="line">            sender = &apos;sender_id&apos;</span><br><span class="line">            recver = &apos;recver_id&apos;</span><br><span class="line">            rocket = h[&apos;rockets&apos;]</span><br><span class="line">            if len(rocket) != 0:</span><br><span class="line">                sendervalue = sortNames(rocket, sender, sendervalue)</span><br><span class="line">                recvervalue = sortNames(rocket, recver, recvervalue)</span><br><span class="line">        return (count, hourvalue, sendervalue, recvervalue)</span><br><span class="line">    else:</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure><p>最终返回当天火箭发送总量，火箭逐小时发送情况，发送者对应的发送量和接收者对应的接收量。</p><p>完成数据预处理之后，就可以根据前端的请求返回对应的数据了。由于前端获取数据之后前端js根据数据完成不同图表的绘制，我是采用socket.io的方式完成数据交互。<br>在后端，我是直接使用flask的一个扩展flask_socketio完成socket.io服务器的搭建(当然，socket.io拥有不同开发语言版本的实现，可根据具体情况有不同选择)。在flask中建立一个socket.io服务器是很简便的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from flask_socketio import SocketIO</span><br><span class="line">from flask_socketio import send, emit</span><br><span class="line"># flask 主程序</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[&apos;SECRET_KEY&apos;] = &apos;secret&apos;</span><br><span class="line">socketio = SocketIO(app)</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    socketio.run(app, host=&apos;0.0.0.0&apos;, port=3000)</span><br></pre></td></tr></table></figure><p>建立socket服务器之后，只需要根据具体情况建立不同的监听事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># historyDate事件，接收来自前端的日期date，将其解析之后调用上述数据获取方法</span><br><span class="line">@socketio.on(&apos;historyDate&apos;)</span><br><span class="line">def sendDate(date):</span><br><span class="line">    if date:</span><br><span class="line">        print date</span><br><span class="line">        time = date.split(&apos;-&apos;)</span><br><span class="line">        timevalue = [int(item) for item in time]</span><br><span class="line">        y = timevalue[0]</span><br><span class="line">        m = timevalue[1]</span><br><span class="line">        d = timevalue[2]</span><br><span class="line">        recordDate = datetime(y,m,d)</span><br><span class="line">        returnValue = valuebyHour(recordDate)</span><br><span class="line">        if returnValue:</span><br><span class="line">            (a, b, c, d) = returnValue</span><br><span class="line">            if b is not None:</span><br><span class="line">                socketio.emit(&apos;historyRockets&apos;, b)</span><br><span class="line">        else:</span><br><span class="line">            socketio.emit(&apos;historyRockets&apos;,None)</span><br><span class="line"># historyRockets事件，接收来自historyDate的数据并将其返回给前端           </span><br><span class="line">@socketio.on(&apos;historyRockets&apos;)</span><br><span class="line">def sendHistory(data):</span><br><span class="line">    emit(&apos;historyRockets&apos;,data)</span><br></pre></td></tr></table></figure><p>服务器端的内容弄完之后，前端只需要建立连接，并在恰当的时候触发对应的事件即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 连接socket.io服务器</span><br><span class="line">var socket = io.connect(&apos;http://ip:&apos; + port);</span><br><span class="line">// 触发事件</span><br><span class="line">socket.emit(&apos;historyDate&apos;,date);</span><br><span class="line">//接收数据</span><br><span class="line">socket.on(&apos;historyRockets&apos;, function(msg)&#123;</span><br><span class="line"> dosth();</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>每天的数据只需要前端发送一个指定的date就可以获取到了。</p><h1 id="最热房间数据获取"><a href="#最热房间数据获取" class="headerlink" title="最热房间数据获取"></a>最热房间数据获取</h1><p>通过socket.io可以完成数据交互，但是这些数据都需要建立额外的连接、消耗额外的网络资源，一些直接可以从后端获取的数据则可直接通过flask模板完成渲染。<br>以最热房间为例，由于通过爬虫抓取到的数据都在数据库中，页面在加载的时候直接调用即可。</p><p>首先获取人气排名前21位(页面显示3*7)。获取这些房间的房间标题、主播名、房间编号和房间封面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 按照观众人数，前20名房间</span><br><span class="line">def HotRoom():</span><br><span class="line">    hotroom = roomcol.find(&#123;&#125;, &#123;&quot;_id&quot;: 0, &quot;date&quot;: 0&#125;).sort(</span><br><span class="line">        &quot;audience&quot;, pymongo.DESCENDING).limit(21)</span><br><span class="line">    rooms = []</span><br><span class="line">    if hotroom:</span><br><span class="line">        for item in hotroom:</span><br><span class="line">            rooms.append(item)</span><br><span class="line">    return rooms</span><br></pre></td></tr></table></figure><p>数据获取之后，只需要在flask的router中添加对应规则并则模板中完成元素添加即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 添加路由规则</span><br><span class="line">@app.route(&apos;/chatmsg&apos;)</span><br><span class="line">def chatmsg():</span><br><span class="line">    rooms = HotRoom()</span><br><span class="line">    return render_template(&apos;gift.html&apos;, hotroom=rooms, flag=0)</span><br></pre></td></tr></table></figure><p>完成模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    &lt;h2 style=&quot;color:rgba(228, 230, 232, 0.53);&quot;&gt;热门房间&lt;/h2&gt;</span><br><span class="line">    &#123;%if hotroom%&#125;</span><br><span class="line">        &#123;%for room in hotroom%&#125;</span><br><span class="line">            &#123;%if flag%3==0 %&#125;</span><br><span class="line">            &lt;div class=&quot;row nopx&quot;&gt;</span><br><span class="line">            &#123;%endif%&#125;</span><br><span class="line">            &lt;div class=&quot;col-sm-6 col-md-4 nopx&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;thumbnail&quot; style=&quot;border:1px solid rgba(135, 144, 160, 0.15);line-height: 0px;</span><br><span class="line">background-color: rgba(8, 8, 8, 0.72);&quot;&gt;</span><br><span class="line">                    &lt;img src=&#123;&#123;room[&apos;img&apos;]&#125;&#125; alt=&quot;http://eclipsesv.com:4321/tv/&#123;&#123;room[&apos;roomid&apos;]&#125;&#125;&quot;&gt;</span><br><span class="line">                    &lt;div class=&quot;caption&quot;&gt;</span><br><span class="line">                        &lt;h4 style=&quot;color:rgba(228, 230, 232, 0.53);&quot;&gt;&#123;&#123;room[&apos;roomtitle&apos;]&#125;&#125;&lt;/h4&gt;</span><br><span class="line">                        &lt;p&gt;</span><br><span class="line">                            &lt;a href=&quot;http://eclipsesv.com:4321/tv/&#123;&#123;room[&apos;roomid&apos;]&#125;&#125;&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">                                &#123;&#123;room[&apos;anchor&apos;]&#125;&#125;@&#123;&#123;room[&apos;tag&apos;]&#125;&#125;</span><br><span class="line">                            &lt;/a&gt;</span><br><span class="line">                        &lt;/p&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &#123;%set flag=flag+1%&#125;</span><br><span class="line">            &#123;%if flag%3==0 %&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &#123;%endif%&#125;</span><br><span class="line">        &#123;%endfor%&#125;</span><br><span class="line">    &#123;%endif%&#125;</span><br></pre></td></tr></table></figure><p>这样就可以啦。</p><h1 id="视频流转播"><a href="#视频流转播" class="headerlink" title="视频流转播"></a>视频流转播</h1><p>热门房间页面完成之后，想要直接在页面中观看视频而不是跳转到斗鱼，之前一直想复杂了，在看了dotamax直播视频之后看了源码就恍然大悟了。原来只需要一个直播间id就可以了。</p><p>在flask中添加路由规则，通过roomid返回对应页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/tv/&lt;int:roomid&gt;&apos;)</span><br><span class="line">def tvstream(roomid):</span><br><span class="line">    if roomid:</span><br><span class="line">        return render_template(&apos;tv.html&apos;, roomid=roomid)</span><br></pre></td></tr></table></figure><p>前端模板只需要这样即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;%if roomid%&#125;</span><br><span class="line"> &lt;object type=&quot;application/x-shockwave-flash&quot; data=&quot;http://staticlive.douyutv.com/common/share/play.swf?room_id=&#123;&#123;roomid&#125;&#125;&quot; width=&quot;1200px&quot; height=&quot;750px&quot; allowscriptaccess=&quot;always&quot; allowfullscreen=&quot;true&quot; allowfullscreeninteractive=&quot;true&quot;&gt;&lt;param name=&quot;quality&quot; value=&quot;high&quot;&gt;&lt;param name=&quot;bgcolor&quot; value=&quot;#000000&quot;&gt;&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot;&gt;&lt;param name=&quot;allowfullscreen&quot; value=&quot;true&quot;&gt;&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot;&gt;&lt;param name=&quot;allowFullScreenInteractive&quot; value=&quot;true&quot;&gt;</span><br><span class="line">&lt;param name=&quot;quality&quot; value=&quot;high&quot;&gt;</span><br><span class="line">&lt;param name=&quot;bgcolor&quot; value=&quot;#000000&quot;&gt;</span><br><span class="line">&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot;&gt;</span><br><span class="line">&lt;param name=&quot;allowfullscreen&quot; value=&quot;true&quot;&gt;</span><br><span class="line">&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot;&gt;</span><br><span class="line">&lt;param name=&quot;allowFullScreenInteractive&quot; value=&quot;true&quot;&gt;</span><br><span class="line"> &lt;/object&gt;</span><br><span class="line">&#123;%endif%&#125;</span><br></pre></td></tr></table></figure><p>这样就可以盗用斗鱼的视频啦，哈哈哈。</p><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>到目前为止，站点基本上可以正常运行，由于前端的内容都是初步接触，总体上应该还有较大的可改进余地。接下来准备完成的点主要包括这些：</p><ul><li>数据库结构优化，充分考虑利用mongodb自身aggregation来完成数据预处理</li><li>提供完善的restful api 完成数据调用</li><li>提供针对直播分类和主播的人气监控</li></ul><p>暂时就先这些，继续努力！</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hack On Douyu -- 2</title>
      <link href="/2016/07/23/HackOnDouyu--2/"/>
      <url>/2016/07/23/HackOnDouyu--2/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章中，主要讲了我获取斗鱼弹幕和某些静态页面的方法，在数据获取到之后，如何有效的组织和存储数据直接关系到后续数据能否可以背有效使用。<br><a id="more"></a><br>为了更直观的说明获取到的这些数据如何组织和使用，我大致花了两张图来说明。</p><h1 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h1><p>通过爬虫或是直接通过tcp通讯获取到的斗鱼静态页面数据和弹幕聊天内容数据组织形式如下图所示：<br><img src="https://eclipsesv.com/pics/myBlogDouyu_mongo.png" alt="mongodb数据组织结构"><br>我使用mongodb来存储和管理数据，把上述的数据存储在名为Douyu的数据库中，将数据分别存于Roominfo、chatmsg、rocket、rocketbyDay四个表中。</p><h2 id="静态页面数据存储"><a href="#静态页面数据存储" class="headerlink" title="静态页面数据存储"></a>静态页面数据存储</h2><p>其中Roominfo库主要记录通过爬虫获取到的当前开播房间信息，字段主要包括用以纪录数据获取时间的date、开播房间人气audience、房间标题roomtitle、主播名anchor、房间标签tag、当前房间封面图片img、房间标识符roomid。<br>在实际使用中，可以隔时执行静态页面数据获取脚本从而获取这些数据，通过对audience进行排序可以轻易获取到人气最高的房间，并且能够将这些房间信息以json的格式传输到需要的地方。而audience和tag的组合也可以获取不同类型直播房间人气对比结果。<br>我在项目中通过服务器上的crontab每隔10分钟执行一次静态页面数据获取任务.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,10,20,30,40,55 * * *  * python  /path/to/allRooms.py</span><br></pre></td></tr></table></figure><p>反应给前端的结果可以通过<a href="http://eclipsesv.com:4321/chatmsg">这个页面</a>看到。</p><h2 id="弹幕聊天内容"><a href="#弹幕聊天内容" class="headerlink" title="弹幕聊天内容"></a>弹幕聊天内容</h2><p>上一篇说过，最初打算是想要对弹幕聊天内容进行自然语言分析的，但是由于一直没来得及搞，也就搁浅了，对与弹幕聊天内容，只是简要的纪录了包括发送者sender_id、发送时间date和弹幕内容content，由于每次获取的弹幕数据都是获取当时人气最高的房间弹幕，所以弹幕内容大都是什么“白银三杰”、“最强王者”之类的。。。</p><h2 id="火箭纪录"><a href="#火箭纪录" class="headerlink" title="火箭纪录"></a>火箭纪录</h2><p>自然语言分析没搞成，所以现在的重点工作是纪录观众赠送火箭，通过这些数据做出一些图表。<br>对火箭信息纪录使用了两个表：rocket和rocketbyDay。<br>rocket主要是获取实时火箭信息，通过与斗鱼弹幕服务器建立连接，根据弹幕消息类型将赠送火箭的信息获取到，主要包括：赠送者sender_id、接受者recver_id、赠送时间date和礼物类型gift。<br>rocketbyDay则是通过每天0:05分统计前一天火箭随着时间的分布情况，以天为单位的date、每天火箭总数count和当天火箭具体数据data。<br>纪录这些内容主要是可以统计出每日逐时礼物赠送情况、每天赠送礼物的土豪排名、受到火箭主播排名等。大致结果可以点击<a href="http://eclipsesv.com:4321/">当天火箭信息</a>和<a href="http://eclipsesv.com:4321/history">火箭历史数据</a>查看具体内容。</p><h1 id="消息实时转发"><a href="#消息实时转发" class="headerlink" title="消息实时转发"></a>消息实时转发</h1><p>上述数据可以看作直播数据中的长时间数据，而其中的一些需要“保鲜”的数据例如在有土豪赠送给主播火箭之后，观众可以在两分钟内到该房间抢鱼丸礼物，对于这种需要“保鲜”的数据，我通过redis的pub／sub来接收和转发，并通过socke.io实时发送给当前打开页面的观众。大致过程如下图所示：<br><img src="https://eclipsesv.com/pics/myBlogRedis.png" alt=""></p><h1 id="遇到的问题和下一步计划"><a href="#遇到的问题和下一步计划" class="headerlink" title="遇到的问题和下一步计划"></a>遇到的问题和下一步计划</h1><p>在实际项目运行中，有好几次出现mongodb莫名其妙挂掉的现象，由于项目运行在腾讯1核心1gb内存的云主机上（学生优惠一个月只要一块钱，23333333），这让我很快想到是不是在写入数据的时候，mongodb占用内存过高导致挂掉（之前在学校做项目的时候曾经见到过mongodb在大量写入数据的时候数据库挂掉的现象）。<br>于是，打开终端，连接到云主机上， 进入到mongodb目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./mongo</span><br><span class="line">use Douyu</span><br><span class="line">db.setProfilingLevel(1)</span><br></pre></td></tr></table></figure><p>然后静待下次数据库挂掉。果然在某个整10分钟的时候，数据又数不出来了，重启数据库，打开mongodb客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.system.profile.find().limit(2)</span><br></pre></td></tr></table></figure><p>出现的内容：<br><img src="https://eclipsesv.com/pics/myBlog%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-07-23%20%E4%B8%8B%E5%8D%8811.15.41.png" alt=""></p><p>正如猜想的那样，果然是由于写入的时候造成了数据库的问题。<br>这时，机智的我想到了师妹那里还有个闲置的云主机，征用过来做个读写分离试下吧（当然我也想搞个副本集，好多主、好多从、好多分片。。。关键不是没条件嘛）。减轻了服务器负载之后，数据库挂掉的现象没有再出现啦。</p><p>到目前为止，项目基本上可以正常运行，在数据操作这方面，打算在增加一些内容，比如分析某个游戏在每天随时间观众人数变化、某个主播直播时段、某个游戏人气变化情况等等。<br>下一篇内容主要讲后端flask的一些情况以及前后端数据传输方式等。</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hack On Douyu -- 1</title>
      <link href="/2016/07/20/HackOnDouyu--1/"/>
      <url>/2016/07/20/HackOnDouyu--1/</url>
      
        <content type="html"><![CDATA[<p>距离上次更新又有一段时间了，毕业答辩之后，确实和同学们一起出去嗨了一段时间，由于还没入职，在家清净的环境中可以好好学一下一直感兴趣的东西啦。</p><a id="more"></a><p>一直对网络爬虫很感兴趣，所以就开始学习很想学的python，用了之后也是感觉非常棒。期间抓过包括知乎、豆瓣、煎蛋还有个壁纸网站的数据，而抓去最多的还是直播网站斗鱼。数据抓下来之后如何使用是个问题，我的办法是用这些数据通过python的web框架flask搭建一个网站，也算是这段时间的学习成果。网站的构建自然少不了前端，也是硬着头皮学习了bootstrap，了解了一些css、javascript的知识。这段时间的学习成果主要是<a href="https://github.com/wangmengcn/LearningFlask" target="_blank" rel="noopener">LearningFlask</a>、<a href="https://github.com/wangmengcn/BeautifulPics" target="_blank" rel="noopener">BeautifulPics</a>、<a href="https://github.com/wangmengcn/Danmu" target="_blank" rel="noopener">Danmu</a>和<a href="https://github.com/wangmengcn/DouyuFan" target="_blank" rel="noopener">DouyuFan</a>这四个项目（由于也是刚接触python，代码质量可能不是太高 －。－）。而最后这个DouyuFan算是对前边几个项目的总结。DouyuFan主要是通过斗鱼网站弹幕信息的抓取，获取直播礼物的分布情况，历史数据记录以及当前最热门房间信息。<br>接下来我就用三次分别介绍我在数据抓取、后台搭建以及前后端数据通讯中学到的知识和遇到的问题。</p><h1 id="开播房间数据获取"><a href="#开播房间数据获取" class="headerlink" title="开播房间数据获取"></a>开播房间数据获取</h1><p>使用python抓取过数据的同学肯定对<a href="http://docs.python-requests.org/en/master/" target="_blank" rel="noopener">request</a>和<a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/" target="_blank" rel="noopener">Beautiful Soup</a>这两个库不陌生。<br>号称http for humans的requests缺失不是沽名钓誉，他在页面数据的抓取上确实简单明了。<br>通常情况下，requests和Beautiful Soup配合使用。以对斗鱼当前直播房间的抓取为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from bs4 import BeautifulSoup  # 导入BeautifulSoup，提取网页中目标元素</span><br><span class="line">import re# re 正则表达式，在快速查找和过滤元素中有出色表现</span><br><span class="line">import requests# reqeusts 用以获取页面数据</span><br><span class="line">from datetime import datetime</span><br><span class="line">from pymongo import MongoClient</span><br></pre></td></tr></table></figure><p>首先导入上述这几个库，然后可以伪造http请求header，这样可以减少爬虫被服务器ban掉的可能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HOST = &quot;http://www.douyu.com&quot;</span><br><span class="line">Directory_url = &quot;http://www.douyu.com/directory?isAjax=1&quot;</span><br><span class="line">Qurystr = &quot;/?page=1&amp;isAjax=1&quot;</span><br><span class="line"></span><br><span class="line">agent = &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.86 Safari/537.36&apos;</span><br><span class="line">accept = &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;</span><br><span class="line">connection = &quot;keep-alive&quot;</span><br><span class="line">CacheControl = &quot;no-cache&quot;</span><br><span class="line">UpgradeInsecureRequests = 1</span><br><span class="line">headers = &#123;</span><br><span class="line">    &apos;User-Agent&apos;: agent,</span><br><span class="line">    &apos;Host&apos;: HOST,</span><br><span class="line">    &apos;Accept&apos;: accept,</span><br><span class="line">    &apos;Cache-Control&apos;: CacheControl,</span><br><span class="line">    &apos;Connection&apos;: connection,</span><br><span class="line">    &apos;Upgrade-InsecureRequests&apos;: UpgradeInsecureRequests</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是开播房间数据的获取和入库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">cli = MongoClient(host=&quot;ip&quot;,port=xxx)</span><br><span class="line">db = cli[&quot;Douyu&quot;]</span><br><span class="line">col = db[&quot;Roominfo&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_roominfo(data):</span><br><span class="line">    if data:</span><br><span class="line">        firstpage = BeautifulSoup(data)</span><br><span class="line">        roomlist = firstpage.select(&apos;li&apos;)</span><br><span class="line">        print len(roomlist)</span><br><span class="line">        if roomlist:</span><br><span class="line">            for room in roomlist:</span><br><span class="line">                try:</span><br><span class="line">                    roomid = room[&quot;data-rid&quot;]</span><br><span class="line">                    roomtitle = room.a[&quot;title&quot;]</span><br><span class="line">                    roomtitle = roomtitle.encode(&apos;utf-8&apos;)</span><br><span class="line">                    roomowner = room.select(&quot;p &gt; span&quot;)</span><br><span class="line">                    roomtag = room.select(&quot;div &gt; span&quot;)</span><br><span class="line">                    roomimg = room.a</span><br><span class="line">                    roomtag = roomtag[0].string</span><br><span class="line">                    date = datetime.now()</span><br><span class="line">                    # now = datetime.datetime(</span><br><span class="line">                    # date.year, date.month, date.day, date.hour, date.minute)</span><br><span class="line">                    if len(roomowner) == 2:</span><br><span class="line">                        zbname = roomowner[0].string</span><br><span class="line">                        audience = roomowner[1].get_text()</span><br><span class="line">                        audience = audience.encode(&apos;utf-8&apos;).decode(&apos;utf-8&apos;)</span><br><span class="line">                        image = roomimg.span.img[&quot;data-original&quot;]</span><br><span class="line">                        word = u&quot;万&quot;    # 在页面中获取的房间人数以万为单位的str需要转换为int型，以便入库</span><br><span class="line">                        if word in audience:</span><br><span class="line">                            r = re.compile(r&apos;(\d+)(\.?)(\d*)&apos;)</span><br><span class="line">                            data = r.match(audience).group(0)</span><br><span class="line">                            audience = int(float(data) * 10000)</span><br><span class="line">                        else:</span><br><span class="line">                            audience = int(audience)</span><br><span class="line">                        roominfo = &#123;</span><br><span class="line">                            &quot;roomid&quot;: int(roomid),</span><br><span class="line">                            &quot;roomtitle&quot;: roomtitle,</span><br><span class="line">                            &quot;anchor&quot;: zbname,</span><br><span class="line">                            &quot;audience&quot;: audience,</span><br><span class="line">                            &quot;tag&quot;: roomtag,</span><br><span class="line">                            &quot;date&quot;: date,</span><br><span class="line">                            &quot;img&quot; : image</span><br><span class="line">                        &#125;</span><br><span class="line">                        col.insert_one(roominfo)</span><br><span class="line">                    # print roomid,&quot;:&quot;,roomtitle</span><br><span class="line">                except Exception, e:</span><br><span class="line">                    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def insert_info():</span><br><span class="line">    session = requests.session()</span><br><span class="line">    pagecontent = session.get(Directory_url).text</span><br><span class="line">    pagesoup = BeautifulSoup(pagecontent)</span><br><span class="line">    games = pagesoup.select(&apos;a&apos;)</span><br><span class="line">    col.drop()</span><br><span class="line">    for game in games:</span><br><span class="line">        links = game[&quot;href&quot;]</span><br><span class="line">        gameurl = HOST + links + Qurystr</span><br><span class="line">        print gameurl</span><br><span class="line">        gamedata = session.get(gameurl).text</span><br><span class="line">        get_roominfo(gamedata)</span><br></pre></td></tr></table></figure><p>我平常习惯使用mongodb作为数据存储，首先建立与数据库的连接，然后通过获取<a href="http://www.douyu.com/directory?isAjax=1" target="_blank" rel="noopener">斗鱼当前所有房间分类</a>，接着逐一获取每个分类中开播的房间数据，并记录每个房间的roomid（房间号，斗鱼直播间唯一标识）、roomtitle（房间标题）、anchor（主播id）、audience（观众人数）、tag（房间所属分类）、date（数据获取时间）、img（直播间封面图片）。通过定时执行此脚本，可以获取当前观众人数最多的房间(通常大都是lol的直播 ＝。＝)，也可以在之后通过roomid查询到关于对应直播间必要的信息。</p><h1 id="弹幕数据获取"><a href="#弹幕数据获取" class="headerlink" title="弹幕数据获取"></a>弹幕数据获取</h1><p>经常看斗鱼直播的同学肯定知道“弹幕大神”这个词，我最初想要抓取弹幕的目的是想通过大量的获取直播间弹幕数据进行一些自然语言分析，由于那些东西一直没学习，也就没再弄，但是，通过弹幕，可以获取到在全频道广播的火箭信息，长时间监测这些数据应该也是一件有意思的事情。<br>说干就干，想要获取到直播间的弹幕数据不同于上边所说的页面数据抓取，好在斗鱼官方也提供了一个获取弹幕的途径(斗鱼弹幕服务器第三方接入协议)[<a href="http://dev-bbs.douyutv.com/forum.php?mod=viewthread&amp;tid=109]，文档中对如何获取弹幕数据、以及弹幕信息类型有具体的说明，这也大大降低了获取弹幕数据的难度。" target="_blank" rel="noopener">http://dev-bbs.douyutv.com/forum.php?mod=viewthread&amp;tid=109]，文档中对如何获取弹幕数据、以及弹幕信息类型有具体的说明，这也大大降低了获取弹幕数据的难度。</a><br>看过这个协议之后，通过建立与弹幕服务器的tcp连接，可以不断的获取到弹幕数据，我使用的是(socket)[<a href="https://docs.python.org/2/library/socket.html]这个库。" target="_blank" rel="noopener">https://docs.python.org/2/library/socket.html]这个库。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HOST = &apos;openbarrage.douyutv.com&apos;</span><br><span class="line">PORT = 8601</span><br><span class="line">RID = 97376</span><br><span class="line">LOGIN_INFO = &quot;type@=loginreq/username@=qq_aPSMdfM5&quot; + \</span><br><span class="line">    &quot;/password@=1234567890123456/roomid@=&quot; + str(RID) + &quot;/&quot;</span><br><span class="line">JION_GROUP = &quot;type@=joingroup/rid@=&quot; + str(RID) + &quot;/gid@=-9999&quot; + &quot;/&quot;</span><br><span class="line">ROOM_ID = &quot;type@=qrl/rid@=&quot; + str(RID) + &quot;/&quot;</span><br><span class="line">KEEP_ALIVE = &quot;type@=keeplive/tick@=&quot; + \</span><br><span class="line">    str(int(time.time())) + &quot;/vbw@=0/k@=19beba41da8ac2b4c7895a66cab81e23/&quot;</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br></pre></td></tr></table></figure><p>在这里，需要注意几个变量： host port roomid gid 。其中HOST是弹幕服务器地址，port是对外开放的端口，roomid则是主播间对应的id，gid是要加入的弹幕频道，－9999频道可以获取到所有弹幕，也就是“海量弹幕”频道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def get_Hotroom():</span><br><span class="line">    hotroom = roomcol.find().limit(1).sort(</span><br><span class="line">        [(&quot;audience&quot;, pymongo.DESCENDING), (&quot;date&quot;, pymongo.DESCENDING)])</span><br><span class="line">    for item in hotroom:</span><br><span class="line">        return item[&quot;roomid&quot;]</span><br><span class="line">        </span><br><span class="line">def create_Conn():</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.connect((HOST, PORT))</span><br><span class="line">    RID = get_Hotroom()</span><br><span class="line">    print &quot;当前最热房间:&quot;, RID</span><br><span class="line">    LOGIN_INFO = &quot;type@=loginreq/username@=qq_aPSMdfM5&quot; + \</span><br><span class="line">        &quot;/password@=1234567890123456/roomid@=&quot; + str(RID) + &quot;/&quot;</span><br><span class="line">    print LOGIN_INFO</span><br><span class="line">    JION_GROUP = &quot;type@=joingroup/rid@=&quot; + str(RID) + &quot;/gid@=-9999&quot; + &quot;/&quot;</span><br><span class="line">    print JION_GROUP</span><br><span class="line">    s.sendall(tranMsg(LOGIN_INFO))</span><br><span class="line">    s.sendall(tranMsg(JION_GROUP))</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure><p>之后，通过get_Hotroom()获取到当前最热门房间（人数最多的房间），通过create_Conn()建立与服务器的连接。连接建立之后就可以开心的获取并保存弹幕数据了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def insert_msg(sock):</span><br><span class="line">    sendtime = 0</span><br><span class="line">    while True:</span><br><span class="line">        if sendtime % 20 == 0:</span><br><span class="line">            print &quot;----------Keep Alive---------&quot;</span><br><span class="line">            try:</span><br><span class="line">                sock.sendall(tranMsg(KEEP_ALIVE))</span><br><span class="line">            except socket.error:</span><br><span class="line">                print &quot;alive error&quot;</span><br><span class="line">                sock = create_Conn()</span><br><span class="line">                insert_msg(sock)</span><br><span class="line">        sendtime += 1</span><br><span class="line">        print sendtime</span><br><span class="line">        try:</span><br><span class="line">            data = sock.recv(4000)</span><br><span class="line">            if data:</span><br><span class="line">                strdata = repr(data)</span><br><span class="line">                if &quot;type@=spbc&quot; in strdata:</span><br><span class="line">                    get_rocket(data)</span><br><span class="line">                if &quot;type@=chatmsg&quot; in strdata:</span><br><span class="line">                    get_chatmsg(data)</span><br><span class="line">        except socket.error:</span><br><span class="line">            print &quot;chat error&quot;</span><br><span class="line">            sock = create_Conn()</span><br><span class="line">            insert_msg(sock)</span><br><span class="line">        time.sleep(1)</span><br></pre></td></tr></table></figure><p>每20秒向服务器发送一条KEEP_ALIVE用以使连接保活，通过获取到的数据特点，将普通聊天弹幕和火箭广播弹幕区分开来，并且保存在不同的数据库中从而为之后提供不同的用途。<br>弹幕数据获取大致是这样的：<br><img src="https://eclipsesv.com/pics/Douyufandanmu.gif" alt="获取弹幕"></p><h1 id="后续内容"><a href="#后续内容" class="headerlink" title="后续内容"></a>后续内容</h1><p>至此，此项目的数据获取工作已经完成，在接下来两篇内容会分别介绍如何使用这些数据构建页面，以及在此过程中遇到的问题。</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>硕士论文致谢</title>
      <link href="/2016/04/22/0422/"/>
      <url>/2016/04/22/0422/</url>
      
        <content type="html"><![CDATA[<p>好久没有更新博客，主要是忙着赶毕业论文啦～～，今天晚上终于完成了最后的致谢，走完了最后一公里。<br>洋洋洒洒三万字，终于到了致谢，在这个雷雨交加的夜晚，我的心情也是无比激动。<br><a id="more"></a><br>转眼间，两年硕士生活就要走到尽头，回想一路走来点点滴滴都是历历在目。我来自河南郑州一所没有什么名气的普通大学，读的是当年比较新兴的地理信息系统专业。在国内作为地理信息系统专业的学生肯定都知道武汉大学测绘遥感信息工程国家重点实验室是领域内的带头羊，大学四年自然是仰慕已久，心里也早早许下愿望将来一定要来这里深造。回想起两年前闻鸡起舞挑灯夜战，刷考研英语真题、做高数600题、背马毛中特，为自习室座位提前一个多小时排队…2014年，樱花盛开的季节，也是武汉大学最美的时候，我很荣幸通过了严格的复试，正式成为实验室的一名学生。在拿到录取通知书的那一刻，我就知道未来的两年，一定是奋斗的两年，一定是充实的两年。多亏了当初努力的我给了自己现在有写下这篇致谢的机会。<br>既然是致谢，自然要感谢两年来不论是在学业上、工作上还是生活上都给予我很大帮助的杜志强老师。14年7月份，还未正式开学，杜老师就提前让我到学校加入小组工作，并给我一个当时很有挑战性的工作——让我为小组项目搭建系统原型。多亏了那次机会让我有幸接触到了很多新的技术、新的思想和新的解决问题思路。紧接着，14年8月云南鲁甸地震，杜老师也是在第一时间派师兄和我去民政部国家减灾中心参加后方抗震救灾工作，杜老师自己也是赶赴地震现场，工作在救灾减灾第一线。那段时间，每天的数据处理、系统展示、工作汇报让人时刻都处于紧张状态，并且经常性的加班到凌晨。正是那段经历，让我在未来的两年内能够轻松应对学习和工作压力，也让我更加清楚地认识到杜老师常说的“要安排好时间”的重要性。杜老师也是个视野开阔、见多识广的导师，不仅能够为项目开发提供独到的见解，而且经常能够直击问题痛点，为我在技术上的成长提供了许多帮助。在这里同时也要感谢张老师、朱老师，感谢他们能够在百忙之中抽出时间参加我的开题报告，并为我的硕士论文提供宝贵意见和建议。<br>读研期间在一起时间最长的当然是vgeGroup的小伙伴们，我们学在一起、玩在一起，感谢你们和我一起成长。在这里，尤其要感谢和我一起加入小组的三哥——王叁同学，她和我同是专硕。感谢她陪我一起度过在二部码代码的日子、感谢她在学习上对我无私的帮助、感谢她教会我不少word和ppt的使用技巧，祝你今后的日子有书有茶有远方。感谢硕姐——刘硕同学在技术上和生活上对我的帮助；感谢老大——顾捷晔同学陪我一起在刀塔中找到了忙碌日子中缺失的激情；感谢琳姐——逯琳同学能够像一个大姐姐一样给大家提供各种帮助，祝你们大家能够早日拿到理想的offer。感谢仇林遥师兄，是他让我接触到硕士期间的主要研究内容，并且耐心地给我讲解各个技术实现细节、教我画出漂亮的Visio图…另外还要感谢我的一众师弟师妹，感谢师弟戴运波能够主动承担起我的大量遗留工作，任劳任怨，兢兢业业；感谢师妹韩颖颖在学习上和生活上给我提供的帮助；感谢师妹李静，她让我学会更好的和压力相处、更好的控制自己的情绪；感谢师妹黄爽，她让我看到了坚持对于一个人的重要性；感谢师妹刘雅玉分担了我的一大部分工作。在这里愿你们能够珍惜在vgeGroup的日子，把每天都过得精彩，每一步都走的踏实。<br>读研两年，在校期间，除了上边说的这些人，陪我最多的就是机房那台每天轰轰作响的服务器，也是由它我才开始接触到神奇的Linux。服务器上有我部署的nginx\php\luajit\mongodb\redis\goaccess\webbench\hexo，有我自己配置的路由表，有我码出来的瓦片调度逻辑脚本，有记录我实验结果的统计图表。因此，我也必须感谢机房的服务器，一个忠实可靠的伙伴。祝你能够早日遇到下一个愿意和你玩耍的小伙伴。<br>距离毕业的日子越来越近，秒针、分针、时针不停在走，回顾这半年，第一次感觉到时间是如此珍贵。早上起床学习新知识、看论文、写论文，下午学车，晚上看各种代码、debug、做实验；第一次感觉生活这么充实，看了凯文凯利的《失控》让我对现今计算机乃至整个世界的发展有了不同以往的看法；看了《图解http》、《wireshark数据包分析实战》让我对tcp/ip的原理有了更深入的理解，并且也学会了如何使用抓包工具抓取自己需要的信息；看了《笨办法学python》、《Head first Python》让我对仰慕已久的python更是着迷，自己也尝试养了几只爬虫，尝试用flask搭建网页，在这个过程中，前端这个新世界的大门也被我开启，看来想要成为一个真正的全栈开发者还有很长的路需要走；在大神Jerry Qu博客的指导下，我也将自己的博客升级到了http2.0。说了这么多，我只是想要感谢一下自己，没有辜负自己的青春，没有忘记自己的初心。<br>在这激动人心的夜里，致谢里自然少不了自己的父母，感谢你们含辛茹苦二十余载，感谢你们一路对我悉心照料，感谢你们对我坚定不移的支持。正是你们，让我在遇到苦难时不低头、经历绝望时看到希望，你们身上的正能量让我切身体会到知耻而后勇并且无时不刻激励着我努力过好每一天；正是你们，能够真心分享我成功时候的喜悦，你们的逆耳忠言、谆谆教诲让我戒骄戒躁、宠辱不惊。<br>回想两年前，一位同学在毕业季曾经说过的一句话“当窗外树影婆娑，便是我们离开的时候”，我们随着飘零的树影离去，追逐自己心中的梦想，去实现自己的价值，为改变这个世界做出自己的贡献。当然，不要忘了，感谢沿路所有遇到的人和事。</p><p>2016年4月22日凌晨<br>武汉大学信息学部</p>]]></content>
      
      
      <categories>
          
          <category> 心情文字 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python学习</title>
      <link href="/2016/04/06/0406/"/>
      <url>/2016/04/06/0406/</url>
      
        <content type="html"><![CDATA[<p>又是一个雷雨交加的夜晚，不知道从什么时候开始喜欢上了这种天气。<br>前段时间一直在研究Python的一个HTTP2.0客户端<a href="https://github.com/Lukasa/hyper" target="_blank" rel="noopener">Hyper</a>，没想到竟喜欢上了Python。这几天也是挤时间学习，看了<a href="https://book.douban.com/subject/26264642/" target="_blank" rel="noopener">《笨办法学Python》</a>和<a href="https://book.douban.com/subject/5310233/" target="_blank" rel="noopener">《Head First Python》</a>之后，想就从爬虫开始实践一把。<br><a id="more"></a><br>在多次尝试抓取网页内容之后，发现需要学的东西还挺多，Python基础的库urllib、requests这些，另外这次实践发现正则表达式也是十分重要。需要多加努力掌握才是。<br>在学习过程中，主要学会了使用浏览器Cookie、设置请求Header、随机更换Proxyhost这些东西来将爬虫伪装为浏览器。下面就直接放上通用性比较强点的代码吧。</p><h2 id="获取代理IP"><a href="#获取代理IP" class="headerlink" title="获取代理IP"></a>获取代理IP</h2><p>通过<a href="http://www.xicidaili.com" target="_blank" rel="noopener">http://www.xicidaili.com</a>这个网站可以实时获取到可用的代理服务器地址和端口，将其加入到一个队列，这里我是直接把他放在Redis的队列中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#-*- coding: UTF-8 -*- </span><br><span class="line">import urllib2</span><br><span class="line">import redis</span><br><span class="line">from BeautifulSoup import BeautifulSoup</span><br><span class="line">class Proxy_queue:</span><br><span class="line">    def __init__(self, addr, p):</span><br><span class="line">        print &quot;链接数据库&quot;</span><br><span class="line">        self.r = redis.StrictRedis(host=addr,port=int(p),db=0)</span><br><span class="line">        self.listname=&quot;proxylist&quot;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    def set_proxy(self):</span><br><span class="line">        for page in range(1,10):</span><br><span class="line">            print page</span><br><span class="line">            url = &apos;http://www.xicidaili.com/nn/%s&apos; %page</span><br><span class="line">            user_agent = &quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.134 Safari/537.36&quot;</span><br><span class="line">            request = urllib2.Request(url)</span><br><span class="line">            request.add_header(&quot;User-Agent&quot;, user_agent)</span><br><span class="line">            content = urllib2.urlopen(request)</span><br><span class="line">            soup = BeautifulSoup(content)</span><br><span class="line">            trs = soup.find(&apos;table&apos;, &#123;&quot;id&quot;:&quot;ip_list&quot;&#125;).findAll(&apos;tr&apos;)</span><br><span class="line">            for tr in trs[1:]:</span><br><span class="line">                tds = tr.findAll(&apos;td&apos;)</span><br><span class="line">                ip = tds[2].text.strip()</span><br><span class="line">                port = tds[3].text.strip()</span><br><span class="line">                protocol = tds[6].text.strip()</span><br><span class="line">                if protocol == &apos;HTTP&apos; or protocol == &apos;HTTPS&apos;:</span><br><span class="line">                    try:</span><br><span class="line">                        self.r.lpush(self.listname,ip+&quot;:&quot;+port)</span><br><span class="line">                        print &apos;%s://%s:%s&apos; % (protocol, ip, port)</span><br><span class="line">                    except Exception, e:</span><br><span class="line">                        print str(e)</span><br><span class="line">                    else:</span><br><span class="line">                        pass</span><br><span class="line">                    finally:</span><br><span class="line">                        pass</span><br><span class="line">    def get_proxy(self):</span><br><span class="line"></span><br><span class="line">        if self.r:</span><br><span class="line">            if self.r.llen(self.listname) == 0:</span><br><span class="line">                print &quot;实时获取最新代理，请稍后......&quot;</span><br><span class="line">                self.set_proxy()</span><br><span class="line">                print &quot;完成最新代理的爬取！&quot;</span><br><span class="line">            return self.r.rpop(self.listname)</span><br></pre></td></tr></table></figure></p><h2 id="实时消费Proxy"><a href="#实时消费Proxy" class="headerlink" title="实时消费Proxy"></a>实时消费Proxy</h2><p>通过上边的方法获取到的代理服务器，暂时存放在Redis队列中，在用的时候可以通过下边的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf8</span><br><span class="line">import urllib</span><br><span class="line">import socket</span><br><span class="line">from proxy_set import Proxy_queue</span><br><span class="line">import sys</span><br><span class="line">default_encoding = &apos;utf-8&apos;</span><br><span class="line">if sys.getdefaultencoding() != default_encoding:</span><br><span class="line">    reload(sys)</span><br><span class="line">    sys.setdefaultencoding(default_encoding)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">socket.setdefaulttimeout(3)</span><br><span class="line">url = &quot;http://ip.chinaz.com/getip.aspx&quot;</span><br><span class="line"></span><br><span class="line">oknum=1</span><br><span class="line">try:</span><br><span class="line">    queue = Proxy_queue(&quot;ip&quot;,port)</span><br><span class="line">except Exception, e:</span><br><span class="line">    print str(e)</span><br><span class="line">else:</span><br><span class="line">    pass</span><br><span class="line">finally:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">if queue:</span><br><span class="line">    while True:</span><br><span class="line">        try:</span><br><span class="line">            proxy_host=&quot;http://&quot;+queue.get_proxy()</span><br><span class="line">            proxy=&#123;&quot;http&quot;:proxy_host&#125;</span><br><span class="line">            res = urllib.urlopen(url,proxies=proxy).read()</span><br><span class="line">            print str(oknum)+ res</span><br><span class="line">            oknum+=1</span><br><span class="line">        except Exception,e:</span><br><span class="line">            print proxy</span><br><span class="line">            print e</span><br><span class="line">            continue</span><br></pre></td></tr></table></figure></p><h2 id="豆瓣API实践"><a href="#豆瓣API实践" class="headerlink" title="豆瓣API实践"></a>豆瓣API实践</h2><p>通过<a href="https://developers.douban.com/wiki/?title=api_v2" target="_blank" rel="noopener">豆瓣官方提供的API</a>可以获取到很多信息，可以满足个人建站的需求，我自己也尝试了一下，利用这些API获取电影、图书和音乐分类信息，得到的数据都是JSON格式的，直接放在MongoDB中很是方便。<br>这部分代码我直接放在了我的<a href="https://github.com/wangmengcn/DouBan_API_DEV" target="_blank" rel="noopener">Github</a>上。</p><h2 id="下步计划"><a href="#下步计划" class="headerlink" title="下步计划"></a>下步计划</h2><p>现在通过豆瓣API基本上获取到了电影、图书和音乐分类主页上类别的数据，下一步打算研究一下Flask框架，完成一个小网站，把这些数据当做基础数据用起来。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 DouBan </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>213</title>
      <link href="/2016/03/25/0325/"/>
      <url>/2016/03/25/0325/</url>
      
        <content type="html"><![CDATA[<p>忙里偷闲和同学从电影院看完《蝙蝠侠大战超人》，观影唯一感受就是希望六月份的那部期待已久的电影不要像这样让人失望。回来路上看到刚从东边爬上来的一轮圆月，还误以为是路灯。<br><a id="more"></a><br><img src="https://eclipsesv.com/pics/IMG_3187.JPG" alt="路灯一样的月亮"><br>又到了周五，日子过得可真快，最近一段时间都过得比较艰难，论文、工作和驾照三座大山也是压得喘不过气来。想起高二下半学期，由于过年的时候期末考试没考好，老爸还专门给我写信鼓励我，告诉我春暖花开的时候，最适合播种，现在的努力才能体验收获的喜悦。两年前的这个时候，自己只身来到武汉参加研究生复试，我相信那个时候的我眼中的光比现在的亮。恰好此时此刻豆瓣FM里边也播着孙燕姿的《尚好的青春》，是时候做出调整，让这些自己肩上的压力变为动力。<br>和更多的人交谈，突破自己的小圈子；和更多的人讨论，开阔自己的思路；向优秀的人学习，承认自己的不足，并努力做到榜样们能够做到的事情。<br>知道自己的知识面狭窄，就去广泛的涉猎不同领域的大作；知道焦虑并不能解决问题，就起身寻找解决问题的办法；知道程序有BUG，就去测试、修改完善然后提交。<br>不能确定做完一件事情后是否会后悔，那就只去做一些不会让自己后悔的事情；知道自己要做什么事情，面对质疑声要礼貌的回应或者不回应；做一个脚踏实地的行动派，向活在梦里的自己说再见！</p>]]></content>
      
      
      <categories>
          
          <category> 心情文字 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux基础知识</title>
      <link href="/2016/03/17/0327/"/>
      <url>/2016/03/17/0327/</url>
      
        <content type="html"><![CDATA[<p>总结一下常用的Linux系统基础知识点。<br><a id="more"></a></p><h1 id="Linux-启动大致过程"><a href="#Linux-启动大致过程" class="headerlink" title="Linux 启动大致过程"></a>Linux 启动大致过程</h1><ol><li>计算机通电之后，进入BIOS阶段，之后操作系统接管硬件，首先读入/boot目录下的内核文件。</li><li>内核文件加载之后，开始运行第一个程序/sbin/init，进行初始换系统环境，由于init是第一个程序，它的进程编号为1，其他所有进程都从它衍生，都是它的子进程。</li><li>init根据“运行级别”确定要运行哪些程序，Linux预置其中运行级别（0-6）。一般来说，0是关机，1是单用户模式，6是重启，根据发行版不同2-5对应的运行级别也有所不同。init进程首先读取文件/etc/inittab，它是运行级别的设置文件。而每个运行级别对应的程序在/etc目录下，指定要加载的程序。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l0:0:wait:/etc/rc.d/rc 0</span><br><span class="line">l1:1:wait:/etc/rc.d/rc 1</span><br><span class="line">l2:2:wait:/etc/rc.d/rc 2</span><br><span class="line">l3:3:wait:/etc/rc.d/rc 3</span><br><span class="line">l4:4:wait:/etc/rc.d/rc 4</span><br><span class="line">l5:5:wait:/etc/rc.d/rc 5</span><br><span class="line">l6:6:wait:/etc/rc.d/rc 6</span><br></pre></td></tr></table></figure><p>例如打开rc3.d文件夹，看看里边都有些什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lrwxrwxrwx 1 root root 22 Dec  9  2013 K02avahi-daemon -&gt; ../init.d/avahi-daemon</span><br><span class="line">lrwxrwxrwx 1 root root 24 Dec  9  2013 K02avahi-dnsconfd -&gt; ../init.d/avahi-dnsconfd</span><br><span class="line">lrwxrwxrwx 1 root root 19 Dec  8 11:25 K05saslauthd -&gt; ../init.d/saslauthd</span><br><span class="line">lrwxrwxrwx 1 root root 13 Dec  9  2013 K15gpm -&gt; ../init.d/gpm</span><br><span class="line">lrwxrwxrwx 1 root root 18 Dec  3 11:19 K15svnserve -&gt; ../init.d/svnserve</span><br><span class="line">......</span><br><span class="line">lrwxrwxrwx 1 root root 17 Dec  9  2013 S03sysstat -&gt; ../init.d/sysstat</span><br><span class="line">lrwxrwxrwx 1 root root 17 Dec  9  2013 S10network -&gt; ../init.d/network</span><br><span class="line">lrwxrwxrwx 1 root root 16 Dec  9  2013 S12syslog -&gt; ../init.d/syslog</span><br><span class="line">lrwxrwxrwx 1 root root 19 Dec  3 11:19 S26haldaemon -&gt; ../init.d/haldaemon</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>可以看到，这里边都是一些程序的连接，K开头的代表KILL（关闭），S开头代表Start，第一个字母之后的数字代表程序执行顺序，数字越小表示执行优先级较高。</p><ol start="4"><li>加载开机启动程序，上边rc.d文件夹中的链接文件指向另外一个目录/etc/init.d，这里边则是真正启动的脚本，init进程逐一加载开机启动程序，其实就是运行这个目录中的启动脚本。</li><li>用户登录，开机启动程序加载完成之后，就要让用户登录了。一般来说登录方式有三种：命令行登录，ssh登录，图形界面登录。</li><li>进入login shell，用户登录时代开的shell就叫做login shell。完成Linux启动过程。</li></ol><h1 id="Linux-系统组成"><a href="#Linux-系统组成" class="headerlink" title="Linux 系统组成"></a>Linux 系统组成</h1><p>Linux操作系统由Linux内核和各种外围程序组成。Linux内核是一个特殊的软件程序，用于实现CPU和内存分配、进程调节、设备驱动等核心操作，以面向硬件为主。外围程序包括用户指定的解析器、网络服务程序、图形桌面程序等各种应用型软件程序，以面向用户为主。<br>Linux内核是操作系统的核心，主要分为几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。<br>这里不得不提一下Linux系统的发行版本，由于Linux系统内核是个开源软件，任何公司或者个人都可以将Linux内核和自由软件打包成一个完整的Linux操作系统。主流的Linux分支有：Red Hat系列（Red Hat企业版、Fedora社区版、CentOS社区版），Suse系列，Debian系列（以Ubuntu为代表）</p><h1 id="Linux-系统小知识点"><a href="#Linux-系统小知识点" class="headerlink" title="Linux 系统小知识点"></a>Linux 系统小知识点</h1><ul><li><p>软硬链接<br>在Linux系统中使用ln命令可以对一个已经存在的文件建立一个新的链接，而不复制文件的内容。链接有软链接和硬链接之分，软链接又叫做符号链接。他们的主要区别是：硬链接，是给文件一个副本，源文件名和链接文件名都指向相同的物理地址。目录不能有硬链接，硬链接不能够跨越文件系统，修改原文件或者硬链接都会影响到对方，如果删除其中一个，另一个不会受到影响，可以防止不必要的误删；软链接，用ln -s命令建立文件的软链接，它是linux系统特殊文件的一种，作为一个文件，它的数据是它所连接文件的路径名，类似于windows中的快捷方式，删除软链接是不会影响到原文件的。</p></li><li><p>僵尸进程<br>在Linux系统中，一个进程结束了，但是他的父进程没有等待（调用wait/waitpid），那么它将变成为一个僵尸进程。通过命令来查看系统中存在的僵尸进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">通过top可以看出当前系统中是否存在僵尸进程</span><br><span class="line">top - 23:12:22 up 28 min,  4 users,  load average: 0.02, 0.07, 0.11</span><br><span class="line">Tasks: 414 total,   2 running, 412 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.3 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1003164 total,   256540 free,   568848 used,   177776 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  1978136 free,   119012 used.   262808 avail Mem</span><br><span class="line">其中zombie前的数字，如果大于0则表明系统存在僵尸进程</span><br><span class="line">//-------分割线--------\\</span><br><span class="line">通过ps命令把僵尸揪出来</span><br><span class="line">ps -ef | grep defunct    或者</span><br><span class="line">ps -A -ostat,ppid,pid,cmd | grep  -e &apos;^[Zz]’</span><br></pre></td></tr></table></figure></li></ul><p>在找到僵尸进程之后，通过其pid使用kill命令将其杀死，如果杀不死，可以先将其父进程杀死，父进程死后僵尸进程变为“孤儿进程”，过继给init进程，init负责处理僵尸进程，并且它产生的所有僵尸进程也会随着消失。</p><ul><li>文件权限<br>1). 在说道文件权限之前，不得不提Linux中用户与用户组的概念。Linux是一个多用户多任务操作系统，即系统上可以建立多个用户，并且多个用户可以在同一时间登录同一个系统执行各自不同的任务而互不影响。Linux正是通过用户和用户组权限的划分和管理来实现多用户多任务的运行机制。<br>Linux下用户时根据角色定义的，具体分为三种角色：超级用户，拥有对系统的最高管理权限，默认root用户；普通用户，只能对自己目录下的文件进行访问和修改，具有登录系统的权限；虚拟用户：此类用户特点是不能进行系统登录，主要是为了方便系统管理，比如nobody用户。<br>用户组是具有相同特征用户的逻辑集合，它能够将需要相同操作权限的用户放在一个组里，从而很大程度上简化管理工作。<br>用户和用户组之间的关系可能是：一对一、一对多、多对多、多对一。<br>用户和用户组相关配置文件有这些：/etc/passwd文件，它记录了Linux系统中每个用户的一些基本属性，并且对所有用户可读。其格式是这样的：用户名：口令：用户标识号：组标识号：注释行描述：主目录：默认shell；/etc/shadow文件，用于存放用户密码，只有root用户有用读权限；/etc/group文件，用户组配置文件，存放用户组相关信息。<br>与用户和用户组相关操作的命令主要有这些：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">创建组</span><br><span class="line">groupadd test  //增加一个test组</span><br><span class="line">修改组</span><br><span class="line">groupmod -n test1 test //将组test改名为test1</span><br><span class="line">删除组</span><br><span class="line">groupdel test1//将test1组删除</span><br><span class="line">//-----------------------------------------//</span><br><span class="line">增加用户</span><br><span class="line">useradd test //增加用户test</span><br><span class="line">passwd test //在使用useradd之后需要对增加的用户指明其登录密码</span><br><span class="line">修改用户</span><br><span class="line">usermod -d /home/test -G test1 test //将用户test的登录目录改为/home/test，并使其加入用户组test1</span><br><span class="line">gpasswd -a test test2//将用户test加入test2组</span><br><span class="line">gpasswd -d test test2  //将用户test从test2组中删除</span><br><span class="line">删除用户</span><br><span class="line">userdel test //删除用户test</span><br></pre></td></tr></table></figure></li></ul><p>2). 介绍完用户和用户组，接下来说一下Linux中文件权限。在Linux中每个文件都具有User，Group和Others三种身份的区别。要想了解文件权限相关的内容，需要知道Linux文件属性，通过ls命令可以看到文件属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">total 88</span><br><span class="line">drwxr-xr-x  3 root root  4096 Mar 21 09:11 .</span><br><span class="line">drwxr-xr-x 12 root root  4096 Mar  5 20:56 ..</span><br><span class="line">-rw-r--r--  1 root root  1077 Dec  3 11:27 fastcgi.conf</span><br><span class="line">-rw-r--r--  1 root root  1077 Mar 10 00:58 fastcgi.conf.default</span><br><span class="line">-rw-r--r--  1 root root  1007 Dec  3 11:27 fastcgi_params</span><br><span class="line">-rw-r--r--  1 root root  1007 Mar 10 00:58 fastcgi_params.default</span><br><span class="line">-rw-r--r--  1 root root  2837 Mar 10 00:58 koi-utf</span><br><span class="line">-rw-r--r--  1 root root  2223 Mar 10 00:58 koi-win</span><br><span class="line">-rw-r--r--  1 root root  3957 Dec  3 11:27 mime.types</span><br><span class="line">-rw-r--r--  1 root root  3957 Mar 10 00:58 mime.types.default</span><br><span class="line">-rw-rw-rw-  1 root root  4037 Mar 10 10:44 nginx.conf</span><br><span class="line">-rw-r--r--  1 root root  3110 Jan 23 15:35 nginx.conf.bak</span><br><span class="line">-rw-r--r--  1 root root  2656 Mar 10 00:58 nginx.conf.default</span><br><span class="line">-rw-r--r--  1 root root 12288 Dec  3 21:00 .nginx.conf.swp</span><br><span class="line">-rw-r--r--  1 root root   636 Dec  3 11:27 scgi_params</span><br><span class="line">-rw-r--r--  1 root root   636 Mar 10 00:58 scgi_params.default</span><br><span class="line">drwxr-xr-x  2 root root  4096 Mar  6 13:39 ssl</span><br><span class="line">-rw-r--r--  1 root root   664 Dec  3 11:27 uwsgi_params</span><br><span class="line">-rw-r--r--  1 root root   664 Mar 10 00:58 uwsgi_params.default</span><br><span class="line">-rw-r--r--  1 root root  3610 Mar 10 00:58 win-utf</span><br><span class="line">[权限] [连接] [owner] [group] [size] [修改日期] [文件名]</span><br></pre></td></tr></table></figure></p><p>由ls命令返回的内容看，第一组由10个字符构成，用以表示其对应文件的文件类型和权限。其中第一个字符代表这个文件是目录（d）、文件（-）、链接文件（l）、可供存储的接口设备（b）等。接下来的9个字符，每三个构成一组，分别代表“文件拥有者的权限”、“同群组的权限”、“其他非本群组的权限”。而每个组由rwx三个参数来构成，分别代表可读（r）、可写（w）和可执行（x）。对于文件来说，r表示具有读取文件内容的权限，w权限表示可写入，表示具有编辑、新增或是修改文件内容（不包括删除），x表示可以执行此文件；对于目录来说，r表示可以读取目录结构列表，查询目录下的文件名数据，通过ls显示目录中的内容，w表示可以改动目录结构列表（建立新的文件和目录，删除已经存在的文件与目录，重命名文件或目录，或者使用mv进行文件的移动）<br>第二组表示有多少文档名连接到此节点；<br>第三组表示这个文件或者目录的拥有者；<br>第四组表示这个文件的所属族群；<br>第五组表示文件的大小，默认单位是bytes；<br>第六组为此文件或者目录建档日期或者最近修改日期；<br>第七栏为文件名。<br>3). 改变文件属性与权限<br>通过chgrp命令改变文件所属群组，chown命令改变文件拥有者，chmod命令改变文件的权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chgrp [-R] GROUP FILE//-R表示递归，将目录下的所有文件都修改其组别 GROUP 表示要改变的目标 FILE是文件或者目录</span><br><span class="line">chown [OPTION] OWNER:GROUP FILE//改变文件所有者</span><br></pre></td></tr></table></figure></p><p>文件权限的改变使用chmod命令，但是权限的设置方式有两种，分别可以使用数字或者符号来进行权限的变更。可以使用数字来代表各个权限，r:4，w:2，x:1。权限的修改按照这些数字即可完成，例如要把nginx.conf文件权限修改为[-rwxr–r–]可以使用下面的命令完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 744 nginx.conf//rwx==&gt;4+2+1=7 r--==&gt;4 r--==&gt;4</span><br></pre></td></tr></table></figure></p><p>或者是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u=rwx,go=r nginx.conf//u==&gt;user go==&gt;group/others</span><br></pre></td></tr></table></figure></p><h1 id="Linux-中软件安装方法"><a href="#Linux-中软件安装方法" class="headerlink" title="Linux 中软件安装方法"></a>Linux 中软件安装方法</h1><ul><li><p>YUM</p></li><li><p>RPM</p></li><li><p>源码编译，系统环境变量</p></li></ul><h1 id="Linux-运维过程中常用命令及其用法"><a href="#Linux-运维过程中常用命令及其用法" class="headerlink" title="Linux 运维过程中常用命令及其用法"></a>Linux 运维过程中常用命令及其用法</h1><ul><li>网络相关命令<br>Linux系统中有相关的文件专门配置系统网络，以redhat发行版为例：<br>ip配置文件：对应网卡的ip地址配置文件在/etc/sysconfig/network-script/ifcfg-<interface-name>文件中。ifcfg-eth0代表第一块网卡，ifcfg-eth1代表第二块网卡，以此类推。此文件中可能存在的字段：</interface-name></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=&#123;name&#125;  #&#123;name&#125;表示网卡对应物理设备的名字</span><br><span class="line">TYPE=Ethernet #网络类型，Ethernet代表以太网</span><br><span class="line">ONBOOT=yes/no #yes/no代表是否激活该网络接口</span><br><span class="line">BOOTPROTO=none/static/bootp/dhcp    #设置网卡获取ip的方式</span><br><span class="line">IPADDR=&#123;address&#125;#如果BOOTPROTO设置为static,&#123;address&#125;代表赋予网卡的ip地址</span><br><span class="line">NETMASK=&#123;mask&#125;#&#123;mask&#125;代表网卡对应的子网掩码</span><br><span class="line">GATEWAY=&#123;gateway&#125;#&#123;gateway&#125;代表默认网关</span><br><span class="line">DNS=&#123;dns&#125;#&#123;dns&#125;代表DNS服务配置</span><br><span class="line">MACADDR=&#123;macaddr&#125;#&#123;macaddr&#125;表示制定一个mac地址</span><br><span class="line">HWADDR=&#123;addr&#125;#&#123;addr&#125;代表mac地址</span><br></pre></td></tr></table></figure><p>通过/etc/sysconfig/network文件可以修改主机名，也可以通过hostname {name}来临时修改主机名；<br>网关的配置文件/etc/sysconfig/network文件，网关的修改也可以通过上述的ip配置文件来修改，network文件中可以修改的配置项有这些：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NETWORK=yes #表示系统是否使用网络，一般设置为yes，如果设置为no，则不能使用网络，而且很多系统服务程序将无法启动</span><br><span class="line">RORWARD_IPV4=yes</span><br><span class="line">HOSTNAME=&#123;hostname&#125;  #&#123;hostname&#125;表示服务器的主机名，这里的主机名要和/etc/hosts中设置的主机名对应</span><br><span class="line">GAREWAY=&#123;address&#125;  #&#123;address&#125;设置本机连接的网关的IP地址，例如，网关10.0.0.2</span><br><span class="line">GATEWAYDEV=&#123;device&#125;  #&#123;device&#125;表示网关的设备名，如：eth0</span><br><span class="line">NETWORK=yes/no　　　　 #网络是否被配置</span><br><span class="line">FORWARD_IPV4=yes/no　　　　 #是否开启IP转发功能</span><br></pre></td></tr></table></figure></p><p>DNS配置文件为/etc/resolv.conf文件，同样的DNS信息也可以在ip配置文件中修改，通过resolv.conf文件配置DNS客户端，目前最多支持三个DNS服务器，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.8.8 #google域名服务器</span><br><span class="line">nameserver 8.8.8.4 #google域名服务器</span><br></pre></td></tr></table></figure></p><p>在没有配置域名服务器的时候，系统上所有的网络程序都通过/etc/hosts文件查询一些主机名对应的IP地址，他们是按照键值对的方式进行配置的，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eclipsesv.com 121.42.219.216</span><br><span class="line">localhost 127.0.0.1</span><br></pre></td></tr></table></figure></p><ul><li>Shell/Python系统管理脚本（CPU、内存、磁盘）、邮件收发脚本、文本处理、随机码生成、Nginx作为系统服务的脚本</li><li>sed\akw\grep 使用 附带常用正则表达式</li><li>数据库 MySQL基础命令、Redis和MongoDB要深入，体现优势</li><li>监控工具 nagios</li><li>用户和组管理</li><li>文件操作权限以及find命令</li><li>crontab命令的使用方法</li><li>磁盘挂载方法</li></ul><h1 id="分析Web服务器日志-（分析日志中排名靠前的ip、计数统计等）"><a href="#分析Web服务器日志-（分析日志中排名靠前的ip、计数统计等）" class="headerlink" title="分析Web服务器日志 （分析日志中排名靠前的ip、计数统计等）"></a>分析Web服务器日志 （分析日志中排名靠前的ip、计数统计等）</h1><ul><li>查看排名前10的IP地址： awk ‘{print $1}’ access.log | sort | uniq -c | sort -nr | head -n 10</li><li>查看某一天的ip地址： cat access.log | grep “01/Nov/2016” | awk ‘{print $1}’ | uniq -c | sort -nr | head -n 10</li><li>查看请求最多的URL：  awk ‘{print $11}’ access.log | sort | uniq -c | sort -nr | head -n 10<h1 id="子网划分方法-（十进制二进制转换，网络地址，主机地址，广播，网关等）"><a href="#子网划分方法-（十进制二进制转换，网络地址，主机地址，广播，网关等）" class="headerlink" title="子网划分方法 （十进制二进制转换，网络地址，主机地址，广播，网关等）"></a>子网划分方法 （十进制二进制转换，网络地址，主机地址，广播，网关等）</h1><h1 id="常用正则表达式-（ip地址、电话号码、以及基础语法）"><a href="#常用正则表达式-（ip地址、电话号码、以及基础语法）" class="headerlink" title="常用正则表达式 （ip地址、电话号码、以及基础语法）"></a>常用正则表达式 （ip地址、电话号码、以及基础语法）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">数字：^[0-9]*$</span><br><span class="line">n位数字: ^\d&#123;n&#125;$</span><br><span class="line">至少n位数字： ^\d&#123;n,&#125;$</span><br><span class="line">m-n位数字： ^\d&#123;m,n&#125;$</span><br><span class="line">零和非零开头的数字： ^(0|[1-9][0-9]*)$</span><br><span class="line">非零开头最多带有两位小数的数字： ^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</span><br><span class="line">带有1-2位小数的正数或者负数： ^(\-)?\d+(\.\d&#123;1,2&#125;)?$</span><br><span class="line">正数、负数和小数： ^(\-|\+)?\d+(\.\d+)?$</span><br><span class="line">Email地址： ^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line">域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span><br><span class="line">InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span><br><span class="line">手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</span><br><span class="line">身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$</span><br><span class="line">ip地址： ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)</span><br></pre></td></tr></table></figure></li></ul><h1 id="TCP协议细节（分组、重传、滑动窗口、握手分手、各阶段连接状态）"><a href="#TCP协议细节（分组、重传、滑动窗口、握手分手、各阶段连接状态）" class="headerlink" title="TCP协议细节（分组、重传、滑动窗口、握手分手、各阶段连接状态）"></a>TCP协议细节（分组、重传、滑动窗口、握手分手、各阶段连接状态）</h1><h1 id="HTTP协议细节（请求-响应报文，状态码，HTTP2-0特性"><a href="#HTTP协议细节（请求-响应报文，状态码，HTTP2-0特性" class="headerlink" title="HTTP协议细节（请求/响应报文，状态码，HTTP2.0特性)"></a>HTTP协议细节（请求/响应报文，状态码，HTTP2.0特性)</h1><h1 id="SMTP-POP3协议细节-（base64编码原理）"><a href="#SMTP-POP3协议细节-（base64编码原理）" class="headerlink" title="SMTP/POP3协议细节 （base64编码原理）"></a>SMTP/POP3协议细节 （base64编码原理）</h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hyper Interface(1)</title>
      <link href="/2016/03/16/Hyper%20Interface1/"/>
      <url>/2016/03/16/Hyper%20Interface1/</url>
      
        <content type="html"><![CDATA[<p>在接下来的一段时间，我会在学习Hyper的过程中，翻译官方接口文档，目标是在仔细阅读文档的同时提高Python技艺，同时会做一些实验测试HTTP2在性能上的提升到底有多少。由于是第一次进行这样的翻译，有很多错误或者纰漏，我会在以后不断的更新。<br><a id="more"></a></p><h1 id="HTTP基础类"><a href="#HTTP基础类" class="headerlink" title="HTTP基础类"></a>HTTP基础类</h1><h2 id="HTTPConnection"><a href="#HTTPConnection" class="headerlink" title="HTTPConnection"></a>HTTPConnection</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class hyper.HTTPConnection(host,port=None,secure=Node,window_manager=Node,</span><br><span class="line">enable_push=False,ssl_content=None,proxy_port=Node,**kwargs)</span><br></pre></td></tr></table></figure><p>HTTPConnection作为一个连接到服务器的对象类似于Python标准库中HTTPConnection的作用，只不过有一些关键的不同之处。<br>Hyper并不支持大多数的标准库中HTTPConnection类构造函数的参数。大多数hyper.Connection类中的可选参数同时支持HTTP/1.1和HTTP/2。</p><blockquote><p>参数</p><ul><li>host-即所要连接的服务器，可以使一个IP地址或者是一个域名，并且可以包含一个端口号，比如说：’eclipsesv.com’,’eclipsesv.com:443’或者’121.42.219.216:44444’。</li><li>port(可选参数)-即所要连接的端口号，如果在host中已经说明，port参数可以缺省，这里有个疑问，。Hyper官网上说的是如果host中不指名要访问的port，并且port参数也不设置的话，缺省是访问443端口，但是我自己在测试的过程中发现好像并不是这样的。<br>默认状态下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from hyper import HTTPConnection</span><br><span class="line">con = HTTPConnection(&apos;eclipsesv.com&apos;)</span><br><span class="line">Streamid = con.request(&apos;GET&apos;,&apos;/&apos;)</span><br><span class="line">print Streamid</span><br><span class="line">resp = con.get_response()</span><br><span class="line">print resp</span><br><span class="line">&apos;&apos;&apos;输出结果&apos;&apos;&apos;</span><br><span class="line">None</span><br><span class="line">&lt;hyper.http11.response.HTTP11Response object at 0x0000000002C722B0&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>指明使用443端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from hyper import HTTPConnection</span><br><span class="line">con = HTTPConnection(&apos;eclipsesv.com&apos;,443)</span><br><span class="line">Streamid = con.request(&apos;GET&apos;,&apos;/&apos;)</span><br><span class="line">print Streamid</span><br><span class="line">resp = con.get_response()</span><br><span class="line">print resp</span><br><span class="line">&apos;&apos;&apos;返回结果&apos;&apos;&apos;</span><br><span class="line">1</span><br><span class="line">&lt;hyper.http20.response.HTTP20Response object at 0x0000000002C5CDD8&gt;</span><br></pre></td></tr></table></figure></p><p>默认情况下，Streamid为None,指明端口443之后，Streamid返回1，这样的结果说明，缺省情况下访问的是80端口，并不是443。<br>在Hyper源码common/connection.py中，HTTPConnection类中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self,</span><br><span class="line">                 host,</span><br><span class="line">                 port=None,</span><br><span class="line">                 secure=None,</span><br><span class="line">                 window_manager=None,</span><br><span class="line">                 enable_push=False,</span><br><span class="line">                 ssl_context=None,</span><br><span class="line">                 proxy_host=None,</span><br><span class="line">                 proxy_port=None,</span><br><span class="line">                 **kwargs):</span><br><span class="line">        self._host = host</span><br><span class="line">        self._port = port</span><br><span class="line">        self._h1_kwargs = &#123;</span><br><span class="line">            &apos;secure&apos;: secure, &apos;ssl_context&apos;: ssl_context, </span><br><span class="line">            &apos;proxy_host&apos;: proxy_host, &apos;proxy_port&apos;: proxy_port </span><br><span class="line">        &#125;</span><br><span class="line">        self._h2_kwargs = &#123;</span><br><span class="line">            &apos;window_manager&apos;: window_manager, &apos;enable_push&apos;: enable_push,</span><br><span class="line">            &apos;secure&apos;: secure, &apos;ssl_context&apos;: ssl_context, </span><br><span class="line">            &apos;proxy_host&apos;: proxy_host, &apos;proxy_port&apos;: proxy_port</span><br><span class="line">        &#125;</span><br><span class="line">        # Add any unexpected kwargs to both dictionaries.</span><br><span class="line">        self._h1_kwargs.update(kwargs)</span><br><span class="line">        self._h2_kwargs.update(kwargs)</span><br><span class="line">        &apos;&apos;&apos;可以看到，默认情况下使用的是HTTP11Connection，这里应该是文档中的碧油鸡&apos;&apos;&apos;</span><br><span class="line">        self._conn = HTTP11Connection(</span><br><span class="line">            self._host, self._port, **self._h1_kwargs</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p><ul><li>secure(可选参数)-用以指明请求是否基于TLS连接。大多数情况下缺省值为False，如果访问服务器443端口缺省则变为True。</li><li>window_manager(可选参数)-这个参数可以是一个BaseFlowControlManager的子类，缺省情况下使用FlowControlManager。用以控制<a href="https://www.zhihu.com/question/32255109" target="_blank" rel="noopener">滑动窗口</a>。</li><li>enable_push(可选参数)-确定服务器是否使用服务器推送（主动推送资源给客户端）。</li><li>ssl_context(可选参数)-用以设置证书认证的选项，缺省情况下使用SSLContext替代。</li><li>proxy_host(可选参数)-代理服务器，可以是一个IP地址或者域名，可以带有端口号。</li><li>proxy_port（可选参数）-代理服务器端口，它和proxy_host的设置方法和host与port参数一致。<blockquote><p>方法</p></blockquote></li><li>request(method,url,body=Node,headers={})-使用method指定的方法，如’GET’或者’POST’和制定的URL来向服务器发送请求。<br>参数–method，指明请求的方法，如’GET’、’POST’等；url，指明要访问的路径，格式像这样：’/path/to/segement’；body（可选参数），必须是一个file-like对象（Python内置函数open()返回的有个read()方法的对象，除了file之外，还可以是内存的字节流、网络流、自定义流等）或者bytestring；headers(可选参数)-用以发送请求的headers。<br>返回值–返回一个StreamID，如果该条请求基于HTTP/1.1返回Node。</li><li>get_response(*args,**kwargs)-用以返回一个请求对象。</li></ul><h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><h2 id="HTTP20Connection"><a href="#HTTP20Connection" class="headerlink" title="HTTP20Connection"></a>HTTP20Connection</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class hyper.HTTP20Connection(host,port=None,secure=None,window_manager=None,</span><br><span class="line">enable_push=False,ssl_context=None,proxy_host=None,proxy_port=None,**kwargs)</span><br></pre></td></tr></table></figure><p>这个类表示的是一个向服务器发起的HTTP2连接，它的参数与HTTPConnection一致，参数的设置也类似，这里不再多说。</p><blockquote><p>方法</p><ul><li>close(error_code=None)，用以关闭与服务器的连接。可选参数error_code用以重置连接，此方法没有返回值。</li><li>connect()，当类HTTP20Connection创建好之后，用以连接制定的服务器，但是如果连接已经建立的话，此方法则变成空操作(no-op)，此方法没有返回值。</li><li>endheaders(message_body=None,final=False,stream_id=None)，发送预先准备好的请求头给服务器。如果参数message_body不为空，它也会被发送到服务器，当做请求体，并且这个流会立即关闭。如果参数final设置为True，请求流也会立即停止，随后调用send()方法以关闭该请求流。此方法无返回值。</li><li>get_pushes(stream_id=None,capture_all=False)，从服务器返回一个promise的生成器，需要注意的是，这个方法不是幂等的，promises在此方法一次调用之后，可能不会按照请求顺序返回。多个调用的返回值可能会引发未定义的行为。参数：stream_id(可选参数)-想要获取服务器推送的流ID；capture_all(可选参数)，如果设置为False，服务器推送的promise会以非阻塞的形式返回，而True则反之。此方法的返回值是一个服务器推送的HTTP20Push对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def get_pushes(self,stream_id=None,capture_all=False):</span><br><span class="line">stream = self._get_stream(stream_id)</span><br><span class="line">    for promised_stream_id, headers in stream.get_pushes(capture_all):</span><br><span class="line">        yield HTTP20Push(</span><br><span class="line">            HTTPHeaderMap(headers), self.streams[promised_stream_id]</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li>get_response(stream_id=None)，此方法在使用request之后使用，request方法的返回值stream_id作为此方法的参数。此方法返回值为一个HTTP20Response对象。</li><li>network_buffer_size，这是HTTP20Connection类默认的一个参数，它是一个内存缓冲区用以存储从网络中获取的数据。可以用来进行调优。</li><li>putheader(header,argument,stream_id=None)，将一个HTTP的请求头发送到服务器，与httplib库中此方法不同的是，调用此方法实际上并不会发送数据到服务器，它仅仅是为endheaders()方法的headers进行排序，它会确保发送到服务器的请求头符合HTTP/2的标准，并且它会剔除一些HTTP/2中无用的参数。</li><li>putrequest(method,selector,**kwargs)，这个方法是向服务器发送请求的第一步，返回一个streamid。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&apos;它在request方法中的使用&apos;</span><br><span class="line">def request(self, method, url, body=None, headers=&#123;&#125;):</span><br><span class="line">stream_id = self.putrequest(method, url)</span><br><span class="line"></span><br><span class="line">    for name, value in headers.items():</span><br><span class="line">        self.putheader(name, value, stream_id)</span><br><span class="line"></span><br><span class="line">    # Convert the body to bytes if needed.</span><br><span class="line">    if isinstance(body, str):</span><br><span class="line">        body = body.encode(&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line">    self.endheaders(message_body=body, final=True, stream_id****=stream_id)</span><br><span class="line">    return stream_id</span><br></pre></td></tr></table></figure><ul><li>receive_frame(frame)，用以接收构成stream的帧。</li><li>request(method,url,body=None,headers={})，使用putrequest方法来向服务器发送请求。</li><li>send(data,final=Flase,stream_id=None)，向服务器发送数据，这些数据会立即发送到服务器，如果这些数据是最后要发送的部分，参数final应该设置为True，这样请求流就会关闭。</li></ul><h2 id="HTTP20Response"><a href="#HTTP20Response" class="headerlink" title="HTTP20Response"></a>HTTP20Response</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class hyper.HTTP20Response(headers,stream)</span><br></pre></td></tr></table></figure><p>HTTP20Response用以代表从服务器上得到的HTTP2响应，它提供了获取响应头和响应实体的方法。响应是一个可迭代的对象也可用于声明对象。</p><blockquote><p>方法</p><ul><li>close()，关闭响应，实际上是关闭了后续的额HTTP2数据流。方法无返回值。</li><li>fileno()，返回基础套接字的文件描述词，此方法当前不可用。</li><li>read(amt=None,decode_content=True)，获取响应实体。参数：amt(可选参数)，设置要读取的数据量，缺省情况下会返回所有的响应实体；decode_content(可选参数)，缺省为True,将返回的数据解码。</li><li>read_chunked(decode_content=True),返回经过编码的数据块。此方法返回一个迭代器，每次迭代都会返回一帧的数据。</li><li>reason=None,返回服务器响应的原因短语。</li><li>status=None,返回服务器响应的状态码。</li></ul></blockquote><h2 id="HTTP20Push"><a href="#HTTP20Push" class="headerlink" title="HTTP20Push"></a>HTTP20Push</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class hyper.HTTP20Push(request_headers,stream)</span><br></pre></td></tr></table></figure><p>HTTP20Push代表通过服务器推送机制被发送出来的一个请求/响应。</p><blockquote><p>方法</p><ul><li>cancel()取消已经推送的数据并且关闭该数据流。此方法无返回值。</li><li>get_response()获取服务器推送的数据。返回一个HTTP20Response对象。</li></ul></blockquote><h1 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h1><ul><li>HTTP/1.1</li><li>Headers</li><li>SSLContext</li><li>Requests Transport Adapter</li><li>Flow Control</li><li>Exceptions</li></ul><h1 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h1><ul><li>2016/3/21更新了HTTP/2</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>邮件传输协议笔记</title>
      <link href="/2016/03/15/0326/"/>
      <url>/2016/03/15/0326/</url>
      
        <content type="html"><![CDATA[<p>网易春招，投了邮件事业部的运维工程师岗位，以前没怎么接触过邮件这块内容，特此记录学习内容。<br><a id="more"></a></p><h1 id="几个定义"><a href="#几个定义" class="headerlink" title="几个定义"></a>几个定义</h1><h2 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h2><p>邮件是一种消息的格式，由信封、首部和正文组成。信封上最重要的是收件人的地址，邮件服务器使用这个地址将邮件发送到受信人所在的邮件服务器上；首部是有用户代理或邮箱服务器添加的一些信息；正文则是发送用户发送给接收用户报文的内容。</p><h2 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h2><p>用户代理是用户与电子邮件系统的交互接口，一般来说他就是我们PC上的一个程序，比如说Foxmail和Outlook等。</p><h2 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h2><p>邮件服务器是电子邮件系统的核心，它用来发送和接收邮件，可以在任何时候为用户提供服务。比如说smtp.163.com。</p><h1 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h1><p>SMTP，简单邮件传送协议，和http等多数应用层协议一样，它通过TCP连接实现邮件在网络中的传送。SMTP用来将客户机上的邮件传送到服务器上或者是从一个邮件服务器转发到另外一个邮件服务器。</p><h2 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h2><p>一个SMTP通信过程如下：</p><ul><li>发送端邮件服务器与接收端邮件服务器25端口建立TCP连接</li><li>客户端向服务器发送各种命令，请求各种服务，例如认证、指定发送人和接收人</li><li>服务器解析用户命令，做出相应操作返回相应给客户端</li><li>重复第二第三步，直至邮件发送完成或者连接中断。<h2 id="Telnet测试SMTP"><a href="#Telnet测试SMTP" class="headerlink" title="Telnet测试SMTP"></a>Telnet测试SMTP</h2>使用Telnet工具，使用SMTP模拟发送邮件过程：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ telnet smtp.163.com 25    //键入邮件服务器名以及端口号25 建立连接</span><br><span class="line">Trying 220.181.12.16...</span><br><span class="line">Connected to smtp.163.com.  //连接建立成功</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">220 163.com Anti-spam GT for Coremail System (163com[20141201])</span><br><span class="line">HELO smtp.163.com          //HELO 用以和服务器完成握手</span><br><span class="line">250 OK</span><br><span class="line">AUTH LOGIN   //AUTH LOGIN 开始认证登录</span><br><span class="line">334 dXNlcm5hbWU6</span><br><span class="line">ZWMZNsaXBzZV9zdg==   //以Base64加密的邮箱用户名</span><br><span class="line">334 UGFzc3dvcmQ6</span><br><span class="line">d456xNjg5MTM=   //以Base64加密的邮箱密码</span><br><span class="line">235 Authentication successful   //认证成功</span><br><span class="line">MAIL FROM:&lt;xxxx@163.com&gt;  //邮件发送方</span><br><span class="line">250 Mail OK</span><br><span class="line">RCPT TO:&lt;xxxx@qq.com&gt;//邮件接收方</span><br><span class="line">250 Mail OK</span><br><span class="line">DATA Just a try for smtp</span><br><span class="line">500 Error: bad syntax</span><br><span class="line">DATA//开始写入邮件内容</span><br><span class="line">354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">TO: xxxxx@qq.com//接收方</span><br><span class="line">FROM: xxxxx@163.com//发送方</span><br><span class="line">SUBJECT: Just a try for SMTP  //邮件主题</span><br><span class="line">  //隔空一行</span><br><span class="line">This is a test,not for real.  //邮件内容</span><br><span class="line">.  //邮件以.加回车键结尾</span><br><span class="line">250 Mail OK queued as smtp12,EMCowEAJp0UnlvZWz6MLAA--.4874S2 1459001194</span><br><span class="line">QUIT  //结束通信</span><br><span class="line">221 Bye</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure><h1 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h1><p>POP3，邮局协议第三版。它被用户代理用来从邮件服务器去的邮件。与SMTP一样它也是一个应用层协议，端口110。POP3协议有三种状态，认证状态、处理状态和更新状态。客户端和服务器刚建立连接时处于认证状态；认证成功后进入处理状态；完成用户命令在用户使用QUIT命令之后进入更新状态。</p><h2 id="通信过程-1"><a href="#通信过程-1" class="headerlink" title="通信过程"></a>通信过程</h2><p>用户代理从邮件服务器上接收邮件的过程如下：</p><ul><li>用户运行用户代理</li><li>用户代理与邮件服务器110端口建立TCP连接</li><li>客户端向服务器端发送各种命令，请求服务，例如查询邮箱信息、下载邮件等</li><li>服务器解析用户命令，做出相应响应</li><li>重复3、4步骤</li><li>用户代理将获取到的数据呈现给用户</li></ul><h2 id="Telnet测试POP3"><a href="#Telnet测试POP3" class="headerlink" title="Telnet测试POP3"></a>Telnet测试POP3</h2><p>使用Telnet工具，测试POP3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">telnet pop.163.com 110 #telnet登录110端口</span><br><span class="line">Trying 202.108.5.104...</span><br><span class="line">Connected to pop.163.com.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">+OK Welcome to coremail Mail Pop3 Server (163com[20050206])</span><br><span class="line">USER xxxx # 用户名</span><br><span class="line">+OK core mail</span><br><span class="line">PASS xxxxx # 登录密码</span><br><span class="line">+OK 254 message(s) [27676669 byte(s)]</span><br><span class="line">STAT # 查看邮箱状态</span><br><span class="line">+OK 254 27676669</span><br><span class="line">LIST # 邮件列表</span><br><span class="line">+OK 354 27676669</span><br><span class="line">1 2468</span><br><span class="line">2 21945</span><br><span class="line">3 33136</span><br><span class="line">4 2071</span><br><span class="line">5 3364</span><br><span class="line">6 18906</span><br><span class="line">7 3136</span><br><span class="line">8 24764</span><br><span class="line">.................</span><br><span class="line"></span><br><span class="line">TOP 254 0 # 查看指定邮件的邮件头，0表示查看整个邮件头，其它正整数表示限制返回多少行。</span><br><span class="line">+OK core mail</span><br><span class="line">Received: from smtp.63.com (unknown [58.252.70.158])</span><br><span class="line">by smtp5 (Coremail) with SMTP id wKjREDrA9gIfFqlEjCnRAg==.29062S4;</span><br><span class="line">Mon, 03 Jul 2006 21:07:18 +0800 (CST)</span><br><span class="line">TO: crazywill@163.com</span><br><span class="line">FROM : cccc@163.com # 这里即前面发信时伪造的一个假发送人信息，平时正常操作只显示这个。</span><br><span class="line">SUBJECT: test by telnet/smtp # 邮件主题</span><br><span class="line">Message-Id: &lt;44A91687.0E6F6C.07562&gt;</span><br><span class="line">Date: Mon, 3 Jul 2006 21:07:19 +0800 (CST)</span><br><span class="line">Sender: crazywill@163.com # 这里是真正的发送人，不可伪造。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">RETR 254 # 获取指定邮件</span><br><span class="line">+OK 354 octets</span><br><span class="line">Received: from smtp.63.com (unknown [58.252.70.158])</span><br><span class="line">by smtp5 (Coremail) with SMTP id wKjREDrA9gIfFqlEjCnRAg==.29062S4;</span><br><span class="line">Mon, 03 Jul 2006 21:07:18 +0800 (CST)</span><br><span class="line">TO: crazywill@163.com</span><br><span class="line">FROM : cccc@163.com</span><br><span class="line">SUBJECT: test by telnet/smtp</span><br><span class="line">Message-Id: &lt;44A91687.0E6F6C.07562&gt;</span><br><span class="line">Date: Mon, 3 Jul 2006 21:07:19 +0800 (CST)</span><br><span class="line">Sender: crazywill@163.com</span><br><span class="line"></span><br><span class="line">test, just a test.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">DELE 254 # 删除第254封邮件</span><br><span class="line">+OK core mail</span><br><span class="line">STAT # 查看邮箱状态</span><br><span class="line">+OK 253 27676315</span><br><span class="line">QUIT # 退出</span><br><span class="line">+OK core mail</span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure></p><h1 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h1><p><a href="http://363918.blog.51cto.com/353918/739650" target="_blank" rel="noopener">使用telnet测试smtp和pop3协议</a><br><a href="http://blog.csdn.net/bripengandre/article/details/2191048" target="_blank" rel="noopener">SMTP协议分析</a><br><a href="http://blog.csdn.net/bripengandre/article/details/2192111" target="_blank" rel="noopener">POP3协议分析</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Learning Hyper</title>
      <link href="/2016/03/14/Learning%20Hyper/"/>
      <url>/2016/03/14/Learning%20Hyper/</url>
      
        <content type="html"><![CDATA[<p>16年3月12日早晨九点半，离开北京，结束了读研生涯的出差之路。在未来两个月将把精力集中放在毕业论文上。由于毕设大量内容与HTTP2.0相关（这不，现在博客已经在Nginx的支持下转为HTTP2.0了，绿色的小锁看起来很顺眼呢），同时自己也在学习Python，特此记录学习过程。<br><a id="more"></a></p><h1 id="毕设内容"><a href="#毕设内容" class="headerlink" title="毕设内容"></a>毕设内容</h1><p>读研期间，做的内容主要是关于实时可视化中所用到的海量瓦片数据，包括瓦片数据切分、瓦片数据库构建、瓦片服务器端高速缓存等等内容。现在回头看看以前耗费了大量时间精力做出来的东西可能仅仅就是个玩具，在实际应用中很可能会崩崩崩，但是我这个人就是喜欢鼓捣些新鲜的东西。去年敲定的HTTP2.0协议，我也是一直关注了很久，<a href="https://imququ.com/" target="_blank" rel="noopener">屈大神的博客</a>相关资料也挺多，其中推荐的几本书也都十分不错。我觉得HTTP2.0的新特性头部压缩、多路复用以及服务器推送都可以在海量小数据传输中发挥很好的效果。</p><blockquote><p>##头部压缩###<br>通过头部压缩，可以有效的降低海量瓦片数据在传输过程中相似请求头部所消耗不必要的流量，通过减少总体数据流量来提高数据传输效率是一个不错的方法。</p><p>##多路复用##<br>通过客户端向瓦片服务器简历的一条HTTP2连接，可以获取多个瓦片数据，有效降低由于TCP建立连接握手分手所占的时间消耗，瓦片服务器也可以按照优先级顺序传送瓦片数据到客户端。</p><p>##服务器推送##<br>这个是我认为对瓦片数据传输效率提升最大的地方，以往的数据传输，即使服务器知道下一步客户端将要请求的数据，它也没法主动将数据推送给客户端，但是HTTP2.0可以实现这点，我们可以在服务器端通过解析当前数据请求的特点推测下一步可能要被请求的数据，提前将数据推送给客户端，有效的提升可视化效果。</p></blockquote><h1 id="Hyper"><a href="#Hyper" class="headerlink" title="Hyper"></a>Hyper</h1><p><a href="https://hyper.readthedocs.org/en/latest/" target="_blank" rel="noopener">Hyper</a>是Python版本的HTTP2.0客户端，其他的开发语诸如Javascript、Go、Java等都有对应的协议实现，可以在<a href="https://github.com/search?utf8=%E2%9C%93&amp;q=http2" target="_blank" rel="noopener">这里</a>找到你想要的客户端。<br>Hyper是一个使用纯粹Python编写的库，它可以在Python3.4或者Python2.7.9或者更高的版本上运行，除了HTTP2.0它也完成了HTTP1.1的实现。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>想要使用Hyper之前，当然要把它安装在你的开发环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install hyper</span><br></pre></td></tr></table></figure></p><p>简单一句话即可搞定。<br>需要注意的是，HTTP2.0需要建立在TLS（安全传输层协议）之上。如果使用的是Python3.4或者更高的版本就不需要担心这些，如果是较早的版本则需要使用PyOpenSSL来提供TLS的支持。</p><h2 id="走起"><a href="#走起" class="headerlink" title="走起"></a>走起</h2><p>在安装了Hyper之后，可以通过下面简单的代码进行HTTP请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from hyper import HTTPConnection</span><br><span class="line">con = HTTPConnection(&apos;eclipsesv.com&apos;)</span><br><span class="line">con.request(&apos;GET&apos;,&apos;/&apos;)</span><br><span class="line">resp = con.get_response()</span><br><span class="line">print resp.headers</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;输出内容&apos;&apos;&apos;</span><br><span class="line">HTTPHeaderMap([(&apos;Server&apos;, &apos;nginx/1.9.7&apos;), (&apos;Date&apos;, &apos;Mon, 14 Mar 2016 14:41:08 GMT&apos;), (&apos;Content-Type&apos;, &apos;text/html&apos;), (&apos;Content-Length&apos;, &apos;184&apos;), (&apos;Connection&apos;, &apos;keep-alive&apos;), (&apos;Location&apos;, &apos;https://eclipsesv.com/&apos;)])</span><br></pre></td></tr></table></figure></p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>今天就先到这里，接下来的几篇内容会按照Hyper官网提供的API进行一些简单的试验，为论文试验做好准备。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>半吊子非专业程序员的成长历程</title>
      <link href="/2015/12/10/1210/"/>
      <url>/2015/12/10/1210/</url>
      
        <content type="html"><![CDATA[<p>人年龄一大，就喜欢回忆从前的过往。<br>想想自己这个半吊子非专业程序员，一路走来的点点滴滴，确实值得记录一下。<br><a id="more"></a></p><h1 id="小霸王让我知道了编程"><a href="#小霸王让我知道了编程" class="headerlink" title="小霸王让我知道了编程"></a>小霸王让我知道了编程</h1><p>大约在我小学三四年纪的时候，在外读书的舅舅给我和弟弟买了个小霸王学习机（大人当然都是本着让小孩好好学习的目的），里边顺便带了张游戏卡，我记得里边有双截龙、拳皇。插上电视，我和老弟一人一个手柄，打得飞起。假期打到手疼，平时上学偷着玩。好景不长，那张卡打了有半年光景就坏了，找了一个学校高年级的问为什么坏了，他告诉我那个卡带上黑色的一坨东西坏了。舅舅从学校回来后，问他能不能修得好，他说不行，那个黑色的一坨叫做绑定封装，是把芯片通过极细的导线于电路板连接后，滴一滴黑色的胶在上面，达到阻隔光线等外界影响的效果，坏了没法修。我继续问，那里边的游戏是怎么做的，他当时说了一个特别高大上的词“编程”。</p><h1 id="从小就有成为大神的梦想"><a href="#从小就有成为大神的梦想" class="headerlink" title="从小就有成为大神的梦想"></a>从小就有成为大神的梦想</h1><p>打那之后，在电视上，书上多多少少都会看到一些关于“编程”的东西，比如警察破案，黑窗口上闪得飞快的命令行；比如当时的世界首富比尔盖茨以前也是编程高手。自己就在心里想着，以后好好学习，也去学习编程，成为大神。</p><h1 id="阴差阳错的C井"><a href="#阴差阳错的C井" class="headerlink" title="阴差阳错的C井"></a>阴差阳错的C井</h1><p>时间跑的飞快，紧张的高中三年，每天沉浸在语数外理化生中，高考之后，在一个闲适的午后，我爸妈告诉我，我被华北水院录取了，地理信息系统专业。我寻思这是啥专业啊，都没听过，不过应该是跟地理有关的，好在我地理还算比较好的，应该还可以吧。<br>到学校后，听学长说我们专业需要“编程”，我仿佛又想起了小时候的梦想，“那我该怎么入门呢？”,我弱弱的问。“CSharp你可以先学，学会了其他的编程语言也就好学了。”<br>编程语言，有一个高大上的名词。按照师兄说的CSharp，我去到图书馆一个一个的找，有C、C++、C井、JAVA…可就是没找到他说的CSharp，我就问图书管理员，咱们这边CSharp的书都放在哪里，他瞥了我一眼，“你看，不就在你背后嘛。”我回过身，“这不是C井吗?”心里想，这人居然还蒙骗大一新生。“同学，你一年级吧，这个不读C井，这就是CSharp。”这下糗大了…</p><h1 id="第一个蹩脚小程序"><a href="#第一个蹩脚小程序" class="headerlink" title="第一个蹩脚小程序"></a>第一个蹩脚小程序</h1><p>时间一直持续到大二暑假前，专业课老师才开始给我们讲一些编程方面的东西，也正是这个老师正式开启了我后来的编程之路。后来又陆陆续续学习了计算机网络、数据结构这些课程。在这个老师的带领下，第一次配置SQL Server，第一次完成了一个蹩脚的信息管理系统，也是第一次在课堂上被夸奖（其实大学阶段，我在宿舍和图书馆的时间要比去上课的时间多得不要太多，以至于毕业的时候，我们专业的人我都认不全）。顺便贴上当年的第一个小程序<br><img src="http://7xkswi.com1.z0.glb.clouddn.com/eclipsesv_jpg第一个蹩脚程序.jpg" alt="">.</p><h1 id="考研期间的疯狂涉猎"><a href="#考研期间的疯狂涉猎" class="headerlink" title="考研期间的疯狂涉猎"></a>考研期间的疯狂涉猎</h1><p>我这个人，就是那种后知后觉，比较呆傻的那种，别人看着是大智若愚，我可是货真价实的傻。别人疯狂自习准备考研的时候，我在打游戏，别人去考研的时候，我还在打游戏。直到大四下学期，在家过了年，再加上一些特殊的原因，我决定，我得去考研才行（因为在大学期间学到的东西确实太少了，怪我自己，我太贪玩）。适逢从小玩到大的好哥们也在考研，我便搬去和他一起并肩作战。在河南理工复习考研，每天都在图书馆自习室看书。偶尔会想，如果考上了，自己这么水怎么行，听说那边人编程都很厉害，我也得厉害点才行。于是，河南理工图书馆计算机相关的书籍被我承包了，PHP、JavaScript、C++、Python、做魔兽世界插件的Lua，有的没的我都看过（当然，那大半年时间，没少看书福尔摩斯探案、冰与火之歌、电影谍影重重的原著伯恩系列等等等等）。就这样，2014年1月3号我记得，顶着快要下山的月亮，在好友的陪同下坐上了回家考试的车。考完之后，就没想考不上的事情，这要是再考不上，就没人能考得上了（就是这么自信）。</p><h1 id="读研期间全新的篇章"><a href="#读研期间全新的篇章" class="headerlink" title="读研期间全新的篇章"></a>读研期间全新的篇章</h1><p>本着学好技术的目的，14年7月12号，我来到武大，14年下半年，我分别接触了WPF、Redis、MongoDB，Github也是打那时候才开始用的。开源软件的蓬勃发展，确实让我感到震惊，也暗暗下定决心，我以后也要成为能有上千个Star的选手（虽然至今都没有一个Star,=.=)。15年上半年，自我感觉是成长最大的一段时间，从Web服务器，TCP/IP协议，各类主流NoSQL数据库，内存数据库集群，服务器端脚本等等，以前从书上看到的东西，从我的一个一个VISIO图落地实现。<br>15年9月份到11月，从另外一个角度让我成长，一个又一个面试失败，让我发现，自己做的东西都只是玩具，跟真正达到高性能、高可用的状态相去甚远。同时，极限编程、敏捷开发、TDD等等以前也只是在书上看到的东西，成为了面试官评判实力的标准。</p><h1 id="脚踏实地"><a href="#脚踏实地" class="headerlink" title="脚踏实地"></a>脚踏实地</h1><p>作为一个蹩脚的半吊子非专业选手，未来的路还很长，我打算从以下几点提升自己的水平：</p><ul><li>传统的关系型数据库（MySQL PostGreSQL）</li><li>设计模式</li><li>数据结构</li><li>深入学习全栈JavaScript开发</li><li>Linux日常操作（听新浪的面试官大叔说熟练操作鸟哥私房菜就可以啦）</li></ul><h1 id="仰望星空"><a href="#仰望星空" class="headerlink" title="仰望星空"></a>仰望星空</h1><p>和三哥一起在珞珈山上走圈，抬头看到满天繁星，我什么时候才能有那么多的Star。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心情文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C#中的virtual、abstract和interface</title>
      <link href="/2015/10/28/C-%E4%B8%AD%E7%9A%84virtual%E5%92%8Cabstract/"/>
      <url>/2015/10/28/C-%E4%B8%AD%E7%9A%84virtual%E5%92%8Cabstract/</url>
      
        <content type="html"><![CDATA[<p><small><a href="http://www.cnblogs.com/blsong/archive/2010/08/12/1798064.html" target="_blank" rel="noopener">本文转自</a></small></p><hr><p>在C#的学习中，容易混淆virtual方法和abstract方法的使用，现在来讨论一下二者的区别。二者都牵涉到在派生类中与override的配合使用。<br><a id="more"></a></p><h1 id="Virtual方法（虚方法）"><a href="#Virtual方法（虚方法）" class="headerlink" title="Virtual方法（虚方法）"></a>Virtual方法（虚方法）</h1><p>virtual 关键字用于在基类中修饰方法。virtual的使用会有两种情况：<br>情况1：在基类中定义了virtual方法，但在派生类中没有重写该虚方法。那么在对派生类实例的调用中，该虚方法使用的是基类定义的方法。<br>情况2：在基类中定义了virtual方法，然后在派生类中使用override重写该方法。那么在对派生类实例的调用中，该虚方法使用的是派生重写的方法。</p><h1 id="Abstract方法（抽象方法）"><a href="#Abstract方法（抽象方法）" class="headerlink" title="Abstract方法（抽象方法）"></a>Abstract方法（抽象方法）</h1><p>abstract关键字只能用在抽象类中修饰方法，并且没有具体的实现。抽象方法的实现必须在派生类中使用override关键字来实现。</p><h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><p>最本质的区别：抽象类是一个不完全的类，是对对象的抽象，而接口是一种行为规范。<br>C# 是面向对象的程序设计语言，每一个函数都属于一个类。<br>Static：当一个方法被声明为Static时，这个方法是一个静态方法，编译器会在编译时保留这个方法的实现。也就是说，这个方法属于类，但是不属于任何成员，不管这个类的实例是否存在，它们都会存在。就像入口函数Static void Main，因为它是静态函数，所以可以直接被调用。<br>Virtual：当一个方法被声明为Virtual时，它是一个虚拟方法，直到你使用ClassName variable = new ClassName();声明一个类的实例之前，它都不存在于真实的内存空间中。这个关键字在类的继承中非常常用，用来提供类方法的多态性支持。<br>abstract：抽象方法声明使用，是必须被派生类覆写的方法，抽象类就是用来被继承的；可以看成是没有实现体的虚方法；如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法；抽象类不能有实体的。</p><h1 id="Talk-is-cheap-Let’s-code"><a href="#Talk-is-cheap-Let’s-code" class="headerlink" title="Talk is cheap,Let’s code"></a>Talk is cheap,Let’s code</h1><p>interface:用来声明接口<br>1.只提供一些方法规约，不提供方法主体. 如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IPerson</span><br><span class="line">&#123;</span><br><span class="line">void getName();//不包含方法主体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.方法不能用public abstract等修饰,无字段变量，无构造函数。<br>3.方法可包含参数。 如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IPerson</span><br><span class="line">&#123;</span><br><span class="line">void getAge(string s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个例子(例1)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface IPerson</span><br><span class="line">&#123;</span><br><span class="line">    IPerson(); //错误</span><br><span class="line">    string name; //错误</span><br><span class="line">    public void getIDcard();//错误</span><br><span class="line">    void getName(); //right</span><br><span class="line">    void getAge(string s); //right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实现interface的类<br>1.与继承类的格式一致，如 public class Chinese:IPerson{}<br>2.必须实现 interface 中的各个方法<br>例2，继承例1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Chinese:IPerson</span><br><span class="line">&#123;</span><br><span class="line">    public Chinese()&#123;&#125; //添加构造</span><br><span class="line">    public void getName()&#123;&#125; //实现getName()</span><br><span class="line">    public void getAge(string s)&#123;&#125; //实现getAge()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>abstract:声明抽象类、抽象方法<br>1.抽象方法所在类必须为抽象类<br>2.抽象类不能直接实例化，必须由其派生类实现。<br>3.抽象方法不包含方法主体，必须由派生类以override方式实现此方法,这点跟interface中的方法类似<br>如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Book</span><br><span class="line">&#123;</span><br><span class="line">    public Book()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract void getPrice(); //抽象方法，不含主体</span><br><span class="line">    public virtual void getName() //虚方法，可覆盖</span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(&quot;this is a test:virtual getName()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public virtual void getContent() //虚方法，可覆盖</span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(&quot;this is a test:virtual getContent()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void getDate() //一般方法，若在派生类中重写，须使用new关键字</span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(&quot;this is a test: void getDate()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JavaBook:Book</span><br><span class="line">&#123;</span><br><span class="line">    public override void getPrice() //实现抽象方法，必须实现</span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(&quot;this is a test:JavaBook override abstract getPrice()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public override void getName() //覆盖原方法，不是必须的</span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(&quot;this is a test:JavaBook override virtual getName()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class test</span><br><span class="line">&#123;</span><br><span class="line">    public test()</span><br><span class="line">    &#123;</span><br><span class="line">        JavaBook jbook=new JavaBook();</span><br><span class="line">        jbook.getPrice(); //将调用JavaBook中getPrice()</span><br><span class="line">        jbook.getName(); //将调用JavaBook中getName()</span><br><span class="line">        jbook.getContent(); //将调用Book中getContent()</span><br><span class="line">        jbook.getDate(); //将调用Book中getDate()</span><br><span class="line">    &#125;</span><br><span class="line">    public static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">    test t=new test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>virtual:标记方法为虚方法<br>1.可在派生类中以override覆盖此方法<br>2.不覆盖也可由对象调用<br>3.无此标记的方法(也无其他标记)，重写时需用new隐藏原方法<br>abstract 与virtual : 方法重写时都使用 override 关键字接口定义以大写字母I开头。方法只定义其名称,在C#中，方法默认是公有方法；用public修饰方法是不允许的,否则会出现编译错误；接口可以从别的接口继承，如果是继承多个接口，则父接口列表用逗号间隔。<br>接口可以通过类来实现，当类的基列表同时包含基类和接口时，列表中首先出现的是基类；类必须要实现其抽象方法；<br>接口使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace Dage.Interface</span><br><span class="line">&#123;</span><br><span class="line">    //打印机接口</span><br><span class="line">    public interface IPrint</span><br><span class="line">    &#123;</span><br><span class="line">    string returnPrintName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//--------------------------------------------</span><br><span class="line">using System;</span><br><span class="line">using Dage.Interface;</span><br><span class="line">namespace Dage.Print</span><br><span class="line">&#123;</span><br><span class="line">    //HP牌打印机类</span><br><span class="line">    public class HP: IPrint</span><br><span class="line">    &#123;</span><br><span class="line">        public string returnPrintName()</span><br><span class="line">        &#123;</span><br><span class="line">        return &quot;这是HP牌打印机&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//--------------------------------------------</span><br><span class="line">using System;</span><br><span class="line">namespace Dage.Print</span><br><span class="line">&#123;</span><br><span class="line">    //Eps牌打印机类</span><br><span class="line">    public class Eps: IPrint</span><br><span class="line">    &#123;</span><br><span class="line">        public string returnPrintName()</span><br><span class="line">        &#123;</span><br><span class="line">        return &quot;这是Eps牌打印机&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//--------------------------------------------</span><br><span class="line">using System;</span><br><span class="line">using Dage.Interface;</span><br><span class="line">namespace Dage</span><br><span class="line">&#123;</span><br><span class="line">    //打印类</span><br><span class="line">    public class Printer</span><br><span class="line">    &#123;</span><br><span class="line">        public Printer()</span><br><span class="line">        &#123;&#125;</span><br><span class="line">        public string PrintName(IPrint iPrint)</span><br><span class="line">        &#123;</span><br><span class="line">        return iPrint.returnPrintName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//--------------------------------------------</span><br></pre></td></tr></table></figure></p><p>–WinFrom中调用代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void button1_Click(object sender, System.EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    Printer p= new Printer();</span><br><span class="line">    switch (this.comboBox1.Text)</span><br><span class="line">    &#123;</span><br><span class="line">        case &quot;HP&quot;:</span><br><span class="line">        MessageBox.Show(p.PrintName(new HP()));</span><br><span class="line">        break;</span><br><span class="line">        case &quot;Eps&quot;:</span><br><span class="line">        MessageBox.Show(p.PrintName(new Eps()));</span><br><span class="line">        break;</span><br><span class="line">        default:</span><br><span class="line">        MessageBox.Show(&quot;没有发现这个品牌！&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>15年的9月和10月</title>
      <link href="/2015/10/20/15%E5%B9%B4%E7%9A%849%E6%9C%88%E5%92%8C10%E6%9C%88/"/>
      <url>/2015/10/20/15%E5%B9%B4%E7%9A%849%E6%9C%88%E5%92%8C10%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<p>仅以此文，今年找工作的这两个月，虽然仍然没有拿到offer,但是需要静下心来仔细思索一下了。<br><a id="more"></a><br>9月22号，接到了来自网易游戏的面试通知短信，心里很是开心，没想到那么难的笔试也可以通过。<br>9月25号，一大早就起床，坐车来到光谷，8点半不到就到了酒店，我是9点15面试的，等着面试的那会，心里忐忑不已，毕竟自己非计算机科班出身，再加上网易游戏是出了名的难进，在那里等待面试也真是如坐针毡。果不其然，终于轮到我了，两个面试官很和蔼的开门，然后坐下拿着我的简历看了一遍，问了一些很基础的问题：解释一下僵尸进程；详细描述一下TCP连接中三次握手和四次挥手；给出一个场景，写出SQL语句……虽然问的问题都很基础，但是自己平时也是知其然不知其所以然，每个问题都能说上一点，但是都不深入。果然，40分钟不到，两位面试官都说自己没什么问了，今天的面试就到此为止了。灰溜溜的走出酒店，自知希望渺茫，果然，一面之后再无音讯。就这样，错失了自己最想要进的公司。<br>错过网易游戏之后，就开始海投，各种公司。<br>10月14号，值得纪念的一天。早起，准备上午11点半在武汉理工的深信服面试，能够走到面试，也实属不易。对于以前只是听过VPN的我来说，需要补充的知识太多，在面试之前，也是广泛的搜集相关的东西恶补。不到十点，打印好简历便出发了，一直在等着，11点40左右，面试官喊了6个人一起进去面试，我才刚刚知道居然是群面，这对于从来不喜欢在众人面前说话的我来说，真的是一个挑战。面试结果也是可想而知，相比于身经百战的面霸们，我自然是相形见绌。<br>中午回到学校已经是1点半，只能去买些泡面，火腿来吃。下午两点半，去参加ThoughtWorks（后称TW）的宣讲会，同样的，这家公司我也是仰慕许久，我很欣赏他们对于编程的态度，对于软件工程的看法，我也很希望能够和他们那样的人工作在一起。宣讲之后，便开始了笔试，作为一家与众不同的公司，他们的笔试也是独出心裁，做着他们的笔试题，自己仿佛正如TW的HR所说，变身成为一台计算机，按照一条条指令运行得出最终结果。很快，一个半小时过去，交上答卷。<br>毕竟已经是10月份，进入秋天，天黑的果然早了许多，5点半回到宿舍，接到新浪的面试通知，晚上7点。心想着特么的，我笔试大题都没做，这让我去面试，不能到了打我一顿吧？但是，在宿舍闲着也是闲着，不如去碰碰运气吧。一个人，喝着一瓶酸奶，6点半到了面试地点，发现人还很多。7点准时，面试官喊我过去。这次面试是我经历所有面试感觉最好的一次了，倒不是说自己表现很好，而是觉得新浪的面试官人都超级好。我投的数据库方向的岗位，面试官拿着我的简历和笔试卷子看了一下说，你笔试大题都没做啊。我也只好说自己数据结构和算法相关的基础比较薄弱。面试官也并没有为难，继续接着问一些项目上的问题和数据库相关的内容，跟他一交流，发现自己做的东西真的是太渣了，聊了半个小时，他说没什么问的了，你先出去稍等下二面。二面的面试官也很和蔼，看着简历和一面面试官的面试信息，上来就让我用Shell利用STMP协议自动发送系统警报邮件。这玩意，很早以前做过，现在也早已经忘记了；然后又问，如何在Linux系统中挂载磁盘，我只知道mount命令，如何一步步创建文件系统、挂载磁盘平日里也没用过…然后又问了一些更加细节的问题，这下肯定更招架不住。他说，你这本科学的地理信息系统，读研又是测绘工程，现在来找计算机的工作，这真是不容易。我笑笑问他，像我这样的，怎样才能比较快速的提高自己的技术水平。他思考了两秒，说道，首先你要有个人给你引路，这样才知道在面对问题的时候，什么问题需要优先解决、问题如何解决、什么问题不需要考虑…而且，如果想要对某种技术有深入研究，你必须打下一个稳固的基础…是啊，自己在平时也是只能摸着石头过河，也没有系统化的学习过计算机相关的内容，也只能怪平时太贪玩，太懒，到真正高技术的人面前，真的是原形毕露。不过我也很开心了，毕竟在这次面试中学习到了不少东西，而且按照面试官的推荐，想要用好Linux，命令必须熟练，当天晚上回到宿舍，立即在网上买了鸟哥私房菜。搞技术的，真的是要扎扎实实，踏踏实实。<img src="http://7xkswi.com1.z0.glb.clouddn.com/eclipse_svlinux.jpg" alt="鸟哥私房菜"><br>很快，TW通知笔试通过，10月16号，认认真真做了大半天代码作业，下午提交了，很快，当天晚上就收到了反馈，通知17号下午4点去面试。心里既兴奋又紧张，心想这次一定要成功。4点的面试，我3点就到了光谷，在休息室候着，相比网易游戏的那次面试，这次就轻松了许多。大概4点一刻，喊我过去面试，一面是HR面，HR很nice，在校招的时候我也见过，做了简短的自我介绍，HR也根据一系列的问答，观察一些细节，记录我的表现，自己感觉最糟糕的就是一段英语的对话，事先没有准备充分，搞得比较紧张；HR面过之后，让我在大厅里等着技术面，大概20分钟左右，技术面开始了，TW的员工都挺年轻。上来先是过了一遍我的代码作业，指出了一些不足，和改进意见，然后就是另一为大哥看着简历来问问题。TW毕竟是一家与众不同的公司，技术面也并没有问诸如计算机网络、算法、数据结构之类的问题，倒是对我的个人博客比较感兴趣，之后又让我介绍了一下自己做的项目，技术面整体来讲也比较轻松，最后问我有什么问的不，我就弱弱的说，现在自己的技术栈比较杂，各种技能都点了天赋点，就是深度不够，如何有效的提高对技术深度。跟我过代码作业那位大哥（后来听说是他们这边的一个经理）说道，你在问一个问题的时候，要先想想问的到底算不算是一个问题，你现在担心你的技术深度不够是没有意义的，这就如同搞科学研究，一群学生和一个教授，可能教授的研究深度会深一些，但是他也不敢说自己的深度已经够了….后来又讲到编程语言的形态，甚至是“人类的学习过程本身就是一个螺旋上升的过程….”。且不说这样说有没有道理，但是这位大哥的见解我已经很佩服了。最后，另外一位大哥说，永远不要去担心一个永远不会发生的问题。其实也是，与其不停的担心问题出现，真的不如去直面问题，解决问题。这也让我想到了当年考研的时候那种心情。10月19号，上午9点40，TW最后一轮面试，三分钟自有演讲，外加无领导小组讨论，整个过程一个多小时，这也都是我最不擅长的东西啦。离开时说是今天会给答复。<br>10月20号，今天等了一天，看到一个小组的同学拿到offer，时间也到了这个时候，自知是无缘TW了。<br>被连着鄙视了两个月，也深知找工作不易，想要找到一个合适自己的，真的像是找对象，除了让自己更加优秀，三哥说的“命中有时终须有，命中无时莫强求”也是有几分道理。<br><img src="http://7xkswi.com1.z0.glb.clouddn.com/eclipse_sv天空.jpg" alt="云淡风轻"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 心情文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OSI七层模型笔记</title>
      <link href="/2015/10/12/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
      <url>/2015/10/12/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>最近在准备找工作的过程中，复习以前学习的计算机网络，由于以前学习的时候也是走马观花，所以现在很有必要做个笔记。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>OSI(Open System Interconnect)，开放系统互连参考模型，是国际标准化组织(ISO)和国际电报电话咨询委员会(CCITT)联合制定的开放系统互连参考模型，为开放式互连信息系统提供了一种功能结构的框架。从低到高分为7层，依次是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。<br><a id="more"></a></p><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>物理层作为OSI中的第一层，产生并检测电压，以便发送和接收携带数据的信号，提供为建立、维护和拆除物理链路所需要的机械的、电气的、功能的和规程的特性；有关的物理链路上传输非结构的位流以及故障检测指示。物理层的媒体主要包括：针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等。在这一层，数据还没有被组织，仅作为原始的位流或电气电压处理，单位是bit比特。</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层是OSI模型第二层，控制物理层和网络层之间的通讯。它可以在不可靠的物理线路上进行数据的可靠传递，它可以将从网络层接收到的数据分割成可被物理层传输的帧（<em>帧是用来移动数据的结构包，它不仅包括原始数据，还包括发送方和接收方的物理地址以及检错和控制信息。其中的地址确定了帧将发送到何处，而纠错和控制信息则确保帧无差错到达。 如果在传送数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧</em>）。数据链路层中运行的设备是交换机。数据链路层的作用主要包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。这一层的协议主要包括：SDLC、HDLC、PPP、STP、帧中继等。数据在这一层的存在形式是Frame数据帧。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>OSI模型的第三层，主要作用是将网络地址转化为对应的物理地址，并且决定如何将数据从发送方传到接收方。网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A 到另一个网络中节点B 的最佳路径。路由器运行在网络层。这一层的协议主要包括：IP、IPX、ARP、RARP和ICMP。数据在这一层存在的形式是Packet数据包和Datagram报文。</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>OSI模型的第四层，传输层提供端到端的交换数据的机制，检查分组编号与次序。传输层对其上三层如会话层等，提供可靠的传输服务，对网络层提供可靠的目的地站点信息。这一层的协议主要包括：TCP、UDP、SPX。数据在这层的存在形式：Segments数据段。</p><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><p>会话层是OSI模型的第五层，负责在网络中的两节点之间建立、维持和终止通信。主要功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。数据在会话层、表示层和应用层中的存在形式是Data数据。</p><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>在表示层中，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同，管理数据的解密与加密，如系统口令的处理。</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>应用层是OSI模型的最高层，直接和应用程序接口并提供常见的网络应用服务。应用层也向第六层表示层发出请求。这一层的协议主要有：HTTP、SMTP、DNS、FTP、TelNet等。</p><h1 id="知名端口号"><a href="#知名端口号" class="headerlink" title="知名端口号"></a>知名端口号</h1><p>知名端口号（well-known port numbers）就是那些由互联网名称与数字地址分配机构（ICANN）预留给传输控制协议（TCP）和用户数据包协议（UDP）使用的端口号。<br>20/21端口主要用作TFP服务；23用于Telnet服务；25是SMTP（主要用作发送邮件）；53端口为DNS服务器开放，主要用作域名解析；80端口是http常用Web端口；110端口为POP3服务开放，主要用作邮件接收；443主要用于https服务，是提供加密和通过安全端口传输的另一种http。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用redis制作页面访问计数器</title>
      <link href="/2015/10/05/%E5%88%A9%E7%94%A8redis%E5%88%B6%E4%BD%9C%E9%A1%B5%E9%9D%A2%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
      <url>/2015/10/05/%E5%88%A9%E7%94%A8redis%E5%88%B6%E4%BD%9C%E9%A1%B5%E9%9D%A2%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>以前博客的页面计数器使用的是卜算子,使用方法点击<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">这里</a>查看,但是页面在加载的时候，并不是很快,于是自己使用Redis制作了一个简单的页面计数工具。<br><a id="more"></a></p><h1 id="后台代码"><a href="#后台代码" class="headerlink" title="后台代码"></a>后台代码</h1><p>我在后台使用的是Node.js，使用<a href="https://github.com/luin/ioredis" target="_blank" rel="noopener">ioredis</a>来对Redis进行操作，从而保存页面的访问次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">var redis = require(&apos;ioredis&apos;);</span><br><span class="line">var client = new redis();</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var url = require(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">    var arg = url.parse(req.url, true).query;</span><br><span class="line">        console.log(&apos;数据接收完毕&apos;);</span><br><span class="line">        //截取url</span><br><span class="line">        console.log(arg.path);</span><br><span class="line">        console.log(arg.subpath);</span><br><span class="line"></span><br><span class="line">        res.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;);//允许跨域访问</span><br><span class="line">        res.setHeader(&apos;Content-Type&apos;,&apos;text/html&apos;);</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &quot;Content-Type&quot;: &quot;text/plain;charset=utf-8&quot;</span><br><span class="line">        &#125;);</span><br><span class="line">        var v=&quot;&quot;;</span><br><span class="line">//每次访问，增加在redis中存储键值</span><br><span class="line">        client.incr(arg.path);</span><br><span class="line">        client.incr(arg.subpath);</span><br><span class="line">        //返回页面访问次数</span><br><span class="line">        client.get(arg.path).then(function(result)&#123;</span><br><span class="line">            client.get(arg.subpath).then(function(subreuslt)&#123;</span><br><span class="line">                res.write(JSON.stringify(result));</span><br><span class="line">                res.write(&apos;,&apos;);</span><br><span class="line">                res.write(JSON.stringify(subreuslt));</span><br><span class="line">                res.end();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;).listen(8000, &quot;127.0.0.1&quot;);</span><br><span class="line">console.log(&apos;Server running at http://127.0.0.1:8000/&apos;);</span><br></pre></td></tr></table></figure></p><p>解析url获取其中的参数，将对应的键值该改变，并且返回技术结果。</p><h1 id="页面代码"><a href="#页面代码" class="headerlink" title="页面代码"></a>页面代码</h1><p>前端页面中，通过访问后台代码获取页面访问数量，实时获取页面访问次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var xmlhttp;</span><br><span class="line">  var url=location.href;</span><br><span class="line">  var host=location.hostname;</span><br><span class="line">    if (window.XMLHttpRequest)</span><br><span class="line">      &#123;// code for IE7+, Firefox, Chrome, Opera, Safari</span><br><span class="line">      xmlhttp=new XMLHttpRequest();</span><br><span class="line">      &#125;</span><br><span class="line">    else</span><br><span class="line">      &#123;// code for IE6, IE5</span><br><span class="line">      xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      xmlhttp.open(&quot;GET&quot;,&quot;http://59.173.238.35:2222?&quot;+&quot;path=&quot;+host+&apos;&amp;&apos;+&quot;subpath=&quot;+url,true);   </span><br><span class="line">      </span><br><span class="line">      xmlhttp.onreadystatechange=function()</span><br><span class="line">      &#123;</span><br><span class="line">      if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)</span><br><span class="line">        &#123;</span><br><span class="line">            result=xmlhttp.responseText;</span><br><span class="line">            result=result.replace(/&quot;/,&quot;&quot;);</span><br><span class="line">            result=result.replace(/&quot;/,&quot;&quot;);</span><br><span class="line">            result=result.replace(/&quot;/,&quot;&quot;);</span><br><span class="line">            result=result.replace(/&quot;/,&quot;&quot;);</span><br><span class="line">            result=result.split(&quot;,&quot;);</span><br><span class="line">            document.getElementById(&quot;busuanzi_value_site_pv&quot;).innerHTML= result[0];</span><br><span class="line">            document.getElementById(&quot;busuanzi_value_page_pv&quot;).innerHTML= result[1];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>如果需要使用，要做的很简单：</p><h2 id="加入脚本"><a href="#加入脚本" class="headerlink" title="加入脚本"></a>加入脚本</h2><p>在需要的页面中增加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://7xkswi.com1.z0.glb.clouddn.com/eclipsesv_jspvcount.js&quot; async=&quot;async&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>顺便说一下，把js或者图片等静态文件托管在<a href="http://www.qiniu.com/" target="_blank" rel="noopener">七牛云存储</a>上，可以提高页面的访问速度。</p><h2 id="增加标签"><a href="#增加标签" class="headerlink" title="增加标签"></a>增加标签</h2><p>在页面适当的位置增加标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">  本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;</span><br><span class="line">  本页总访问量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>这样，就可以愉快的使用页面计数器了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习资料</title>
      <link href="/2015/09/09/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
      <url>/2015/09/09/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<p>前些天在图书馆借的几本书，最近看了，发现都还不错，一本是<a href="http://book.douban.com/subject/6889456/" target="_blank" rel="noopener">Linux shell脚本攻略</a>另外一本<a href="http://book.douban.com/subject/25856314/" target="_blank" rel="noopener">Web性能权威指南</a>。<br>第一本书，是印度一个在校大学生写的，里边的内容都比较具有实战型，可以在日常工作中提供不同的解决问题的思路。而第二本书则是非常系统性的提供了不同角度的优化web应用的方法，我自己比较感兴趣的是其中对与HTTP/2的讲解。<br>下一步打算更新nginx开始使用HTTP/2，考虑现在的缓存流程，改变服务器端和客户端的架构。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nginx </tag>
            
            <tag> Web性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最近的一些想法</title>
      <link href="/2015/08/27/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/"/>
      <url>/2015/08/27/%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>已经有一段时间没有更新博客了，一来是糟心事太多，一直在做着十分不想做的事情，二来是由于最近也开始找工作了，花费了很多时间补一补以前欠下的知识。<br>但是也没有停下学习的脚步，把从图书馆借了两个多月的《龙枪传承》和另外一本小说原封不动的还了回去，又借了四本和服务器相关的书，在下学期想要多花点精力学习Node.js。MongoDB和Redis的GEO特性也十分值得深入学习。<br><a id="more"></a><br>近期的目标：</p><ul><li>赶快把现在做的项目相关的内容完成，做不愿意做的事情，真的是难受；</li><li>结合GDAL和MongoDB组织管理矢量数据，数据组织好之后，初步打算利用Cesium制作一个小型的app；</li><li>拥有非阻塞IO特性的Nginx和Node.js可以很好的结合起来，前者负责请求的转发和负载均衡，后者用来操作相关的数据库，这样重构一下以前的多级缓存架构，很期待到时候性能的提升（现在的Nginx+Lua在对数据库的操作过程中，IO阻塞对性能的影响还是比较大的）。</li><li>补充完善自己的知识系统，包括计算机原理，计算机网络和一些常用的算法，哦对了，还有很久没有用过的SQL，貌似在找工作的时候笔试经常用到捏。</li></ul><p>别的不多说啦，压力很大，要好好努力才是！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 心情文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mongodb副本集在nginx-gridfs中的使用</title>
      <link href="/2015/08/17/Mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E5%9C%A8nginx-gridfs%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2015/08/17/Mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E5%9C%A8nginx-gridfs%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.mongodb.org/" target="_blank" rel="noopener">Mongodb</a>作为一款非常流行的NOSQL数据库，应用范围非常广泛，它和<a href="https://github.com/mdirolf/nginx-gridfs" target="_blank" rel="noopener">Nginx-gridfs</a>组合可以构建性能非常出色的应用。下边简单介绍一下如何搭建这套应用。<br><a id="more"></a></p><h1 id="Mongodb副本集的搭建"><a href="#Mongodb副本集的搭建" class="headerlink" title="Mongodb副本集的搭建"></a>Mongodb副本集的搭建</h1><p>在生产环境中，使用单实例的Mongodb显然不能承担重任。<a href="http://docs.mongodb.org/manual/core/replication-introduction/" target="_blank" rel="noopener">Mongodb的副本集</a>是一个mongod进程实例簇，数据在这个簇中相互复制，并且可以自动进行故障切换。这个过程虽然增加了数据冗余，但是确保了高可用性，简化了管理任务。同时，副本集也使分布式存储成为了可能。下面就可是搭建一个简单的副本集：</p><h2 id="下载解压Mongodb"><a href="#下载解压Mongodb" class="headerlink" title="下载解压Mongodb"></a>下载解压Mongodb</h2><p>最新的稳定版本是<a href="https://fastdl.mongodb.org/src/mongodb-src-r3.0.5.tar.gz?_ga=1.74584210.1075743892.1439139049" target="_blank" rel="noopener">3.0.5</a>,将下载下来的安装包解压到指定位置，将解压后的bin文件夹的文件分别复制到/usr/local/Mongorepset/1/、/usr/local/Mongorepset/2/、/usr/local/Mongorepset/3/中，并在这三个文件夹中分别建立data文件夹。</p><h2 id="启动mongod初始化副本集"><a href="#启动mongod初始化副本集" class="headerlink" title="启动mongod初始化副本集"></a>启动mongod初始化副本集</h2><p>分别在上述三个文件夹中启动mongod，端口号和日志文件分别对应各自的文件夹：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Mongorepset/3</span><br><span class="line">./mongod --dbpath=./data --port=33333 --replSet repset --logpath=./data/1.log --fork</span><br></pre></td></tr></table></figure></p><p>启动mongod之后，启动任意一个mongo，初始化副本集：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/Mongorepset/3</span><br><span class="line">./mongo --port=33333</span><br><span class="line"></span><br><span class="line">&gt; use admin</span><br><span class="line">switched to db admin</span><br><span class="line">&gt; config=&#123; _id:&quot;repset&quot;,members:[</span><br><span class="line">... &#123;_id:0,host:&quot;127.0.0.1:11111&quot;&#125;,</span><br><span class="line">... &#123;_id:1,host:&quot;127.0.0.1:22222&quot;&#125;,</span><br><span class="line">... &#123;_id:2,host:&quot;127.0.0.1:33333&quot;&#125;]</span><br><span class="line">... &#125;</span><br><span class="line">&gt; rs.initiate(config);</span><br></pre></td></tr></table></figure></p><p>这样，Mongodb副本集就算搭建完成，我们可以看一下现在副本集的状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">repset:SECONDARY&gt; rs.status();</span><br><span class="line">&#123;</span><br><span class="line">&quot;set&quot; : &quot;repset&quot;,</span><br><span class="line">&quot;date&quot; : ISODate(&quot;2015-08-17T12:59:59.910Z&quot;),</span><br><span class="line">&quot;myState&quot; : 2,</span><br><span class="line">&quot;members&quot; : [</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : 0,</span><br><span class="line">&quot;name&quot; : &quot;127.0.0.1:11111&quot;,</span><br><span class="line">&quot;health&quot; : 1,</span><br><span class="line">&quot;state&quot; : 2,</span><br><span class="line">&quot;stateStr&quot; : &quot;SECONDARY&quot;,</span><br><span class="line">&quot;uptime&quot; : 693,</span><br><span class="line">&quot;optime&quot; : Timestamp(1439816203, 1),</span><br><span class="line">&quot;optimeDate&quot; : ISODate(&quot;2015-08-17T12:56:43Z&quot;),</span><br><span class="line">&quot;configVersion&quot; : 1,</span><br><span class="line">&quot;self&quot; : true</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : 1,</span><br><span class="line">&quot;name&quot; : &quot;127.0.0.1:22222&quot;,</span><br><span class="line">&quot;health&quot; : 1,</span><br><span class="line">&quot;state&quot; : 2,</span><br><span class="line">&quot;stateStr&quot; : &quot;SECONDARY&quot;,</span><br><span class="line">&quot;uptime&quot; : 196,</span><br><span class="line">&quot;optime&quot; : Timestamp(1439816203, 1),</span><br><span class="line">&quot;optimeDate&quot; : ISODate(&quot;2015-08-17T12:56:43Z&quot;),</span><br><span class="line">&quot;lastHeartbeat&quot; : ISODate(&quot;2015-08-17T12:59:59.561Z&quot;),</span><br><span class="line">&quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-08-17T12:59:59.561Z&quot;),</span><br><span class="line">&quot;pingMs&quot; : 0,</span><br><span class="line">&quot;configVersion&quot; : 1</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : 2,</span><br><span class="line">&quot;name&quot; : &quot;127.0.0.1:33333&quot;,</span><br><span class="line">&quot;health&quot; : 1,</span><br><span class="line">&quot;state&quot; : 1,</span><br><span class="line">&quot;stateStr&quot; : &quot;PRIMARY&quot;,</span><br><span class="line">&quot;uptime&quot; : 196,</span><br><span class="line">&quot;optime&quot; : Timestamp(1439816203, 1),</span><br><span class="line">&quot;optimeDate&quot; : ISODate(&quot;2015-08-17T12:56:43Z&quot;),</span><br><span class="line">&quot;lastHeartbeat&quot; : ISODate(&quot;2015-08-17T12:59:59.562Z&quot;),</span><br><span class="line">&quot;lastHeartbeatRecv&quot; : ISODate(&quot;2015-08-17T12:59:59.362Z&quot;),</span><br><span class="line">&quot;pingMs&quot; : 0,</span><br><span class="line">&quot;electionTime&quot; : Timestamp(1439816205, 1),</span><br><span class="line">&quot;electionDate&quot; : ISODate(&quot;2015-08-17T12:56:45Z&quot;),</span><br><span class="line">&quot;configVersion&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有一个PRIMARY和两个SECONDARY节点，他们的工作方式如下：<br><img src="http://docs.mongodb.org/manual/_images/replica-set-read-write-operations-primary.png" alt="">，在应用中，PRIMARY节点负责写入和读取数据，SECONDARY节点负责备份PRIMARY中数据，它们之间通过心跳包来检测彼此的运行状态，如果主节点挂掉，它们在很短的时间内就可以重新推选出一个新的PRIMARY，保证数据库的高可用性。</p><h1 id="Nginx-gridfs中副本集的使用"><a href="#Nginx-gridfs中副本集的使用" class="headerlink" title="Nginx-gridfs中副本集的使用"></a>Nginx-gridfs中副本集的使用</h1><p>Nginx-gridfs为Nginx提供了直接访问Mongodb的能力，配置Mongodb的副本集也十分简单，只需要在nginx配置文件中对应的location增加字段就可以了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /gridfs/ &#123;</span><br><span class="line">    gridfs my_app field=filename type=string;</span><br><span class="line">    mongo &quot;repset&quot;</span><br><span class="line">          127.0.0.1:11111</span><br><span class="line">          127.0.0.1:22222</span><br><span class="line">          127.0.0.1:33333;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中Location中的字段gridfs 对应的是数据库名；filed对应的是检索字段，nginx-gridfs提供了对_id和filename的支持；mongo对应的”foo”是副本集的名称；下边则是这个副本集的节点。<br>保存更新之后的nginx配置文件，重启nginx，就可以愉快地通过Nginx访问Mongodb副本集啦。</p>]]></content>
      
      
      <categories>
          
          <category> Mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mongodb </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>php执行服务器端脚本</title>
      <link href="/2015/08/14/php%E6%89%A7%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%84%9A%E6%9C%AC/"/>
      <url>/2015/08/14/php%E6%89%A7%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>最近在做一个在客户端进行mongodb数据集选择，然后重写Nginx配置文件，最后重启Nginx的小工具。遇到最大的问题是，现在生成了Nginx配置文件，但是没法重启Nginx，使生成的配置文件即刻生效。<br>于是想到了一个办法，在服务器上写一个重启Nginx的脚本，使用php来运行这个脚本，客户端通过http访问php来完成Nginx的重启。<br><a id="more"></a></p><h1 id="Nginx重启脚本"><a href="#Nginx重启脚本" class="headerlink" title="Nginx重启脚本"></a>Nginx重启脚本</h1><p>按照上边的思路，第一步要做的就是先搞一个管理Nginx的脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line"># nginx - this script starts and stops the nginx daemin</span><br><span class="line">#</span><br><span class="line"># chkconfig:   - 85 15 </span><br><span class="line"># description:  Nginx is an HTTP(S) server, HTTP(S) reverse \</span><br><span class="line">#               proxy and IMAP/POP3 proxy server</span><br><span class="line"># processname: nginx</span><br><span class="line"># config:      /usr/local/nginx/conf/nginx.conf</span><br><span class="line"># pidfile:     /usr/local/nginx/logs/nginx.pid</span><br><span class="line"></span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"></span><br><span class="line"># Source networking configuration.</span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line"># Check that networking is up.</span><br><span class="line">[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0</span><br><span class="line"></span><br><span class="line">nginx=&quot;/usr/local/nginx/sbin/nginx&quot;</span><br><span class="line">prog=$(basename $nginx)</span><br><span class="line"></span><br><span class="line">NGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot;</span><br><span class="line"></span><br><span class="line">lockfile=/var/lock/subsys/nginx</span><br><span class="line"></span><br><span class="line">start() &#123;</span><br><span class="line">    [ -x $nginx ] || exit 5</span><br><span class="line">    [ -f $NGINX_CONF_FILE ] || exit 6</span><br><span class="line">    echo -n $&quot;Starting $prog: &quot;</span><br><span class="line">    daemon $nginx -c $NGINX_CONF_FILE</span><br><span class="line">    retval=$?</span><br><span class="line">    echo</span><br><span class="line">    [ $retval -eq 0 ] &amp;&amp; touch $lockfile</span><br><span class="line">    return $retval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop() &#123;</span><br><span class="line">    echo -n $&quot;Stopping $prog: &quot;</span><br><span class="line">    killproc $prog -QUIT</span><br><span class="line">    retval=$?</span><br><span class="line">    echo</span><br><span class="line">    [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile</span><br><span class="line">    return $retval</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart() &#123;</span><br><span class="line">    configtest || return $?</span><br><span class="line">    stop</span><br><span class="line">    start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reload() &#123;</span><br><span class="line">    configtest || return $?</span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot;</span><br><span class="line">    killproc $nginx -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">force_reload() &#123;</span><br><span class="line">    restart</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configtest() &#123;</span><br><span class="line">  $nginx -t -c $NGINX_CONF_FILE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rh_status() &#123;</span><br><span class="line">    status $prog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rh_status_q() &#123;</span><br><span class="line">    rh_status &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        rh_status_q &amp;&amp; exit 0</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        rh_status_q || exit 0</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    restart|configtest)</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    reload)</span><br><span class="line">        rh_status_q || exit 7</span><br><span class="line">        $1</span><br><span class="line">        ;;</span><br><span class="line">    force-reload)</span><br><span class="line">        force_reload</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        rh_status</span><br><span class="line">        ;;</span><br><span class="line">    condrestart|try-restart)</span><br><span class="line">        rh_status_q || exit 0</span><br><span class="line">            ;;</span><br><span class="line">    *)</span><br><span class="line">        echo $&quot;Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;&quot;</span><br><span class="line">        exit 2</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><p>可以把这个脚本放在指定的位置，比如说/etc/init.d/。</p><h1 id="php运行Nginx控制脚本"><a href="#php运行Nginx控制脚本" class="headerlink" title="php运行Nginx控制脚本"></a>php运行Nginx控制脚本</h1><p>现在管理Nginx的脚本有了，写几行php代码，运行这个脚本就好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$result2 = exec(&quot;/usr/bin/sudo /etc/init.d/nginx reload&quot;,$result);</span><br><span class="line">echo $result2;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>写好把这个文件命名为reload.php丢在/usr/local/nginx/html/里边，在浏览器里边输入 <a href="http://127.0.0.1/reload.php" target="_blank" rel="noopener">http://127.0.0.1/reload.php</a> 就好啦。<br>但是，好像没有什么反应对吧。原因就是，<strong>运行php-fpm工作进程的用户，并没有运行Nginx控制脚本的权限</strong>。</p><h1 id="给php-fpm提权限"><a href="#给php-fpm提权限" class="headerlink" title="给php-fpm提权限"></a>给php-fpm提权限</h1><h2 id="更改工作进程用户"><a href="#更改工作进程用户" class="headerlink" title="更改工作进程用户"></a>更改工作进程用户</h2><p>首先，要看一下php-fpm的工作进程用户是谁：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep php-fpm</span><br></pre></td></tr></table></figure></p><p>返回结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root       2665      1  0 14:08 ?        00:00:00 php-fpm: master process (/usr/local/php/etc/php-fpm.conf)</span><br><span class="line">nobody     2666   2665  0 14:08 ?        00:00:00 php-fpm: pool www</span><br><span class="line">nobody     2667   2665  0 14:08 ?        00:00:00 php-fpm: pool www</span><br><span class="line">root       4933   4371  0 14:49 pts/2    00:00:00 grep --color=auto php-fpm</span><br></pre></td></tr></table></figure></p><p>很清楚的看到，当前php-fpm运行的master进程是由root启动的，而工作进程则是默认的nobody运行。得到这些信息就可以修改php-fpm的工作进行用户。<br>添加用户组和用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupadd reload</span><br><span class="line">adduser -g reload reload</span><br></pre></td></tr></table></figure></p><p>打开/usr/local/php/etc/php-fpm.conf文件，进行配置。修改其中的user和group为reload，重启php。可以看到php-fpm的工作进程用户改变了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep php-fpm</span><br><span class="line"></span><br><span class="line">root       5326      1  0 15:00 ?        00:00:00 php-fpm: master process (/usr/local/php/etc/php-fpm.conf)</span><br><span class="line">reload     5327   5326  0 15:00 ?        00:00:00 php-fpm: pool www</span><br><span class="line">reload     5328   5326  0 15:00 ?        00:00:00 php-fpm: pool www</span><br><span class="line">root       5473   3935  0 15:03 pts/0    00:00:00 grep --color=auto php-fpm</span><br></pre></td></tr></table></figure></p><h2 id="更改-etc-sudoers文件"><a href="#更改-etc-sudoers文件" class="headerlink" title="更改/etc/sudoers文件"></a>更改/etc/sudoers文件</h2><p>在更改了php工作进程用户之后，需要做的就给这个用户赋予操作Nginx控制脚本的权限。<br>步骤如下：<br>默认情况下，/etc/sudoers文件是不可写的，使用root权限修改文件的操作权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+w /etc/sudoers</span><br></pre></td></tr></table></figure></p><p>用文本编辑器打开sudoers文件，在末尾行增加一条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reload   ALL=(root)      NOPASSWD: /etc/init.d/nginx</span><br></pre></td></tr></table></figure></p><p>并且需要把sudoers文件中的“Defaults    requiretty”一行前增加#，将其屏蔽。<br>修改完成，保存文件，修改sudoers文件操作权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u-w /etc/sudoers</span><br></pre></td></tr></table></figure></p><h1 id="完成重启"><a href="#完成重启" class="headerlink" title="完成重启"></a>完成重启</h1><p>至此，需要做的已经完成，在浏览器里边输入<a href="http://127.0.0.1/reload.php" target="_blank" rel="noopener">http://127.0.0.1/reload.php</a> 就可以正常重启Nginx了。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis的GEO扩展</title>
      <link href="/2015/08/11/redisGeo/"/>
      <url>/2015/08/11/redisGeo/</url>
      
        <content type="html"><![CDATA[<p>在redis3.2版本中，增加了geohash的扩展，这下可以使用Redis来作更多有意思的事情了。<br><a id="more"></a></p><h1 id="GEO相关命令"><a href="#GEO相关命令" class="headerlink" title="GEO相关命令"></a>GEO相关命令</h1><p>主要相关的命令有一下这些</p><ul><li>GEOADD</li><li>GEODIST</li><li>GEOHASH</li><li>GEOPOS</li><li>GEORADIUS</li><li>GEORADIUSBYMEMBER</li></ul><p>下面开始一一说明这些命令的作用：</p><h2 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a>GEOADD</h2><p>从这个命令的名字来开，大概就可以猜测到它的作用，即向REDIS中增加一条和地理位置相关的数据。<br>使用语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD dataset latitude longtitude place [latitude longtitude place]...</span><br></pre></td></tr></table></figure></p><p>其中,dataset表示一个数据集，在这个数据集中可以存储多个地名(place)，latitude和longtitude各表示纬度和经度，一次GEOADD可以添加多个place。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD Sicily 13.361389 38.115556 &quot;Palermo&quot; 15.087269 37.502669 &quot;Catania&quot;</span><br></pre></td></tr></table></figure></p><p>上边的操作，就完成了向Sicily数据集中增加Palermo和Catania这两条信息，在增加完成时，redis-cli返回完成添加的数据条目数。</p><h2 id="GEODIST"><a href="#GEODIST" class="headerlink" title="GEODIST"></a>GEODIST</h2><p>这条命令会返回在一个GEO数据集中两个地点之间的距离，如果其中一个或者两个地点都不再GEO数据集中，返回NULL。<br>返回的距离默认单位是米，不过还可以使用其他的单位主要包括：</p><ul><li>km（千米）</li><li>mi (英里)</li><li>ft (英尺)</li></ul><p>使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GEODIST Sicily Palermo Catania</span><br><span class="line">GEODIST Sicily Palermo Catania km</span><br><span class="line">GEODIST Sicily Palermo Catania mi</span><br></pre></td></tr></table></figure></p><p>这样，根据最后的单位，返回不同的数值。</p><h2 id="GEOHASH"><a href="#GEOHASH" class="headerlink" title="GEOHASH"></a>GEOHASH</h2><p>用这条命令可以返回一个或多个已经存入redis地点的11位Geohash码，使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOHASH Sicily Palermo Catania</span><br></pre></td></tr></table></figure></p><p>返回结果是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;sqc8b49rny0&quot;</span><br><span class="line">2) &quot;sqdtr74hyu0&quot;</span><br></pre></td></tr></table></figure></p><h2 id="GEOPOS"><a href="#GEOPOS" class="headerlink" title="GEOPOS"></a>GEOPOS</h2><p>这个命令，可以返回在GEOSET里边指定地点的经纬度，用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOPOS Sicily Palermo Catania</span><br></pre></td></tr></table></figure></p><p>返回结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) 1) &quot;13.361389338970184&quot;</span><br><span class="line">   2) &quot;38.115556395496299&quot;</span><br><span class="line">2) 1) &quot;15.087267458438873&quot;</span><br><span class="line">   2) &quot;37.50266842333162&quot;</span><br></pre></td></tr></table></figure></p><h2 id="GEORADIUS"><a href="#GEORADIUS" class="headerlink" title="GEORADIUS"></a>GEORADIUS</h2><p>顾名思义，这个命令返回的是指定地点半径范围内的所有匹配地点，类似与缓冲区分析，这个缓冲区的范围单位跟GEODIST命令中所用的一样有m(米),km(千米),mi(英里),ft(英尺)。<br>另外这个命令还有另外的选项：</p><ul><li>WITHDIST 返回结果除了匹配点以外，还返回匹配点距离中心点的距离；</li><li>WITHCOORD 返回结果除匹配点外，还包含匹配点的经纬度；</li><li>WITHASH 返回结果初匹配点外，还包含匹配点的geohash码。</li></ul><p>默认的返回结果是一个无序的集合，使用命令ASC或DESC可以使匹配点按照距离中心点的远近排序返回。<br>同时，默认情况下，匹配点会全数返回，增加COUNT命令，可以返回指定数量的匹配结果。<br>命令用法如下：</p><h3 id="WITHDIST"><a href="#WITHDIST" class="headerlink" title="WITHDIST"></a>WITHDIST</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS Sicily 15 37 200 km WITHDIST</span><br></pre></td></tr></table></figure><p>对应返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1) 1) &quot;Palermo&quot;</span><br><span class="line">   2) &quot;190.4424&quot;</span><br><span class="line">2) 1) &quot;Catania&quot;</span><br><span class="line">   2) &quot;56.4413&quot;</span><br></pre></td></tr></table></figure></p><h3 id="WITHCOORD"><a href="#WITHCOORD" class="headerlink" title="WITHCOORD"></a>WITHCOORD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS Sicily 15 37 200 km WITHCOORD</span><br></pre></td></tr></table></figure><p>对应返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1) 1) &quot;Palermo&quot;</span><br><span class="line">   2) 1) &quot;13.361389338970184&quot;</span><br><span class="line">      2) &quot;38.115556395496299&quot;</span><br><span class="line">2) 1) &quot;Catania&quot;</span><br><span class="line">   2) 1) &quot;15.087267458438873&quot;</span><br><span class="line">      2) &quot;37.50266842333162&quot;</span><br></pre></td></tr></table></figure></p><h2 id="GEORADIUSBYMEMBER"><a href="#GEORADIUSBYMEMBER" class="headerlink" title="GEORADIUSBYMEMBER"></a>GEORADIUSBYMEMBER</h2><p>这个命令和GEORADIUS使用方法类似，不过这个指定中心点不是经纬度，而是一个地点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUSBYMEMBER Sicily Palermo  200 km</span><br></pre></td></tr></table></figure></p><p>返回如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) &quot;Palermo&quot;</span><br><span class="line">2) &quot;Catania&quot;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>增加了GEO特性的redis，我们可以充分发挥想象力，好好利用一下它，在接下来的几篇博客，我会深入研究一下GEOHASH的特性，另外，Mongodb的GEO特性也非常之的研究。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux下程序开机自启动</title>
      <link href="/2015/08/07/Linux%E4%B8%8B%E7%A8%8B%E5%BA%8F%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
      <url>/2015/08/07/Linux%E4%B8%8B%E7%A8%8B%E5%BA%8F%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>在日常工作中，随着服务器上部署的服务的增多，每次服务器重启之后，都需要逐一将服务启动，这个过程耗时而且麻烦。于是，将一些服务在服务器启动之后自动启动变得很方便。<br><a id="more"></a><br>在Linux下设置开机自启动程序，通常的做法是修改/etc/rc.d/rc.local文件，过程十分简单，只需要在这个文件追加你需要的命令就可以了。<br>比如说，我现在需要开机自启动Mongodb,php-fpm,nginx，简要做法如下：<br>将mongodb启动的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/Mongodb3.0/bin/mongod --dbpath=/usr/local/Mongodb3.0/db --logpath=/usr/local/Mongodb3.0/log/mongodb.log --fork --pidfilepath=/usr/local/Mongodb3.0/log/mongo.pid</span><br></pre></td></tr></table></figure></p><p>php-fpm启动的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/php/sbin/php-fpm -c /usr/local/php/etc/php.ini -y /usr/local/php/etc/php-fpm.conf</span><br></pre></td></tr></table></figure></p><p>以及nginx启动的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></p><p>放在/etc/rc.d/rc.local文件末尾。<br>还有一步十分重要，就是修改rc.local文件的操作权限，chmod a+w /etc/rc.d/rc.loacl，赋予所有用户操作rc.local文件的权限。这样在重启系统之后，这些程序都会如愿自动启动。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器端缓存环境配置(三)</title>
      <link href="/2015/08/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%93%E5%AD%98%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-%E4%B8%89/"/>
      <url>/2015/08/04/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%93%E5%AD%98%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="nginx的Lua扩展"><a href="#nginx的Lua扩展" class="headerlink" title="nginx的Lua扩展"></a><strong>nginx的Lua扩展</strong></h1><p>接着上两篇博客，现在开始搭建nginx的LUA和mongodb扩展，完成整个流程的最后一步配置。<br>Lua是一个可以嵌入到nginx配置文件的动态脚本语言，这样就可以在nginx请求处理的各个阶段执行各种进行逻辑控制的Lua代码。<br>想要在nginx里边增加lua扩展，需要的模块如下：</p><ul><li><a href="http://luajit.org" target="_blank" rel="noopener">luajit</a></li><li><a href="https://github.com/simpl/ngx_devel_kit" target="_blank" rel="noopener">ngx_devel_kit</a></li><li><a href="https://github.com/chaoslawful/lua-nginx-module" target="_blank" rel="noopener">lua_nginx_module</a></li></ul><a id="more"></a><h2 id="安装luajit"><a href="#安装luajit" class="headerlink" title="安装luajit"></a>安装luajit</h2><p>惯例，先要下载安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://luajit.org/download/LuaJIT-2.0.0-beta9.tar.gz </span><br><span class="line">tar -zxvf LuaJIT-2.0.0-beta9.tar.gz</span><br><span class="line">cd LuaJIT-2.0.0-beta9/</span><br><span class="line">make</span><br><span class="line">make install PREFIX=/usr/local/luajit</span><br><span class="line">ln -sf luajit-2.0.0-beta9 /usr/local/luajit/bin/luajit</span><br></pre></td></tr></table></figure></p><p>接下来，配置luajit的环境变量，这个在nginx重新编译的时候需要。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LUAJIT_LIB=/usr/local/luajit/lib  </span><br><span class="line">export LUAJIT_INC=/usr/local/luajit/include/luajit-2.0</span><br></pre></td></tr></table></figure></p><h2 id="安装ngx-devel-kit"><a href="#安装ngx-devel-kit" class="headerlink" title="安装ngx_devel_kit"></a>安装ngx_devel_kit</h2><p><a href="https://github.com/simpl/ngx_devel_kit.git" target="_blank" rel="noopener">点击获取ngx_devel_kit</a>，将其放在/usr/local目录下，或者使用git来快捷获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">git clone https://github.com/simpl/ngx_devel_kit.git</span><br></pre></td></tr></table></figure></p><h2 id="安装lua-nginx-module"><a href="#安装lua-nginx-module" class="headerlink" title="安装lua-nginx-module"></a>安装lua-nginx-module</h2><p><a href="https://github.com/chaoslawful/lua-nginx-module.git" target="_blank" rel="noopener">点击获取lua-nginx-kit</a>，跟ngx_devel_kit一样，将其解压放于/usr/local目录下。或者使用git快捷获取。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/</span><br><span class="line">git clone https://github.com/chaoslawful/lua-nginx-module.git</span><br></pre></td></tr></table></figure></p><p>使用git来获取github上的资源，是不是十分方便？</p><h2 id="重新编译nginx"><a href="#重新编译nginx" class="headerlink" title="重新编译nginx"></a>重新编译nginx</h2><p>进入nginx源码放置的文件夹，重新配置configure，再次make，增加nginx的扩展。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx-1.8.0/</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-ld-opt=&quot;-Wl,-rpath,$LUAJIT_LIB&quot; --add-module=/usr/local/ngx_devel_kit --add-module=/usr/local/lua-nginx-module</span><br><span class="line">make -j2 </span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>至此，nginx的lua 扩展模块已经安装完毕，下面进行一下测试。</p><h2 id="测试lua模块"><a href="#测试lua模块" class="headerlink" title="测试lua模块"></a>测试lua模块</h2><p>在nginx的配置文件中增加一段代码就OK了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p><p>在监听80端口的server中增加一下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /lua &#123;</span><br><span class="line">    default_type &apos;text/plain&apos;;</span><br><span class="line">    content_by_lua &apos;ngx.say(&quot;I am lua in nginx&quot;)&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></p><p>现在在浏览器中输入<a href="http://127.0.0.1/lua" target="_blank" rel="noopener">127.0.0.1/lua</a>，就可以看到“I am lua in nginx”。这样就说明，nginx的lua模块也安装成功了。</p><h1 id="nginx的mongodb-gridfs扩展"><a href="#nginx的mongodb-gridfs扩展" class="headerlink" title="nginx的mongodb gridfs扩展"></a><strong>nginx的mongodb gridfs扩展</strong></h1><p>先从github上将nginx-gridfs模块下载下来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">git clone https://github.com/mdirolf/nginx-gridfs.git</span><br><span class="line">cd nginx-gridfs/</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure></p><p>重新编译nginx，这里要注意，由于上边已经增加了nginx的lua扩展，现在需要增加模块，方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure></p><p>获取当前nginx已有的模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx version: nginx/1.8.0</span><br><span class="line">built by gcc 4.8.3 20140911 (Red Hat 4.8.3-9) (GCC) </span><br><span class="line">configure arguments: --prefix=/usr/local/nginx --with-ld-opt=-Wl,-rpath,/usr/local/luajit/lib --add-module=/usr/local/ngx_devel_kit --add-module=/usr/local/lua-nginx-module</span><br></pre></td></tr></table></figure></p><p>可以看到，configure arguments后边的参数，将他们拷贝，供等下使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx-1.8.0/</span><br><span class="line">./configure --prefix=/usr/local/nginx --with-ld-opt=-Wl,-rpath,/usr/local/luajit/lib --add-module=/usr/local/ngx_devel_kit --add-module=/usr/local/lua-nginx-module --with-openssl=/usr/include/openssl --with-http_stub_status_module --add-module=/usr/local/nginx-gridfs</span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure></p><p>这样，nginx-gridfs模块就也安装完成了，现在就可以使用nginx来直接操作mongodb中的gridfs了。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a><strong>结束</strong></h1><p>到这里，整个流程的环境安装和配置就算完成了。后边的博客会继续记录我在学习这些内容的过程。<br>最后，再来张美图吧<br><img src="http://7xkswi.com1.z0.glb.clouddn.com/eclipsesv_jpgIMG_1877.JPG" alt=""><br>~~ 武汉最近的天气，确实很好！</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mongodb </tag>
            
            <tag> Nginx </tag>
            
            <tag> Redis </tag>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器端缓存环境配置(二)</title>
      <link href="/2015/08/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%93%E5%AD%98%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-%E4%BA%8C/"/>
      <url>/2015/08/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%93%E5%AD%98%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>上一篇博客讲解了整个缓存流程中数据库部分的搭建，有了最基础的部分，现在可以搭建上层的内容了。</p><a id="more"></a><h1 id="Web服务器"><a href="#Web服务器" class="headerlink" title="Web服务器"></a><strong>Web服务器</strong></h1><p>整个缓存流程中，客户端都是以HTTP请求的方式获取服务器上数据库中的数据。我们选择了Nginx作为HTTP请求解析和负载均衡的工具。<br>Nginx作为一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP 代理服务器。它以稳定性、丰富的功能和第系统资源消耗而闻名。下面开始介绍Nginx的安装和配置：<br>以往的安装方式都是直接编译源码，这次来点新的。</p><h2 id="Ngxin打包安装"><a href="#Ngxin打包安装" class="headerlink" title="Ngxin打包安装"></a>Ngxin打包安装</h2><p>按照<a href="http://nginx.org/en/linux_packages.html" target="_blank" rel="noopener">nginx官网</a>上的方法来进行操作。<br>首先打开终端，进入/usr/local目录，下载rpm文件：</p><pre><code>[wangmeg@localhost ~]$ cd /usr/local[root@localhost local]# wget http://nginx.org/packages/centos/7/noarch/RPMS/nginx-    release-centos-7-0.el7.ngx.noarch.rpm</code></pre><p>之后安装rpm文件，并使用yum 命令进行Nginx的自动安装：</p><pre><code>[root@localhost local]# rpm -i nginx-release-centos-7-0.el7.ngx.noarch.rpm [root@localhost local]# yum install nginx</code></pre><p>稍等片刻，终端出现</p><pre><code>----------------------------------------------------------------------Thanks for using nginx!Please find the official documentation for nginx here:* http://nginx.org/en/docs/Commercial subscriptions for nginx are available on:* http://nginx.com/products/----------------------------------------------------------------------  Verifying  : 1:nginx-1.8.0-1.el7.ngx.x86_64                               1/1 Installed:  nginx.x86_64 1:1.8.0-1.el7.ngx                                                Complete!</code></pre><p>表示Nginx安装完毕。现在，在终端键入命令nginx启动nginx，在浏览器中输入http:127.0.0.1之后出现<br><img src="http://7xkswi.com1.z0.glb.clouddn.com/eclipsesv_jpgScreenshot%20from%202015-08-02%2020%3A29%3A42.png" alt=""><br>这样，Nginx就算安装完毕了。<br>可以在终端键入命令： nginx -V 来查看这样默认安装的相关配置。</p><pre><code>[root@localhost local]# nginx -Vnginx version: nginx/1.8.0built by gcc 4.8.2 20140120 (Red Hat 4.8.2-16) (GCC) built with OpenSSL 1.0.1e-fips 11 Feb 2013TLS SNI support enabledconfigure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_stub_status_module --with-http_auth_request_module --with-mail --with-mail_ssl_module --with-file-aio --with-ipv6 --with-http_spdy_module --with-cc-opt=&apos;-O2 -g -pipe -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic&apos;</code></pre><h2 id="Nginx源码编译"><a href="#Nginx源码编译" class="headerlink" title="Nginx源码编译"></a>Nginx源码编译</h2><p>相对于上述使用yum安装nginx，我更习惯编译源码安装。<br>在进行安装以前，需要安装pcre和zlib。</p><h3 id="pcre安装"><a href="#pcre安装" class="headerlink" title="pcre安装"></a>pcre安装</h3><pre><code>[root@localhost etc]# cd /usr/local[root@localhost local]# wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.37.tar.gz[root@localhost local]# tar -zxvf pcre-8.37.tar.gz [root@localhost pcre-8.37]# cd pcre-8.37/[root@localhost pcre-8.37]# ./configure [root@localhost pcre-8.37]# make [root@localhost pcre-8.37]# make install</code></pre><p>这样，pcre就算安装完成。</p><h3 id="zlib安装"><a href="#zlib安装" class="headerlink" title="zlib安装"></a>zlib安装</h3><pre><code>[root@localhost local]# wget http://zlib.net/zlib-1.2.8.tar.gz[root@localhost local]# tar -zxvcf zlib-1.2.8.tar.gz [root@localhost local]# cd zlib-1.2.8/[root@localhost zlib-1.2.8]# make &amp;&amp; make install</code></pre><p>OK，zlib也安装完毕。</p><h3 id="Nginx源码编译安装"><a href="#Nginx源码编译安装" class="headerlink" title="Nginx源码编译安装"></a>Nginx源码编译安装</h3><p>接下来下载nginx源码，完成后续的安装和配置。</p><p>[root@localhost pcre-8.37]# cd /usr/local<br>[root@localhost local]# wget <a href="http://nginx.org/download/nginx-1.8.0.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.8.0.tar.gz</a><br>[root@localhost local]# tar -zxvf nginx-1.8.0.tar.gz<br>[root@localhost local]# cd ./nginx-1.8.0/<br>[root@localhost nginx-1.8.0]# ./configure –prefix=/usr/local/nginx<br>[root@localhost nginx-1.8.0]# make &amp;&amp; make install</p><p>如果没有错误提示，则表示nginx编译安装完成。<br>现在键入命令/usr/local/nginx/sbin/nginx就可以启动nginx了。<br>另外，终止nginx的命令使用：/usr/local/nginx/sbin/nginx -s stop；进行nginx平滑重启使用命令/usr/local/nginx/sbin/nginx -s reload。</p><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a><strong>PHP</strong></h1><p>上边的操作，算是完成了nginx的初步安装，接下来开始进行PHP的安装。<br>首先，需要下载PHP，可以从官网上进行下载，我选择的是5.4.43版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost Desktop]# cd /usr/local</span><br><span class="line">[root@localhost local]# wget http://php.net/distributions/php-5.4.43.tar.gz</span><br></pre></td></tr></table></figure><p>完成解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# tar -zxvf php-5.4.43.tar.gz</span><br></pre></td></tr></table></figure></p><p>进行安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost local]# cd php-5.4.43/</span><br><span class="line">[root@localhost php-5.4.43]# ./configure --prefix=/usr/local/php --enable-fpm</span><br></pre></td></tr></table></figure></p><p>检查配置的过程，我的机器上出现了错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checking for xml2-config path... </span><br><span class="line">configure: error: xml2-config not found. Please check your libxml2 installation.</span><br></pre></td></tr></table></figure></p><p>表示缺少libxml2，不用担心，使用yum 安装便是。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost php-5.4.43]# yum install libxml2 </span><br><span class="line">[root@localhost php-5.4.43]# yum install libxml2-devel -y</span><br></pre></td></tr></table></figure></p><p>再次进行配置检查，出现下面这些则可进行下一步操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Thank you for using PHP.</span><br><span class="line"></span><br><span class="line">config.status: creating php5.spec</span><br><span class="line">config.status: creating main/build-defs.h</span><br><span class="line">config.status: creating scripts/phpize</span><br><span class="line">config.status: creating scripts/man1/phpize.1</span><br><span class="line">config.status: creating scripts/php-config</span><br><span class="line">config.status: creating scripts/man1/php-config.1</span><br><span class="line">config.status: creating sapi/cli/php.1</span><br><span class="line">config.status: creating sapi/fpm/php-fpm.conf</span><br><span class="line">config.status: creating sapi/fpm/init.d.php-fpm</span><br><span class="line">config.status: creating sapi/fpm/php-fpm.service</span><br><span class="line">config.status: creating sapi/fpm/php-fpm.8</span><br><span class="line">config.status: creating sapi/fpm/status.html</span><br><span class="line">config.status: creating sapi/cgi/php-cgi.1</span><br><span class="line">config.status: creating ext/phar/phar.1</span><br><span class="line">config.status: creating ext/phar/phar.phar.1</span><br><span class="line">config.status: creating main/php_config.h</span><br><span class="line">config.status: executing default commands</span><br></pre></td></tr></table></figure></p><p>配置环境没问题，就可以进行make &amp;&amp; make install，完成安装了。<br>安装完成之后，不要忘记将PHP配置文件放到指定位置。<br><code>[root@localhost php-5.4.43]# cp ./php.ini-development /usr/local/php/etc/php.ini</code><br>完成PHP安装之后，咱们来给它加点料，前边说了，整个流程，需要使用PHP来获取Mongodb中的数据集信息，咱们顺势把mongodb的扩展也装上把。</p><p>先从github上将<a href="https://github.com/mongodb/mongo-php-driver" target="_blank" rel="noopener">php的mongodb扩展</a>下载。按照网页中的方法进行安装配置。<br>需要说明的一点是。phpize的默认安装位置是/usr/local/php/bin/phpize；php-config默认位置是/usr/local/php/bin/php-config。<br>这样。PHP的安装和需要的扩展已经安装完毕。</p><h1 id="Nginx-php的配置"><a href="#Nginx-php的配置" class="headerlink" title="Nginx+php的配置"></a>Nginx+php的配置</h1><p>现在nginx和php都已经分别安装完成，现在可以检验一下他们在一起能否正常运行。</p><ol><li><p>修改nginx配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gedit /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></li><li><p>找到这一段，取消前边的注释“#”,修改其中内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">            root           html;</span><br><span class="line">            fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">            fastcgi_index  index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  /usr/local/nginx/html/$fastcgi_script_name;</span><br><span class="line">            include        fastcgi_params;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>在/usr/lcoal/nginx/html/文件夹下创建文件info.php，写入内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   echo phpinfo();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li><li><p>启动nginx和php-fpm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/nginx/sbin/nginx </span><br><span class="line">[root@localhost ~]# /usr/local/php/sbin/php-fpm -c /usr/local/php/etc/php.ini -y /usr/local/php/etc/php-fpm.conf</span><br></pre></td></tr></table></figure></li><li><p>启动firefox,地址栏中输入”127.0.0.1/info.php”，出现如下结果则表明运行正常。<br><img src="http://7xkswi.com1.z0.glb.clouddn.com/eclipsesv_jpgScreenshot%20from%202015-08-04%2001%3A11%3A35.png" alt=""></p></li><li><p>这个网页往下，可以看到这样的结果，表示mongodb的扩展也安装成功。<br><img src="http://7xkswi.com1.z0.glb.clouddn.com/eclipsesv_jpgScreenshot%20from%202015-08-04%2001%3A12%3A07.png" alt=""></p></li></ol><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a><strong>未完待续</strong></h1><p>整个流程内容较多，下一篇博客，经会介绍如何安装配置nginx的Lua扩展，完成整个流程的搭建。<br>最后，以一张美图来结束这篇博客。<br><img src="http://7xkswi.com1.z0.glb.clouddn.com/eclipsesv_jpgIMG_1858.JPG" alt="雨后初晴的武汉"></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mongodb </tag>
            
            <tag> Nginx </tag>
            
            <tag> Redis </tag>
            
            <tag> Lua </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器端缓存环境配置</title>
      <link href="/2015/07/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%93%E5%AD%98%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2015/07/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%BC%93%E5%AD%98%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="原材料"><a href="#原材料" class="headerlink" title="原材料"></a><strong>原材料</strong></h1><p>正所谓“巧妇难为无米之炊”，在进行服务器端缓存搭建之前，需要将整个流程所需的元素准备好。</p><ul><li><a href="http://nginx.org/" title="作为Web服务器的存在" target="_blank" rel="noopener">Nginx</a>作为Web服务器的存在</li><li><a href="https://www.mongodb.org/" title="磁盘数据库" target="_blank" rel="noopener">Mongodb</a>磁盘数据库</li><li><a href="http://www.lua.org/" title="与Nginx结合，进行服务器端的逻辑控制" target="_blank" rel="noopener">Lua</a>与Nginx结合，进行服务器端的逻辑控制</li><li><a href="http://redis.io/" title="高速缓存" target="_blank" rel="noopener">Redis</a>内存数据库，高速缓存</li><li><a href="http://www.php.net/" title="返回数据库信息给客户端" target="_blank" rel="noopener">PHP</a>读取磁盘数据库信息，返回给客户端</li></ul><a id="more"></a><h1 id="调料包"><a href="#调料包" class="headerlink" title="调料包"></a><strong>调料包</strong></h1><p>有了原材料，当然需要将它们融合在一起，才能烹调出美味，下面这些内容则可以称之为调料包：</p><ul><li><strong>Nginx的Lua扩展</strong><br><a href="http://luajit.org" target="_blank" rel="noopener">LuaJit</a><br><a href="https://github.com/simpl/ngx_devel_kit" target="_blank" rel="noopener">ngx_devel_kit</a><br><a href="https://github.com/chaoslawful/lua-nginx-module" target="_blank" rel="noopener">lua-nginx-module</a></li><li><strong>Nginx的Mongodb扩展</strong><br><a href="https://github.com/mdirolf/nginx-gridfs" target="_blank" rel="noopener">Nginx-gridfs</a></li><li><strong>PHP的Mongodb扩展</strong><br><a href="https://github.com/mongodb/mongo-php-driver" target="_blank" rel="noopener">Mongo-php-driver</a></li><li><a href="https://github.com/h4lflife/lua-resty-redis" target="_blank" rel="noopener"><strong>Lua的Redis扩展</strong></a></li></ul><h1 id="Mongodb的安装配置"><a href="#Mongodb的安装配置" class="headerlink" title="Mongodb的安装配置"></a><strong>Mongodb的安装配置</strong></h1><p>柿子先挑软的捏，整个流程中需要安装和配置的内容比较多，相比来说，Mongodb算是最简单的一个了。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>在写这篇博客的时候，最新的Mongodb版本是<a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.0.5.tgz" target="_blank" rel="noopener">3.0.5</a>，下载的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local</span><br><span class="line">$ su</span><br><span class="line">Password: </span><br><span class="line"># wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.0.5.tgz</span><br><span class="line">--2015-08-01 11:06:41--  https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.0.5.tgz</span><br><span class="line">Resolving fastdl.mongodb.org (fastdl.mongodb.org)... 54.230.156.11, 54.230.156.102, 54.230.156.123, ...</span><br><span class="line">Connecting to fastdl.mongodb.org (fastdl.mongodb.org)|54.230.156.11|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 50203367 (48M) [application/x-gzip]</span><br><span class="line">Saving to: ‘mongodb-linux-x86_64-rhel70-3.0.5.tgz’</span><br><span class="line"></span><br><span class="line">100%[======================================&gt;] 50,203,367   582KB/s   in 4m 40s </span><br><span class="line"></span><br><span class="line">2015-08-01 11:11:31 (175 KB/s) - ‘mongodb-linux-x86_64-rhel70-3.0.5.tgz’ saved [50203367/50203367]</span><br></pre></td></tr></table></figure><p>首先进入/usr/local目录，下载这个文件需要root权限，输入su之后，输入自己的root密码，使用wget命令，下载MongoDB到/usr/local目录下；<br>有的时候官网上资源不容易下载，提供下载地址<a href="http://yunpan.cn/cdARXPYP7FRPT" target="_blank" rel="noopener">MongoDB3.0.5点击下载，访问密码0cdf</a>。</p><h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># tar zxvf mongodb-linux-x86_64-rhel70-3.0.5.tgz </span><br><span class="line"># mv ./mongodb-linux-x86_64-rhel70-3.0.5 /usr/local/Mongodb3.0</span><br></pre></td></tr></table></figure><p>使用tar zxvf 解压缩*.tgz文件，mv 命令将解压缩后的文件夹重命名为Mongodb3.0；</p><h2 id="运行起来"><a href="#运行起来" class="headerlink" title="运行起来"></a>运行起来</h2><p>在运行之前，需要建立两个文件夹：</p><pre><code>[root@localhost local]# cd Mongodb3.0/[root@localhost Mongodb3.0]# mkdir ./db[root@localhost Mongodb3.0]# mkdir ./log</code></pre><p>先进入/usr/local/Mongodb3.0文件夹：cd Mongodb3.0/ ，在当前文件夹中建立db和log文件夹。</p><pre><code>[root@localhost Mongodb3.0]# cd ./bin/[root@localhost bin]# lsbsondump  mongodump    mongoimport  mongorestore  mongotopmongo     mongoexport  mongooplog   mongosmongod    mongofiles   mongoperf    mongostat[root@localhost bin]# ./mongod --dbpath=../db --port=27017 --logpath=../log/mongodb.log --forkabout to fork child process, waiting until server is ready for connections.forked process: 12246child process started successfully, parent exiting</code></pre><p>进入/usr/local/Mongodb3.0/bin/文件夹：cd ./bin/；<br>bin文件夹下mongod为mongodb启动文件，运行命令 ./mongod –dbpath=../db –port=27017 –logpath=../log/mongodb.log –fork 启动Mongodb。<br>–dbpath 代表Mongodb数据存储的位置； –port 表示Mongodb所占用的端口号； –logpath 表示日志文件的路径；–fork 表示Mongodb以守护进程的形式启动。<br>现在可以看到<br>about to fork child process, waiting until server is ready for connections.<br>forked process: 12246<br>child process started successfully, parent exiting<br>表示Mongodb已经正常启动！</p><h2 id="停止Mongodb"><a href="#停止Mongodb" class="headerlink" title="停止Mongodb"></a>停止Mongodb</h2><p>按照上边的步骤，可以已守护进程的方式启动Mongodb，在需要停止Mongodb的时候，可以使用以下操作：</p><pre><code>[root@localhost bin]# ps -e | grep mongod 12246 ?        00:00:04 mongod</code></pre><p>键入命令 ps -e | grep mongod，可以看到正在运行的Mongodb的pid（进程号）;</p><pre><code>[root@localhost bin]# kill 12246[root@localhost bin]# ps -e | grep mongod[root@localhost bin]# </code></pre><p>得到进程号之后，使用kill命令来停止Mongodb，再次输入ps -e | grep mongod 终端就不会再有显示，表示进程已被杀死。</p><h1 id="Redis-集群的搭建"><a href="#Redis-集群的搭建" class="headerlink" title="Redis 集群的搭建"></a>Redis 集群的搭建</h1><p>这里需要说明以下，下载的时候选择支持集群模式的Redis3.0之后的版本。</p><h2 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h2><p>跟Mongodb一样，第一步肯定是先把文件下载下来：</p><pre><code>[root@localhost bin]# cd /usr/local[root@localhost local]# wget http://download.redis.io/releases/redis-3.0.3.tar.gz--2015-08-01 13:02:27--  http://download.redis.io/releases/redis-3.0.3.tar.gzResolving download.redis.io (download.redis.io)... 109.74.203.151Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 1360959 (1.3M) [application/x-gzip]Saving to: ‘redis-3.0.3.tar.gz.1’100%[======================================&gt;] 1,360,959    149KB/s   in 1m 41s 2015-08-01 13:04:20 (13.2 KB/s) - ‘redis-3.0.3.tar.gz.1’ saved [1360959/1360959]</code></pre><p>相比Mongodb，Redis文件还是很小的。<br>同样，在下载失败的时候，可以<a href="http://yunpan.cn/cdABZJ4uNn7vQ" target="_blank" rel="noopener">点击下载Redis3.0.3 访问密码dc5a</a>。</p><h2 id="解压缩-1"><a href="#解压缩-1" class="headerlink" title="解压缩"></a>解压缩</h2><pre><code>[root@localhost local]# tar -zxvf redis-3.0.3.tar.gz.1 </code></pre><p>将文件解压缩到/usr/local文件夹下。</p><h2 id="单独实例先Run起来"><a href="#单独实例先Run起来" class="headerlink" title="单独实例先Run起来"></a>单独实例先Run起来</h2><p>这里与Mongodb不太一样，运行之前需要编译一下：</p><pre><code>[root@localhost local]# cd redis-3.0.3/[root@localhost redis-3.0.3]# make </code></pre><p>需要稍等一下，终端显示</p><pre><code>Hint: It&apos;s a good idea to run &apos;make test&apos; ;)make[1]: Leaving directory `/usr/local/redis-3.0.3/src&apos;</code></pre><p>则表示make成功。</p><pre><code>[root@localhost redis-3.0.3]# cd src/[root@localhost src]# ./redis-server ../redis.conf 16790:M 01 Aug 13:15:44.020 * The server is now ready to accept connections on port 6379</code></pre><p>进入src文件夹下，键入命令：./redis-server ../redis.conf ，就可以启动Redis实例。正常的运行结果则如上所示。</p><p>在这里，因为不是以守护进程的形式启动的Redis，如果需要停止进行，在运行Redis的终端使用Ctrl+C来停止进程。</p><pre><code>^C16790:signal-handler (1438406388) Received SIGINT scheduling shutdown...16790:M 01 Aug 13:19:48.465 # User requested shutdown...16790:M 01 Aug 13:19:48.465 * Saving the final RDB snapshot before exiting.16790:M 01 Aug 13:19:48.507 * DB saved on disk16790:M 01 Aug 13:19:48.507 # Redis is now ready to exit, bye bye...</code></pre><h2 id="Redis集群，High起来"><a href="#Redis集群，High起来" class="headerlink" title="Redis集群，High起来"></a>Redis集群，High起来</h2><p>Redis作为一个内存数据库，在实际的使用环境中，经常会受到机器内存大小的限制，在3.0之前的版本，集群需要采用proxy的方法，现在redis自身提供了cluster的支持。</p><h3 id="集群搭建准备工作"><a href="#集群搭建准备工作" class="headerlink" title="集群搭建准备工作"></a>集群搭建准备工作</h3><p>集群的搭建需要使用Redis下src文件夹中redis-trib.rb，这是一个ruby程序，因此需要系统中有ruby环境。</p><pre><code>root@localhost src]# yum install ruby [root@localhost src]# gem install redis</code></pre><p>键入上边的命令，安装ruby 和 ruby 的redis 扩展。在安装扩展的时候，很有可能不能安装，可能是资源被墙了。可以使用我自己下载到的资源<a href="http://yunpan.cn/cdABc69IzjVvG" target="_blank" rel="noopener">redis.gem 访问密码9727</a>进行本地安装。</p><pre><code>[root@localhost src]# gem install --local /usr/local/redis-3.0.0.gem </code></pre><p>将下载到的gem文件放到/usr/local目录下，使用上边的命令进行安装。这样，Redis集群的运行环境就搭建完毕。</p><p>要做redis集群，至少需要3个Master实例。<br>先把redis的配置文件redis.conf和redis-server文件放到一个文件夹中：</p><pre><code>[root@localhost local]# cd /usr/local[root@localhost local]# mkdir -p ./redis-cluster/6379[root@localhost local]# cp ./redis-3.0.3/redis.conf ./redis-3.0.3/src/redis-server ./redis-cluster/6379/</code></pre><p>然后将文件夹6379复制两份：</p><pre><code>[root@localhost local]# cd ./redis-cluster/[root@localhost redis-cluster]# cp -rf ./6379/ ./6380[root@localhost redis-cluster]# cp -rf ./6379 ./6381</code></pre><p>接下来，需要作的就是修改对应文件夹下的redis.conf文件。</p><pre><code>port 6379 #不同目录，这里端口对应不同cluster-enabled yes #开启集群功能cluster-config-file nodes.conf #节点配置文件，这个文件是服务启动时自己配置创建的cluster-node-timeout 6000appendonly yes</code></pre><p>建议将conf文件中的save字段都屏蔽了，在使用过程中，发现开启之后，redis写rdb文件的时候对集群性能有很大影响。</p><h3 id="集群-走起"><a href="#集群-走起" class="headerlink" title="集群 走起"></a>集群 走起</h3><p>上边的步骤，完成了集群搭建的准备工作。下边要开始运行起来了！<br>先把三个redis实例启动起来。</p><pre><code>[root@localhost src]# ps -ef | grep redisroot      18979  18297  0 14:24 pts/0    00:00:00 ./redis-server *:6379 [cluster]root      19094  19057  0 14:25 pts/4    00:00:00 ./redis-server *:6380 [cluster]root      19181  19146  0 14:25 pts/7    00:00:00 ./redis-server *:6381 [cluster]</code></pre><p>键入 ps -ef | grep redis 可以看到三个redis实例都在运行。<br>接下来使用redis-trib.rb来将三个实例连接起来。</p><pre><code>[root@localhost src]# cd /usr/local/redis-3.0.3/src/[root@localhost src]# ./redis-trib.rb create --replicas 0 127.0.0.1:6379 127.0.0.1:6380 127.0.0.1:6381</code></pre><p>终端会有这样的显示：</p><pre><code>&gt;&gt;&gt; Performing hash slots allocation on 3 nodes...Using 3 masters:127.0.0.1:6379127.0.0.1:6380127.0.0.1:6381M: 4ee119039aebd0e1d48b3f52149a7940db34c6fb 127.0.0.1:6379   slots:0-5460 (5461 slots) masterM: f6ad85a038a05e297130f6e112e223db54c47ea5 127.0.0.1:6380   slots:5461-10922 (5462 slots) masterM: 0b97e4a7f8e5ced1f2f2471694b76dcf77ce1fc7 127.0.0.1:6381   slots:10923-16383 (5461 slots) masterCan I set the above configuration? (type &apos;yes&apos; to accept):</code></pre><p>键入 yes </p><pre><code>&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to join the clusterWaiting for the cluster to join.&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:6379)M: 4ee119039aebd0e1d48b3f52149a7940db34c6fb 127.0.0.1:6379   slots:0-5460 (5461 slots) masterM: f6ad85a038a05e297130f6e112e223db54c47ea5 127.0.0.1:6380   slots:5461-10922 (5462 slots) masterM: 0b97e4a7f8e5ced1f2f2471694b76dcf77ce1fc7 127.0.0.1:6381   slots:10923-16383 (5461 slots) master[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.</code></pre><p>测试一下，集群是否正常工作。</p><pre><code>[root@localhost src]# ./redis-cli -c -h 127.0.0.1 -p 6379127.0.0.1:6379&gt; set key values-&gt; Redirected to slot [12539] located at 127.0.0.1:6381OK</code></pre><p>这样，集群就算搭建完成了。哈哈哈。</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>至此，整个服务器缓存流程中的数据库部分已经搭建完毕，接下来要配置的是Web服务器和PHP的安装配置，我会在后续的文章中继续更新。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mongodb </tag>
            
            <tag> Nginx </tag>
            
            <tag> Redis </tag>
            
            <tag> Lua </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>送给自己</title>
      <link href="/2015/07/31/%E9%80%81%E7%BB%99%E8%87%AA%E5%B7%B1/"/>
      <url>/2015/07/31/%E9%80%81%E7%BB%99%E8%87%AA%E5%B7%B1/</url>
      
        <content type="html"><![CDATA[<p><strong>总有一天，你将破茧而出</strong><br><strong>成长的比人们期待的还要美丽</strong></p><p><strong>但这个过程会很痛</strong><br><strong>会很辛苦</strong></p><p><strong>面对着汹涌而来的现实</strong><br><strong>觉得自己渺小无力</strong></p><p><strong>但这 也是生命的一部分</strong><br><strong>做好现在你能做的 然后 一切都会好的</strong><br><strong>我们都将孤独地长大 不要害怕</strong></p>]]></content>
      
      
      <categories>
          
          <category> 心情文字 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
